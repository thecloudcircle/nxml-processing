
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>Molecular Diversity Preservation International (MDPI)</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">27879862</article-id><article-id pub-id-type="pmc">3675528</article-id><article-id pub-id-type="doi">10.3390/s8053005</article-id><article-id pub-id-type="publisher-id">sensors-08-03005</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>PAU/GNSS-R: Implementation, Performance and First Results of a Real-Time Delay-Doppler Map Reflectometer Using Global Navigation Satellite System Signals</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Marchan-Hernandez</surname><given-names>Juan Fernando</given-names></name><xref ref-type="corresp" rid="c1-sensors-08-03005"><sup>*</sup></xref></contrib><contrib contrib-type="author"><name><surname>Camps</surname><given-names>Adriano</given-names></name></contrib><contrib contrib-type="author"><name><surname>Rodriguez-Alvarez</surname><given-names>Nereida</given-names></name></contrib><contrib contrib-type="author"><name><surname>Bosch-Lluis</surname><given-names>Xavier</given-names></name></contrib><contrib contrib-type="author"><name><surname>Ramos-Perez</surname><given-names>Isaac</given-names></name></contrib><contrib contrib-type="author"><name><surname>Valencia</surname><given-names>Enric</given-names></name></contrib><aff id="af1-sensors-08-03005"> Remote Sensing Lab, Dept. Teoria del Senyal i Comunicacions, Campus Nord D3, Universitat Politecnica de Catalunya, 08034 Barcelona, Spain</aff></contrib-group><author-notes><corresp id="c1-sensors-08-03005"><label>*</label> Author to whom correspondence should be addressed; E-mail: <email>jfmarchan@tsc.upc.edu</email></corresp></author-notes><pub-date pub-type="collection"><month>5</month><year>2008</year></pub-date><pub-date pub-type="epub"><day>06</day><month>5</month><year>2008</year></pub-date><volume>8</volume><issue>5</issue><fpage>3005</fpage><lpage>3019</lpage><history><date date-type="received"><day>16</day><month>11</month><year>2007</year></date><date date-type="accepted"><day>24</day><month>4</month><year>2008</year></date></history><permissions><copyright-statement>&#x000a9; 2008 by the authors; licensee Molecular Diversity Preservation International, Basel, Switzerland.</copyright-statement><copyright-year>2008</copyright-year><license><license-p>This article is an open-access article distributed under the terms and conditions of the CreativeCommons Attribution license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>).</license-p></license></permissions><abstract><p>Signals from Global Navigation Satellite Systems (GNSS) were originally conceived for position and speed determination, but they can be used as signals of opportunity as well. The reflection process over a given surface modifies the properties of the scattered signal, and therefore, by processing the reflected signal, relevant geophysical data regarding the surface under study (land, sea, ice&#x02026;) can be retrieved. In essence, a GNSS-R receiver is a multi-channel GNSS receiver that computes the received power from a given satellite at a number of different delay and Doppler bins of the incoming signal. The first approaches to build such a receiver consisted of sampling and storing the scattered signal for later post-processing. However, a real-time approach to the problem is desirable to obtain immediately useful geophysical variables and reduce the amount of data. The use of FPGA technology makes this possible, while at the same time the system can be easily reconfigured. The signal tracking and processing constraints made necessary to fully design several new blocks. The uniqueness of the implemented system described in this work is the capability to compute in real-time Delay-Doppler maps (DDMs) either for four simultaneous satellites or just one, but with a larger number of bins. The first tests have been conducted from a cliff over the sea and demonstrate the successful performance of the instrument to compute DDMs in real-time from the measured reflected GNSS/R signals. The processing of these measurements shall yield quantitative relationships between the sea state (mainly driven by the surface wind and the swell) and the overall DDM shape. The ultimate goal is to use the DDM shape to correct the sea state influence on the L-band brightness temperature to improve the retrieval of the sea surface salinity (SSS).</p></abstract><kwd-group><kwd>GPS reflectometry</kwd><kwd>Delay-Doppler Maps (DDM)</kwd><kwd>sea state</kwd><kwd>digital design</kwd><kwd>embedded system</kwd><kwd>real-time</kwd><kwd>field-programmable gate array (FPGA)</kwd></kwd-group></article-meta></front><body><sec><label>1.</label><title>Introduction</title><p>Remote sensing sensors allow retrieving geophysical parameters that are interesting from both scientific and commercial points of view, such as sea surface salinity, soil moisture, sea state or altimetry products. On the other hand, Global Navigation Satellite Systems (GNSS) cover the Earth with their navigation signals, used nowadays in a wide range of everyday situations, such as fleet management, vehicle guidance or leisure/outdoors interactive maps. However, as first proposed in [<xref ref-type="bibr" rid="b1-sensors-08-03005">1</xref>] nearly fifteen years ago, these navigation signals can also be received and processed after reflecting on a certain surface to retrieve altimetry information. This approach, in short known as GNSS-R, allows inexpensively and remotely sensing other geophysical parameters over wide areas of the Earth's surface [<xref ref-type="bibr" rid="b2-sensors-08-03005">2</xref>-<xref ref-type="bibr" rid="b4-sensors-08-03005">4</xref>]. This is possible because the scattering mechanism &#x02018;watermarks&#x02019; the signal so that the geophysical information regarding the reflecting surface is added to it. A very straightforward example is that of the soil moisture retrieval. The water content is related to the soil dielectric constant, which is related to the reflection coefficient. Therefore, the ratio between the incident and the reflected power of the GNSS signal can be indirectly linked to the soil moisture content.</p><p>To the present day only the GPS constellation has been fully deployed, and therefore mostly all the GNSS-R receivers built so far rely on that particular system (other GNSS are the Russian GLONASS or the European GALILEO). More specifically, the Standard Positioning Service (SPS) GPS signal broadcast at the L1 frequency (1575.42 MHz) has the following expression [<xref ref-type="bibr" rid="b5-sensors-08-03005">5</xref>]:
<disp-formula id="FD1"><label>(1)</label><mml:math id="mm1"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>L</mml:mi><mml:mn>1</mml:mn><mml:mo>,</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>sin</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:msub><mml:mi>f</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic>CA(t)</italic> is a pseudo-random code unique to each satellite, <italic>D(t)</italic> is a low-speed navigation data signal, and <italic>f<sub>c</sub></italic> is the carrier frequency. The relative motion between emitter and receiver shifts the carrier frequency of the received signal:
<disp-formula id="FD2"><label>(2)</label><mml:math id="mm2"><mml:mrow><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mtext mathvariant="italic">rec</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>D</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>sin</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>c</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>being <italic>f<sub>d</sub></italic> the value of this Doppler frequency shift. The advantage of the instrument described in this work is that the observable is the whole Delay-Doppler Map (DDM), which is the correlation of the incoming signal with a replica of the CA code for several Doppler and code values<xref ref-type="fn" rid="fn1-sensors-08-03005"><sup>1</sup></xref>:
<disp-formula id="FD3"><label>(3)</label><mml:math id="mm3"><mml:mrow><mml:mtext mathvariant="italic">DDM</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>&#x0222b;</mml:mo><mml:mn>0</mml:mn><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>S</mml:mi><mml:mrow><mml:mi>a</mml:mi><mml:mo>,</mml:mo><mml:mtext mathvariant="italic">rec</mml:mtext></mml:mrow></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:msup><mml:mi>e</mml:mi><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mi>j</mml:mi><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:msub><mml:mi>f</mml:mi><mml:mi>d</mml:mi></mml:msub><mml:mi>t</mml:mi></mml:mrow></mml:msup><mml:mo>&#x022c5;</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:munderover><mml:mo>&#x0222b;</mml:mo><mml:mn>0</mml:mn><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:munderover><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mi>Q</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>t</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003c4;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x022c5;</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mo>cos</mml:mo><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mo>&#x02213;</mml:mo><mml:mi>j</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mtext mathvariant="italic">sen</mml:mtext><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo stretchy="true">|</mml:mo><mml:mrow><mml:msub><mml:mi>f</mml:mi><mml:mi>d</mml:mi></mml:msub></mml:mrow><mml:mo stretchy="true">|</mml:mo></mml:mrow><mml:mi>t</mml:mi></mml:mrow><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo>&#x022c5;</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where the analytic signal <italic>S<sub>a,rec</sub></italic> = <italic>I</italic> + <italic>jQ</italic> has been used. In radar terminology the DDM is known as the Woodward ambiguity function [<xref ref-type="bibr" rid="b6-sensors-08-03005">6</xref>]. The DDM is a complex two-dimensional function, and this presents some implications when trying to average several DDMs.</p><p>The navigation data signal <italic>D</italic>(<italic>t</italic>) (<xref rid="FD1" ref-type="disp-formula">Eqns.1</xref> and <xref rid="FD2" ref-type="disp-formula">2</xref>) has a data rate of 50 bit/s; i.e, every 20 ms there may be a polarity inversion on the received signal due to the transmission of a navigation bit. This may cause the GPS signal not to be detected if not taken into account properly. Usually the GPS receivers decode the navigation message, and are able to determine the position of this sign transition. However, in this GNSS-R implementation the navigation message is not decoded. That means that 1 out of 20 1 ms-based DDMs may be erroneous. This should not be an issue, but whenever coherently averaging a number of DDMs to improve the SNR, a common situation whenever working with low SNR GNSS-R signals, the sign change may cause an overall SNR decrease after integration. A rule-of-thumb coherence time for the sea surface at L-band is on the order of 5-10 ms [<xref ref-type="bibr" rid="b7-sensors-08-03005">7</xref>], although it can be larger for calm seas. Therefore, an upper bound for the number of DDM to be coherently added will be between 5 and 10. In addition to this, the incoherent (module) average can last for a longer time, provided that the code and Doppler shifts due to the relative motion between emitter and receiver are accounted for.</p><p>The emitted GPS signal is right-hand circularly polarized (RHCP). However, after reflecting on the sea surface, it becomes mostly left hand circularly polarized (LHCP), with a certain degree of ellipticity due to the difference between the vertical and horizontal reflection coefficients. The PAU receiver antennas [<xref ref-type="bibr" rid="b8-sensors-08-03005">8</xref>] are sensitive to both the horizontal and vertical linear polarizations, and it is the digital receiver that composes the LHCP from the vertical and horizontal ones. Therefore, it is of capital importance to undertake a phase and amplitude calibration before composing the required polarization.</p><p>The PAU system [<xref ref-type="bibr" rid="b8-sensors-08-03005">8</xref>, <xref ref-type="bibr" rid="b9-sensors-08-03005">9</xref>] operates completely with digitized signals. The sampling frequency determines how many samples constitute the minimum &#x02018;data strip&#x02019; to be used. Because the length of the C/A codes is 1 ms, and the sampling frequency for the whole of the PAU system [<xref ref-type="bibr" rid="b8-sensors-08-03005">8</xref>] is 5.745 MHz, each data strip has 5745 samples, sampled at 1 bit<xref ref-type="fn" rid="fn2-sensors-08-03005"><sup>2</sup></xref>. This severe quantification of the input signal has a little effect on the GPS signal, just a small loss in signal-to-noise ratio (SNR)<xref ref-type="fn" rid="fn3-sensors-08-03005"><sup>3</sup></xref>, while it allows for a much simpler design.</p><p>From <xref rid="FD3" ref-type="disp-formula">Eqn. 3</xref> it is clear that each delay-Doppler coordinate of a DDM can be obtained from the combination and accumulation of four <italic>partial products</italic>:
<disp-formula id="FD4"><label>(4a)</label><mml:math id="mm4"><mml:mrow><mml:mtext mathvariant="italic">DDM</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mo>int</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>I</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">COS</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>Q</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">SIN</mml:mo><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>Q</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">COS</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>I</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">SIN</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022c5;</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mi>d</mml:mi><mml:mo>&#x0003e;</mml:mo><mml:mn>0</mml:mn><mml:mtext mathvariant="italic">Hz</mml:mtext></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD5"><label>(4b)</label><mml:math id="mm5"><mml:mrow><mml:mtext mathvariant="italic">DDM</mml:mtext><mml:mo>=</mml:mo><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mrow><mml:mo>int</mml:mo></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>I</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">COS</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>Q</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">SIN</mml:mo><mml:mo>+</mml:mo><mml:mi>j</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>Q</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">COS</mml:mo><mml:mo>+</mml:mo><mml:mtext mathvariant="italic">CA</mml:mtext><mml:mo>&#x022c5;</mml:mo><mml:mi>I</mml:mi><mml:mo>&#x022c5;</mml:mo><mml:mo mathvariant="italic">SIN</mml:mo></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022c5;</mml:mo><mml:mi>d</mml:mi><mml:mi>t</mml:mi><mml:mo>,</mml:mo><mml:mi>f</mml:mi><mml:mi>d</mml:mi><mml:mo>&#x0003c;</mml:mo><mml:mn>0</mml:mn><mml:mtext mathvariant="italic">Hz</mml:mtext></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <italic>CA</italic> stands for the GPS C/A code, <italic>I</italic>/<italic>Q</italic> for the in-phase &#x00026; quadrature signal components, and <italic>SIN</italic>/<italic>COS</italic> for the demodulating tones at the Doppler frequency.</p><p>The Very High Definition Level digital logic description language (VHDL) approach generates the <italic>C</italic>/<italic>A</italic> codes corresponding to all the delay coordinates, the demodulating tones associated to all the Doppler coordinates, and then combines them with the I/Q inputs to form the four <italic>partial products</italic> (<xref rid="FD4" ref-type="disp-formula">Eqn. 4</xref>) needed to compute the complex DDM.</p><p>The goal of implementing this reflectometer-DDM generator [<xref ref-type="bibr" rid="b8-sensors-08-03005">8</xref>, <xref ref-type="bibr" rid="b10-sensors-08-03005">10</xref>] is to obtain quantitative relationships between the sea state (mainly driven by the surface wind and the swell) and the overall DDM shape. It is expected that this would make possible to correct the sea state influence on the L-band brightness temperature to improve the retrieval of the sea surface salinity (SSS).</p><p>This work is divided as follows: Section 2 reviews thoroughly the system architecture, whereas section 3 deals with the preliminary results. Finally, section 4 addressees the conclusions and future research lines of the present work.</p></sec><sec><label>2.</label><title>GNSS-R Reflectometer Architecture</title><p>Most of the existing GNSS-R receiver architectures just measure the correlation peak or the cut in the delay axis of the DDMs once the Doppler frequency has been compensated, which is called a &#x02018;waveform&#x02019;. This section describes the architecture of an FPGA-based real-time GPS reflectometer that computes the full two-dimensional DDM every 1 ms and performs the coherent and incoherent averaging. The core of the system is a full-custom designed DDM generator that interacts with other in-house and off-the-shelf VHDL cores.</p><p>The main dataflow path of the system is that of the reflected GPS signal (<xref ref-type="fig" rid="f1-sensors-08-03005">Fig. 1</xref>). The PAU-RAD [<xref ref-type="bibr" rid="b11-sensors-08-03005">11</xref>] section of the instruments sends the digitized and quantized I/Q raw data corresponding to the particular beams composed (1 or 4) to a buffer located in the reflectometer FPGA. This buffer plays a key role in the system, since it allocates the two I/Q 5745-sample strips for the up to 4 selected beams, to allow them to be processed at a higher clock rate using hardware reuse techniques. The buffer is based in two RAM-like registers that change their respective inputs and output connections. One is being written while the other is being read to generate the DDM. When the input register is full, it is swapped with the other one. From here the data is sent in blocks of 1 ms (5745 samples at the sampling frequency of the system corresponding to the period of the C/A code) to the DDM generator. Then, once the new DDM is ready, it is sent out of the system to a terminal computer, where it will be processed and stored. The transfer of up to four complex-valued DDMs every 1 ms is performed using the USB 2.0 protocol. The resulting throughput is 2 (real and imaginary parts) times 32 bits per point times 4 beams times 16 x 16 points = 8 Kbytes every 1 ms, that is 7.8 MB/s. In fact, in addition to the DDM data, the time tag of the raw data and the delay and Doppler center coordinates used for its computation are transmitted as well, since not all of the 32 bytes are used to code the DDM point values. Whenever the first of the 4 DDMs has been successfully received by the host computer, an interrupt is issued in the reflectometer system by the USB FPGA controller and the parameters for the generation of the next DDM are transferred to the DDM generator, which starts the computation using the data of the corresponding beam. After 5745 clock cycles (1 ms of data) the DDM generator activates the &#x02018;data_ready&#x02019; signal. The microprocessor program asks the USB controller to read the DDM values from the output interface of the DDM generator, and to send these values to the host PC, closing the cycle of processing and data transfer. The integration time can be freely configured, since every 1 ms a new DDM is obtained. It is up to the receiving program to accumulate as many of them as configured, either coherently (in amplitude and phase) or incoherently (in absolute values).</p><p>The direct signal from the satellite is also processed to obtain an accurate estimate of the signal delay. To do so an upwards-looking GPS antenna receives the signal and feeds it into an A/D converter. A second buffer stores these data until they are sent to a &#x02018;delay offset&#x02019; block that estimates the delay offset.</p><p>A third dataflow path is that of the data packets generated by a commercial GPS receiver. They enter the FPGA using an RS-232 interface using the GPS-standard TSIP protocol, and provide the system with parameters of interest such as the elevation, azimuth, power level, and Doppler of the visible satellites, simplifying to a large extent the FPGA design.</p><sec><label>2.1.</label><title>Hardware Setup</title><p>The reflectometer system has been implemented using the AVNet VIRTEX-4 LX 60 development board that includes the FPGA core, SDRAM RAM (32 MB), Flash ROM (8 MB), an UART serial interface, an USB 2.0 serial interface, an Ethernet connection, an OLED display and several other connectors. Inside the FPGA a microprocessor, data bus and RAM system is synthetized. Several peripherals are attached to the bus [<xref ref-type="bibr" rid="b10-sensors-08-03005">10</xref>]. The most relevant is the DDM generator, which performs the Doppler compensation and the integration (<xref rid="FD3" ref-type="disp-formula">Eqn. 3</xref>). The core of this generator is shown in <xref ref-type="fig" rid="f2-sensors-08-03005">Fig. 2</xref>. It is a synchronous block that receives the I/Q samples in a serial fashion, as well as the Doppler values and C/A code samples for all the DDM points. The outcome are the four <italic>partial products</italic> (<xref rid="FD3" ref-type="disp-formula">Eqn. 4</xref>) that are conveniently added or subtracted (depending on the sign of the Doppler shift) and accumulated during 5745 clock cycles (1 ms of data) to obtain the real and imaginary parts of each DDM coordinate. In <xref ref-type="fig" rid="f2-sensors-08-03005">Fig. 2</xref> it is seen that the I, Q and C/A code inputs are delayed by means of shift registers so that they are synchronized with the demodulating tones generated in the block <italic>signs_and_amplitudes</italic> (<xref ref-type="fig" rid="f3-sensors-08-03005">Fig. 3a</xref>). The values fed to this component determine the Doppler frequencies that are generated (they are the multiplying factors of the base frequency of the block), and thus the sign (1 bit) and amplitude (7 bits) of each frequency are obtained. Then, the block <italic>signs_combinations</italic> generates, for each DDM point, the sign of the four <italic>partial products</italic> that compose it (<italic>CA.I.SIN, CA.I.COS, CA.Q.SIN</italic> and <italic>CA.Q.COS</italic>). The core of this component is the <italic>oscillator</italic> block (<xref ref-type="fig" rid="f3-sensors-08-03005">Fig. 3b</xref>), that every clock cycle computes one sine and one cosine sample, at a frequency set by the input value <italic>&#x003b1;</italic>. To do so every clock cycle the value of the variable <italic>full_phase</italic> is increased in <italic>&#x003b1;</italic> units (<xref ref-type="fig" rid="f3-sensors-08-03005">Fig. 3b</xref>). The 9 most significant bits (<italic>trunc_phase</italic>) out of 18 are then fed into the <italic>oscillator_sinc</italic> block to generate the <italic>sin</italic> and <italic>cos</italic> outputs. This allows having a smaller frequency step without having to use a large number of bits to quantify the phase that is converted into sine/cosine amplitude. The <italic>oscillator_sinc</italic> component is located at the bottom of the hierarchy level. To efficiently generate the sine and cosine values, it has been taken into account that the output signal shall be quantized with a finite number of levels. The first Most Significant Bit (MSB) tells whether the sine value is positive or negative, whereas the second MSB has information on the slope sign (<xref ref-type="fig" rid="f4-sensors-08-03005">Fig. 4</xref>). The remaining 7 bits indicate the position within the first wave quarter. Instead of dividing the amplitude in equal-length intervals, the phase domain has been divided in such a way, so that the 7-bit phase of the wave quarter have a linear correspondence with the 7 bits that codify the amplitude. Therefore, if no further correction were made a triangular wave would be obtained. A correction for each level (from 0 to 127) that minimizes the error when comparing it with an ideal quantized sine has been computed, and it is then added to it. At the same time, the cosine is obtained by negating the 7 LSB's of the truncated phase, thus obtaining the complementary level:
<disp-formula id="FD6"><label>(5)</label><mml:math id="mm6"><mml:mrow><mml:msub><mml:mtext mathvariant="italic">Level</mml:mtext><mml:mrow><mml:mo mathvariant="italic">cos</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>127</mml:mn><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mtext mathvariant="italic">Level</mml:mtext><mml:mrow><mml:mo mathvariant="italic">sin</mml:mo><mml:mspace width="1.0em"/></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The cosine sign (the MSB of <italic>cos</italic>) is computed as the exclusive OR of the sine's two MSB:
<disp-formula id="FD7"><label>(6)</label><mml:math id="mm7"><mml:mrow><mml:msub><mml:mtext mathvariant="italic">MSB</mml:mtext><mml:mrow><mml:mo mathvariant="italic">cos</mml:mo></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mtext mathvariant="italic">MSB</mml:mtext><mml:mrow><mml:mo mathvariant="italic">sin</mml:mo><mml:mspace width="0.4em"/></mml:mrow></mml:msub><mml:mtext>xor</mml:mtext><mml:msub><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">MSB</mml:mtext><mml:mrow><mml:mo>&#x02212;</mml:mo></mml:mrow><mml:mn>1</mml:mn></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo mathvariant="italic">sin</mml:mo><mml:mspace width="1.0em"/></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>The sine and cosine waveforms are generated with 8-bit, since the preliminary simulations indicated that using fewer bits resulted in a severe DDM deformation.</p><p>The simultaneous generation of several different-delay C/A codes is achieved with the block <italic>CA_generator</italic> (<xref ref-type="fig" rid="f2-sensors-08-03005">Figs. 2</xref> and <xref ref-type="fig" rid="f5-sensors-08-03005">5</xref>). As explained in [<xref ref-type="bibr" rid="b5-sensors-08-03005">5</xref>], these codes are the product of two Maximum Length Sequences (MLS) <italic>G<sub>1</sub></italic> and <italic>G<sub>2</sub></italic> obtained using their respective linear feedback shift registers (LFSR). The satellite unique C/A code is determined by the delay of <italic>G<sub>2</sub></italic> with respect to the non-delayed <italic>G<sub>1</sub></italic>. Therefore, to obtain a C/A code delayed n chips, it is necessary to generate a <italic>G<sub>1</sub></italic> sequence delayed n chips and also a <italic>G<sub>2</sub></italic> sequence delayed n chips plus the offset that determines the satellite ID. To obtain these delayed sequences the 10-bit <italic>M<sub>1</sub></italic> and <italic>M<sub>2</sub></italic> masks determine the values of the <italic>G<sub>1</sub></italic> and <italic>G<sub>2</sub></italic> registers that are used to obtain the delayed outputs. These masks are pre-calculated using state-transition matrices, and are stored for all the possible 1022 chip-shift values [<xref ref-type="bibr" rid="b12-sensors-08-03005">12</xref>]:
<disp-formula id="FD8"><label>(7)</label><mml:math id="mm8"><mml:mrow><mml:msub><mml:mi>M</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mover accent="true"><mml:mi>p</mml:mi><mml:mo>&#x02192;</mml:mo></mml:mover><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mn>1</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:mtext mathvariant="italic">ID</mml:mtext></mml:mrow></mml:mtd><mml:mtd><mml:mover accent="true"><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo></mml:mover></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:mo>&#x022c5;</mml:mo><mml:msub><mml:mi>M</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mspace width="1.0em"/><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <italic>M<sub>i</sub></italic>(<italic>n</italic>) is the mask corresponding to the i<sub>th</sub> sequence (<italic>i</italic> =1, 2) with a delay of <italic>n</italic> chips, <italic>&#x00070;&#x020d7;<sub>i</sub></italic> is a row vector containing the coefficients of the polynomial representing the <italic>G<sub>i</sub></italic> LFSR (0010000001 for G<sub>1</sub> and 0110010111 for G<sub>2</sub>), ID is the square 9-element identity matrix, &#x00030;&#x020d7; is a 9-element zero's column vector and <italic>M<sub>0</sub></italic> is the mask for a delay offset of 0 chips ( 0000000001). Thus, the <italic>M<sub>1</sub></italic> and <italic>M<sub>2</sub></italic> masks contain not only the C/A code delay offset value, but also the satellite ID to be generated. On the other hand, to allow for a code resolution smaller than one chip the block <italic>resampler</italic> was conceived (<xref ref-type="fig" rid="f5-sensors-08-03005">Fig. 5</xref>). Since the system's sampling frequency is 5.745 MHz and the period of the C/A code is 1 ms for 1023 chips, the relation &#x02018;samples per chip&#x02019; is 5745/1023, which is equivalent to the irreducible fractional form of 1915/341. Therefore, a modulo-1915 counter increases in 341 units every clock cycle. When the counter &#x0201c;rolls-up&#x0201d; a pulse to drive the <italic>G<sub>1</sub></italic> and <italic>G<sub>2</sub></italic> LFSRs is issued (<italic>pulse_CA</italic> signal in <xref ref-type="fig" rid="f5-sensors-08-03005">Fig. 5</xref>). The initial value of this counter is related to the non-integer desired code delay. For instance, a non-integer chip value of 0.4 chips would correspond to an initial value of 0.4 x 1915 = 766 units.</p><p>Another capital core of the designed embedded system is the buffer for the reflected signal. Both the direct signal buffer and the reflected signal buffer share the same design (<xref ref-type="fig" rid="f1-sensors-08-03005">Fig. 1</xref>). It receives the multiplexed GPS data from PAU-RAD and demultiplexes it so that a DDM for a single beam can be processed at a time. This peripheral is composed of two storage units that alternatively switch their input and output ports. Whenever one is receiving and storing the I/Q data the other is being unloaded (one of the four beams at a time) to compute a new DDM. The clock frequency to receive the data bits is four times the sampling frequency of the data to allow the simultaneous storage of the data of four different beams. On the other hand, the unloading of the raw data and the generation of the DDM are performed at the clock frequency of the reflectometer (100 MHz), which is significantly higher than that of the incoming data (23 MHz). Thus again, hardware reuse is possible and up to four satellites can be processed in 1 ms. The switching between the storage units takes place whenever the one being written reaches its capacity limit (i.e, 5745 samples for each of the four beams), and an interrupt is issued by the buffer. This interrupt has top priority, since no data loss is allowed, and it triggers the generation of the DDMs associated to the data of the 1 ms under consideration. To achieve this, it is necessary to translate the delay and Doppler values of the signals received from different satellites to a set of parameters (the masks M1 and M2 of the LFSR's that determine the satellite ID and the C/A code offset, and the &#x003b1; values that determine the step of the frequency synthesizers that compensate the Doppler shifts), and send them to the DDM generator before the computation of a DDM.</p><p>In order to have the DDM maximum in the center of the window of delay and Doppler values it is necessary to have a good estimate of the delay and Doppler frequency of the received signal. At low and moderate altitudes the Doppler maximum value for both direct and reflected signals is roughly the same, and the difference lies only in the magnitude of the Doppler spread. Taking this into account, and also considering that the temporal derivative of these Doppler shifts (&#x0223c; 1 Hz/s [<xref ref-type="bibr" rid="b5-sensors-08-03005">5</xref>]) is much smaller than the 1 s update rate of the parameters provided by the GPS receiver, its value can be used straightforwardly as the Doppler center value. Unfortunately the situation is quite the opposite when it comes to the delay value: it is necessary to estimate the delay difference between the direct and reflected signals from the transmitter-receiver geometry. For example, in the simplest case of a low altitude receiver at constant height <italic>h</italic> the excess delay is:
<disp-formula id="FD9"><label>(8)</label><mml:math id="mm9"><mml:mrow><mml:mi>&#x00394;</mml:mi><mml:mi>&#x003c4;</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>h</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:mfrac><mml:mo>cos</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mspace width="1.0em"/><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>being <italic>&#x003b8;</italic> the zenith angle and <italic>c</italic> the light speed. This value must be added to the direct signal delay to obtain the reflected signal delay. However, the temporal derivative of the delay cannot be neglected over the 1 s update interval. Therefore, should the delay value obtained through the serial interface be used, the maximum of the DDM will move along the delay domain at a speed depending on the satellite's position until eventually getting out of view. This drift is very inconvenient, since integration is needed to improve the low SNR of the reflected signal. If the peak moves, the integration will only further degrade the waveform. Therefore it is of capital importance to have readily available an estimate for the delay updated the more frequently the better. To do so a whole new block is required to perform the circular correlation by means of Fast Fourier Transform operations to find the maximum of the correlation of the direct signal with clean CA code replicas for four different satellites simultaneously. The equation applied is [<xref ref-type="bibr" rid="b5-sensors-08-03005">5</xref>]:
<disp-formula id="FD10"><label>(9)</label><mml:math id="mm10"><mml:mrow><mml:msub><mml:mi>R</mml:mi><mml:mrow><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mtext mathvariant="italic">ca</mml:mtext></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext mathvariant="italic">IFFT</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">FFT</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mi>x</mml:mi><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#x022c5;</mml:mo><mml:mtext mathvariant="italic">IFFT</mml:mtext><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext mathvariant="italic">ca</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo><mml:mspace width="1.0em"/></mml:mrow><mml:mo>,</mml:mo></mml:mrow></mml:math></disp-formula>where <italic>x</italic> is the baseband complex signal <italic>I</italic> + <italic>j</italic>&#x000b7;<italic>Q</italic>. Before computing such a correlation it is necessary to compensate the respective Doppler offsets by using the data provided by the uplooking GPS receiver and to generate for each of the four satellites a local replica with zero delay offset of their C/A codes. This block has been implemented with standard Fast Fourier Transform (FFT) and complex multiplier cores, ensuring its performance and preventing an excessive use of the FPGA resources (<xref ref-type="fig" rid="f6-sensors-08-03005">Fig. 6</xref>). Since the number of samples (5745 samples for 1 ms of sampled data) is not a power of 2, as needed to perform an FFT, it is necessary to fill the data values until reaching 8192 = 2&#x002c6;13 samples. This results in two correlation maxima instead of only one. What is more, the amplitude of these maxima is position dependent. Fortunately these peaks are always spaced by the same amount of samples (8192-5745 = 2447 samples, as shown in <xref ref-type="fig" rid="f7-sensors-08-03005">Fig. 7a</xref>). Therefore, if the resulting value lays above a certain threshold, it would be necessary to subtracts from it those 2447 samples to obtain the actual offset value. If the value lays beneath the threshold, then it is already the value being searched (<xref ref-type="fig" rid="f7-sensors-08-03005">Fig. 7b</xref>).</p></sec><sec><label>2.2.</label><title>Software Setup</title><p>The coordinated operation of all the peripherals that compose the reflectometer is ensured by the program running on the MicroBlaze soft processor. This code is written in ANSI C, and controls the GPS incoming data through the UART, the selection of the satellites, the generation of the DDM parameters and the signaling of the beginning of a new DDM computation. This program also transfers the DDM generation parameters to the DDM generator (the masks <italic>M<sub>1</sub></italic> and <italic>M<sub>2</sub></italic> of the LFSR's that determine the satellite ID and the C/A code offset, and the &#x003b1; values that determine the step of the frequency synthesizers that compensate the Doppler shifts). To do so these inputs are mapped to a RAM-like register at the DDM generator side. Then the read/write operations are performed by simply addressing to the DDM generator's address space. Another task of the code is the decoding of the data packets received from the commercial GPS receiver through the RS-232 link. These packets contain information on the available satellites and their respective delay, Doppler, power, elevation and azimuth values. From these values both the parameters to be fed to the DDM generator and the most suitable array beam for a given satellite are determined. Since it is another PAU system (PAU-RAD [<xref ref-type="bibr" rid="b11-sensors-08-03005">11</xref>]) that is in charge for the beamforming, the beam selection is transmitted to it through a dedicated communication channel. To do so the elevation-azimuth space is divided according to a grid and a beam number is assigned to each region.</p><p>The program defines several constants such as the DDM resolution (step in both the delay and Doppler domains), the sampling frequency of the incoming data and a set of conversion factors (i.e., to convert from chips to samples). At the same time, the system variables and structures are also defined. They include the packet structures used to interact with the commercial GPS receiver, the masks of the LFSRs that generate the CA code with a certain delay, or a vector of the selected satellites to work with. The system functions can be grouped in three sets:
<list list-type="bullet"><list-item><p>The first one includes those that send and receive data from the GPS receiver,</p></list-item><list-item><p>A second set selects which of the available satellites are to be used, taking into account their power and position, and finally</p></list-item><list-item><p>Another set of critical functions computes the DDM parameters and transfers them to the DDM generator.</p></list-item></list></p><p>The system has two sources of interrupts (<xref ref-type="fig" rid="f8-sensors-08-03005">Fig. 8</xref>). The buffer for the reflected signal (<xref ref-type="fig" rid="f1-sensors-08-03005">Fig. 1</xref>) issues an interrupt every 1 ms (i.e., whenever new data is available). This Interrupt Service Routine (ISR) plays an important role in the overall operation of the reflectometer, since the buffer interrupt is the synchronism reference of the system. It comprises the following tasks:
<list list-type="bullet"><list-item><p>First, the UART interrupts are disabled,</p></list-item><list-item><p>Then, for each of the four simultaneous beams/satellites, the buffer is notified which beam has to dump next,</p></list-item><list-item><p>The corresponding DDM parameters are set into the DDM generator,</p></list-item><list-item><p>The generation of the DDM is triggered,</p></list-item><list-item><p>The system waits until the <italic>DDM_ready</italic> signal goes high,</p></list-item><list-item><p>Then the DDM data sending through the USB controller is enabled,</p></list-item><list-item><p>The ISR waits for the USB controller to assert that the sending process is finished, and finally</p></list-item><list-item><p>Before returning to the main function the UART interrupts are again enabled.</p></list-item></list></p><p>The RS-232 serial port controller issues an interrupt every time new data arrives from the GPS receiver:
<list list-type="bullet"><list-item><p>First of all, its associated ISR disables the UART interrupts,</p></list-item><list-item><p>Then it reads from the UART buffer all the available data bytes and parses them to decode the TSIP report packets,</p></list-item><list-item><p>Also, depending on the value of a counter, new Elevation &#x00026; Azimuth packets are requested, and finally</p></list-item><list-item><p>Before returning to the main program the interrupts for the UART are enabled.</p></list-item></list></p><p>The main program initializes the system and waits for interrupts:
<list list-type="bullet"><list-item><p>First, the UART interrupts are enabled in the RS-232 controller,</p></list-item><list-item><p>Then a configuration command TSIP packet is sent to the GPS receiver, so that it outputs the raw data packet every 1 second,</p></list-item><list-item><p>The satellite table is initialized and its associated DDM parameters are retrieved,</p></list-item><list-item><p>The interrupts in the microprocessor and in the interrupt controller are enabled,</p></list-item><list-item><p>The code waits for interrupts and, after an UART ISR has been executed, gets the new DDM parameters for the four simultaneous beams.</p></list-item></list></p></sec><sec sec-type="methods"><label>2.3.</label><title>Data Output</title><p>As it has already been pointed out, the computed DDM needs to be swiftly sent out of the FPGA system to be processed. This data link is divided in three areas. The first one is a peripheral synthesized in the FPGA that acts as an external master for the USB controller (CY7C68013 chip). Then there is the USB controller IC itself, composed of a microcontroller and an I/O buffer. The third section is the program running at the terminal computer. The FPGA master controller sends the computed DDM values to the I/O buffer, using additional control signals. It acts as a data bridge between the DDM generator and the USB controller, since it sweeps the output address range of the DDM generator, reading and sending data points away. The data interface is shown in <xref ref-type="fig" rid="f9-sensors-08-03005">Fig. 9</xref>. It has been written in Visual C++. After the program starts, it verifies that the USB controller is indeed connected to the computer through an USB cable and then uploads the firmware to it, so that it becomes configured. Additional control buttons allow configuring the integration times and the data files to store. So far two interfaces have been implemented, each of them associated to one operational mode. In the first one four satellites are tracked simultaneously, and up to 16 &#x000d7; 16 point DDMs can be displayed in real-time. The second mode operates with just one satellite, but combines the hardware resources so that its size is four times larger: 32 &#x000d7; 32.</p></sec></sec><sec sec-type="results"><label>3.</label><title>Results</title><p>PAU-OR (one receiver) is a small-scale version of the complete PAU instrument [<xref ref-type="bibr" rid="b13-sensors-08-03005">13</xref>]. It has been developed to test the concept before assembling the whole instrument, and also to allow more flexibility when trying to gather field data, because of its compactness. The reflectometer core, common to both instruments, has been assembled in PAU-OR to debug the reflectometer by acquiring real GPS data.</p><p>The experimental test shown took place at the Garraf cliffs, 30 km South of Barcelona. It was a calm sea day (SWH = 51 cm). To determine the GPS satellites with a suitable geometry for tracking their reflections (<xref ref-type="fig" rid="f10-sensors-08-03005">Fig. 10</xref>), a 45&#x000b0; incidence angle mask had to be considered due to the cliff steepness. The results are shown in <xref ref-type="fig" rid="f9-sensors-08-03005">Figs. 9a and 9b</xref> in both operational modes. The coherent integration time was set to 1 ms, and the averaged number of views (incoherent) was of 100. Depending on the surface under observation (land or sea, for example), the maximum coherent integration time must be selected according to the surface's correlation time, so that the coherent averaging of uncorrelated waveforms is not performed.</p><p>It is known that the shape of the DDMs associated to the signals reflected over a certain surface depends on the geometry of observation and on the nature of the surface: its roughness, spatial orientation, and dielectric permittivity.</p></sec><sec sec-type="conclusions"><label>4.</label><title>Conclusions</title><p>An implementation of a real-time VHDL reflectometer has been presented. The design featured several in-house designed cores (DDM generator, delay offset estimator, buffer) to cope with the realtime nature of the system. There are three different data chains (reflected and direct signals and commercial GPS receiver data) that are combined together to obtain the system's observable: the delay-Doppler map (DDM). The shape of the DDMs can be linked to the Transmitter-Receiver geometry and to the scattering properties of the Earth's surface.</p><p>Future improvements of the system will include an improved interaction of the peripherals by means of direct links instead of the system bus. Regarding the measurements, field experiments will be performed during 2008 and 2009 to obtain collocated series of DDM's, brightness temperature data at L-band and sea state data (sea surface directional wave spectrum). It is expected that the full measurement of the DDMs will provide a more robust correlation with the brightness temperature change associated to the sea state, and thus will help improve the sea state correction required for accurate salinity retrieval.</p></sec></body><back><ack><p>This work, conducted as part of the award &#x0201c;Passive Advanced Unit (PAU): A Hybrid L-band Radiometer, GNSS-Reflectometer and IR-Radiometer for Passive Remote Sensing of the Ocean&#x0201d; made under the European Heads of Research Councils and European Science Foundation EURYI (European Young Investigator) Awards scheme in 2004, was supported by funds from the Participating Organizations of EURYI and the EC Sixth Framework Program. It has also been supported by the Department of Universities of the Catalan Autonomous Government and the European Social Fund. The authors would like to acknowledge the contribution of Mr. Jos&#x000e9; Yeste to the USB interface implementation.</p></ack><fn-group><fn id="fn1-sensors-08-03005"><label>1</label><p>Existing instruments are able to provide in real-time just &#x0201c;waveforms&#x0201d; or cuts of the DDM at constant <italic>f<sub>d</sub></italic></p></fn><fn id="fn2-sensors-08-03005"><label>2</label><p>For simplicity, the sign bit is retained after sampling at 8 bits, calibration and digital beamforming.</p></fn><fn id="fn3-sensors-08-03005"><label>3</label><p>According to [<xref ref-type="bibr" rid="b5-sensors-08-03005">5</xref>], the SNR decreases 1.96 dB and 0.55 dB alter 1-bit and 2-bit quantization, respectively.</p></fn></fn-group><ref-list><title>References and Notes</title><ref id="b1-sensors-08-03005"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Mart&#x000ed;n-Neira</surname><given-names>M.</given-names></name></person-group><article-title>A Passive Reflectometry and Interferometry System (PARIS): Application to Ocean Altimetry</article-title><source>ESA Journal</source><year>1993</year><volume>17</volume><fpage>331</fpage><lpage>355</lpage></element-citation></ref><ref id="b2-sensors-08-03005"><label>2.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rius</surname><given-names>A.</given-names></name><name><surname>Aparicio</surname><given-names>J.M.</given-names></name><name><surname>Cardellach</surname><given-names>E.</given-names></name><name><surname>Mart&#x000ed;n-Neira</surname><given-names>M.</given-names></name><name><surname>Chapron</surname><given-names>B.</given-names></name></person-group><article-title>Sea surface state measured using GPS reflected signals</article-title><source>Geophys. Res. Lett.</source><year>2002</year><volume>29</volume><issue>23</issue><fpage>2122</fpage></element-citation></ref><ref id="b3-sensors-08-03005"><label>3.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Soulat</surname><given-names>F.</given-names></name><name><surname>Caparrini</surname><given-names>M.</given-names></name><name><surname>Germain</surname><given-names>O.</given-names></name><name><surname>Lopez-Dekker</surname><given-names>P.</given-names></name><name><surname>Taani</surname><given-names>M.</given-names></name><name><surname>Ruffini</surname><given-names>G.</given-names></name></person-group><article-title>Sea state monitoring using coastal GNSS-R</article-title><source>Geophys. Res. Lett.</source><year>2004</year><volume>31</volume><fpage>L21303.1</fpage><lpage>L21303.4</lpage></element-citation></ref><ref id="b4-sensors-08-03005"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>You</surname><given-names>H.</given-names></name><name><surname>Garrison</surname><given-names>J.L.</given-names></name><name><surname>Heckler</surname><given-names>G.</given-names></name><name><surname>Zavorotny</surname><given-names>V.U.</given-names></name></person-group><article-title>Stochastic Voltage Model and Experimental Measurement of Ocean-Scattered GPS Signal Statistics</article-title><source>IEEE Trans. On Geoscience and Remote Sensing</source><year>2004</year><volume>42</volume><issue>10</issue><fpage>2160</fpage><lpage>2169</lpage></element-citation></ref><ref id="b5-sensors-08-03005"><label>5.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Tsui</surname><given-names>J.B.Y.</given-names></name></person-group><source>Fundamentals of Global Positioning System Receivers: A Software Approach</source><publisher-name>Wiley Interscience</publisher-name><publisher-loc>New York</publisher-loc><year>2000</year><fpage>32</fpage><lpage>52</lpage></element-citation></ref><ref id="b6-sensors-08-03005"><label>6.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Skolnik</surname><given-names>M.</given-names></name></person-group><source>Radar Handbook</source><publisher-name>McGraw-Hill</publisher-name><publisher-loc>New York</publisher-loc><year>1990</year><fpage>21.8-21</fpage><lpage>15</lpage></element-citation></ref><ref id="b7-sensors-08-03005"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Chapman</surname><given-names>R.D.</given-names></name><name><surname>Gotwols</surname><given-names>B.L.</given-names></name><name><surname>Sterner</surname><given-names>R.E.</given-names></name></person-group><article-title>On the statistics of the phase of microwave backscatter from the ocean surface</article-title><source>J. Geophys.Res.</source><year>1994</year><volume>99</volume><fpage>16293</fpage><lpage>16301</lpage></element-citation></ref><ref id="b8-sensors-08-03005"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Camps</surname><given-names>A.</given-names></name><name><surname>Bosch-Lluis</surname><given-names>X.</given-names></name><name><surname>Marchan-Hernandez</surname><given-names>J.F.</given-names></name><name><surname>Ramos-Perez</surname><given-names>I</given-names></name><name><surname>Izquierdo</surname><given-names>B.</given-names></name><name><surname>Rodr&#x000ed;guez</surname><given-names>N.</given-names></name></person-group><article-title>New Instruments for Ocean Remote Sensing: PAU Description and Analysis of PAU-Radiometer</article-title><source>IEEE Trans. On Geoscience and Remote Sensing</source><year>2007</year><volume>45</volume><issue>10</issue><fpage>3180</fpage><lpage>3192</lpage></element-citation></ref><ref id="b9-sensors-08-03005"><label>9.</label><element-citation publication-type="patent"><person-group person-group-type="author"><name><surname>Camps</surname><given-names>A.</given-names></name><name><surname>Marchan-Hernandez</surname><given-names>J.F.</given-names></name><name><surname>Bosch-Lluis</surname><given-names>X.</given-names></name><name><surname>Ramos-Perez</surname><given-names>I.</given-names></name></person-group><article-title>Sistema h&#x000ed;brido receptor de senales GNSS-Reflejadas / radiometro diferencial de pseudocorrelaci&#x000f3;n para observaci&#x000f3;n pasiva del oc&#x000e9;ano</article-title><patent>Spanish Patent 200602778</patent><month>10</month><day>25th</day><year>2006</year><comment>Spain</comment></element-citation></ref><ref id="b10-sensors-08-03005"><label>10.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Marchan-Hernandez</surname><given-names>J.F.</given-names></name><name><surname>Ramos-Perez</surname><given-names>I.</given-names></name><name><surname>Bosch-Lluis</surname><given-names>X.</given-names></name><name><surname>Camps</surname><given-names>A.</given-names></name><name><surname>Rodr&#x000ed;guez-&#x000c1;lvarez</surname><given-names>N.</given-names></name><name><surname>Albiol</surname><given-names>D.</given-names></name></person-group><article-title>PAU-GNSS/R, a Real-Time GPS-Reflectometer for Earth Observation Applications: Architecture Insights and Preliminary Results</article-title><conf-name>Proceedings of the IGARSS</conf-name><conf-date>2007, July 23-27</conf-date><conf-loc>Barcelona, Spain</conf-loc></element-citation></ref><ref id="b11-sensors-08-03005"><label>11.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Bosch-Lluis</surname><given-names>X.</given-names></name><name><surname>Camps</surname><given-names>A.</given-names></name><name><surname>Marchan-Hernandez</surname><given-names>J.F.</given-names></name><name><surname>Ramos-Perez</surname><given-names>I.</given-names></name><name><surname>Prehn</surname><given-names>R.</given-names></name><name><surname>Izquierdo</surname><given-names>B.</given-names></name><name><surname>Banqu&#x000e9;</surname><given-names>X.</given-names></name><name><surname>Yeste</surname><given-names>J.</given-names></name></person-group><article-title>FPGA-based Implementation of a Polarimetric Radiometer with Digital Beamforming</article-title><conf-name>Proceedings of the IGARSS</conf-name><conf-date>2006, July 31-August 4</conf-date><conf-loc>Denver, USA</conf-loc></element-citation></ref><ref id="b12-sensors-08-03005"><label>12.</label><element-citation publication-type="patent"><person-group person-group-type="author"><name><surname>Burshtein</surname><given-names>D.</given-names></name></person-group><article-title>Efficient Way to Produce a Delayed Version of a Maximum Length Sequence using a Division Circuit</article-title><patent>US Patent 6038577</patent><month>3</month><day>14th</day><year>2000</year><comment>USA</comment></element-citation></ref><ref id="b13-sensors-08-03005"><label>13.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Camps</surname><given-names>A.</given-names></name><name><surname>Aguasca</surname><given-names>A.</given-names></name><name><surname>Bosch-Lluis</surname><given-names>X.</given-names></name><name><surname>Marchan-Hernandez</surname><given-names>J.F.</given-names></name><name><surname>Ramos-Perez</surname><given-names>I.</given-names></name><name><surname>Rodr&#x000ed;guez-&#x000c1;lvarez</surname><given-names>N.</given-names></name><name><surname>Bou</surname><given-names>F.</given-names></name><name><surname>Ib&#x000e1;nez</surname><given-names>C.</given-names></name><name><surname>Banqu&#x000e9;</surname><given-names>X.</given-names></name><name><surname>Prehn</surname><given-names>R.</given-names></name></person-group><article-title>PAU One-Receiver Ground Based and Airborne Instruments</article-title><conf-name>Proceedings of the IGARSS</conf-name><conf-date>2007, July 23-27</conf-date><conf-loc>Barcelona, Spain</conf-loc></element-citation></ref></ref-list></back><floats-group><fig id="f1-sensors-08-03005" position="float"><label>Figure 1.</label><caption><p>Data paths in the implemented reflectometer.</p></caption><graphic xlink:href="sensors-08-03005f1"/></fig><fig id="f2-sensors-08-03005" position="float"><label>Figure 2.</label><caption><p>Delay Doppler Map (DDM) generator architecture. The &#x02018;Amps to 2C&#x02019; block performs the two's complement encoding, whereas the &#x02018;AC&#x02019; block accumulates the inputs.</p></caption><graphic xlink:href="sensors-08-03005f2"/></fig><fig id="f3-sensors-08-03005" position="float"><label>Figure 3.</label><caption><p>Detail of the main cores that compose the DDM generator: (a) &#x02018;Sign and amplitudes&#x02019; block in <xref ref-type="fig" rid="f2-sensors-08-03005">Fig. 2</xref> and (b) &#x02018;Oscillator block&#x02019; in <xref ref-type="fig" rid="f3-sensors-08-03005">Fig. 3a</xref>.</p></caption><graphic xlink:href="sensors-08-03005f3"/></fig><fig id="f4-sensors-08-03005" position="float"><label>Figure 4.</label><caption><p>Phase MSBs role on the wave generation.</p></caption><graphic xlink:href="sensors-08-03005f4"/></fig><fig id="f5-sensors-08-03005" position="float"><label>Figure 5.</label><caption><p>Sketch of the <italic>C/A generator</italic> block. The <italic>Resampler</italic> component drives the Linear Feedback Shift Registers (LFSR) inside the block <italic>G1 and G2,</italic> out of where the C/A code is obtained. The values of M1, M2 and nint_value determine the code offset and the satellite ID.</p></caption><graphic xlink:href="sensors-08-03005f5"/></fig><fig id="f6-sensors-08-03005" position="float"><label>Figure 6.</label><caption><p>Architecture of the delay offset block.</p></caption><graphic xlink:href="sensors-08-03005f6"/></fig><fig id="f7-sensors-08-03005" position="float"><label>Figure 7.</label><caption><p>Correlation of the 5745-sample C/A code using standard FFT blocks with 2<sup>13</sup> = 8192 input samples. (a) Two correlation maxima instead of a single one. (b) Relation of the actual code offset and the retrieved one.</p></caption><graphic xlink:href="sensors-08-03005f7"/></fig><fig id="f8-sensors-08-03005" position="float"><label>Figure 8.</label><caption><p>Interrupts and their associated Interrupt Service Routine (ISR) dataflow: (a) Buffer ISR and (b) UART ISR</p></caption><graphic xlink:href="sensors-08-03005f8"/></fig><fig id="f9-sensors-08-03005" position="float"><label>Figure 9.</label><caption><p>Implemented interface for receiving, displaying and storing the DDMs. On the left the 4-satellite operational mode is seen, whereas on the right the 1-satellite operational mode is shown. These videos correspond to actual measurements on the Garraf Cliffs (click to play them).</p></caption><graphic xlink:href="sensors-08-03005f9"/></fig><fig id="f10-sensors-08-03005" position="float"><label>Figure 10.</label><caption><p>Experimental measurements at Garraf Cliffs. On the left PAU-OR points towards the sea surface from above the cliff. On the right, the position of the available satellites can be seen in a polar diagram. Results are shown in <xref ref-type="fig" rid="f9-sensors-08-03005">Fig. 9</xref> for both modes of operation.</p></caption><graphic xlink:href="sensors-08-03005f10"/></fig></floats-group></article>

<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>Molecular Diversity Preservation International (MDPI)</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">22164021</article-id><article-id pub-id-type="pmc">3231738</article-id><article-id pub-id-type="doi">10.3390/s110807341</article-id><article-id pub-id-type="publisher-id">sensors-11-07341</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>A Novel Systematic Error Compensation Algorithm Based on Least Squares Support Vector Regression for Star Sensor Image Centroid Estimation</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Yang</surname><given-names>Jun</given-names></name></contrib><contrib contrib-type="author"><name><surname>Liang</surname><given-names>Bin</given-names></name></contrib><contrib contrib-type="author"><name><surname>Zhang</surname><given-names>Tao</given-names></name><xref ref-type="corresp" rid="c1-sensors-11-07341"><sup>*</sup></xref></contrib><contrib contrib-type="author"><name><surname>Song</surname><given-names>Jingyan</given-names></name></contrib><aff id="af1-sensors-11-07341">Department of Automation, Tsinghua University, Beijing 100084, China; E-Mails: <email>jun-yang07@mails.tsinghua.edu.cn</email> (J.Y.); <email>bliang@tsinghua.edu.cn</email> (B.L.); <email>jysong@tsinghua.edu.cn</email> (J.S.)</aff></contrib-group><author-notes><corresp id="c1-sensors-11-07341"><label>*</label>Author to whom correspondence should be addressed; E-Mail: <email>taozhang@tsinghua.edu.cn</email>; Tel.: +86-10-6279-7846; Fax: +86-10-6279-7629.</corresp></author-notes><pub-date pub-type="collection"><year>2011</year></pub-date><pub-date pub-type="epub"><day>25</day><month>7</month><year>2011</year></pub-date><volume>11</volume><issue>8</issue><fpage>7341</fpage><lpage>7363</lpage><history><date date-type="received"><day>7</day><month>7</month><year>2011</year></date><date date-type="rev-recd"><day>18</day><month>7</month><year>2011</year></date><date date-type="accepted"><day>22</day><month>7</month><year>2011</year></date></history><permissions><copyright-statement>&#x000a9; 2011 by the authors; licensee MDPI, Basel, Switzerland.</copyright-statement><copyright-year>2011</copyright-year><license><license-p><!--CREATIVE COMMONS-->This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/3.0/">http://creativecommons.org/licenses/by/3.0/</ext-link>).</license-p></license></permissions><abstract><p>The star centroid estimation is the most important operation, which directly affects the precision of attitude determination for star sensors. This paper presents a theoretical study of the systematic error introduced by the star centroid estimation algorithm. The systematic error is analyzed through a frequency domain approach and numerical simulations. It is shown that the systematic error consists of the approximation error and truncation error which resulted from the discretization approximation and sampling window limitations, respectively. A criterion for choosing the size of the sampling window to reduce the truncation error is given in this paper. The systematic error can be evaluated as a function of the actual star centroid positions under different Gaussian widths of star intensity distribution. In order to eliminate the systematic error, a novel compensation algorithm based on the least squares support vector regression (LSSVR) with Radial Basis Function (RBF) kernel is proposed. Simulation results show that when the compensation algorithm is applied to the 5-pixel star sampling window, the accuracy of star centroid estimation is improved from 0.06 to 6 &#x000d7; 10<sup>&#x02212;5</sup> pixels.</p></abstract><kwd-group><kwd>star sensor</kwd><kwd>subpixel</kwd><kwd>centroid estimation</kwd><kwd>systematic error compensation</kwd><kwd>LSSVR</kwd></kwd-group></article-meta></front><body><sec><label>1.</label><title>Introduction</title><p>The star tracker is a satellite-based embedded system which estimates the orientation of the satellite in space. This information is essential for any space mission, as it supplies all attitude data required for satellite control. There are other sensors used for the same purpose (gyroscope, sun tracker, magnetometer, GPS), but star trackers are more accurate and allow for attitude estimation without prior information [<xref ref-type="bibr" rid="b1-sensors-11-07341">1</xref>]. For these reasons star trackers are used onboard 3-axis stabilized spacecraft. Star trackers estimate the orientation directly from the images of stars taken by an onboard camera. The estimation is based on a comparison of the star locations in the image with those in the predefined catalogue. One important factor influenced the performance of the star tracker is the star centroid location estimation in the image. This process becomes difficult when noise exists. This work applies the Least Square Support Vector Regression (LSSVR) with Radial Basis Function (RBF) kernel to improve the estimation process.</p><p>The noise influence on the estimation process can be divided into two types, the random noise and the systematical noise. The random noise includes the short noise, dark current noise, CCD readout noise, and radiation noise, which are closely related with the hardware of the CCD sensor [<xref ref-type="bibr" rid="b2-sensors-11-07341">2</xref>]. In order to obtain high accuracy star locations in the image, sub-pixel centroid algorithms should be adopted, namely, the center of mass (COM), polynomial and B-spline interpolators [<xref ref-type="bibr" rid="b3-sensors-11-07341">3</xref>]. The systematic noise is due to the nature of the centroid algorithm. The systematic noise of the centroid algorithm can cause several arc-seconds accuracy loss, so it is essential to analyze the systematic error and design a compensation method to improve the accuracy of star centroid location estimation in the image. In this paper, the systematic error is discussed in detail and the random noise will be only briefly analyzed.</p><p>The properties of the systematic error have been investigated by many scholars. In general, systematic error of centroid estimation is related with the energy distribution of starlight on star image (Gaussian width), the frequency of sampling, the size of sampling window and the actual position of star point. Grossman <italic>et al.</italic> [<xref ref-type="bibr" rid="b4-sensors-11-07341">4</xref>] pointed out that the systematic error was reduced by increasing degrees of blur and by the wider defocusing of the neighbor pixels of the starlight. However, Hegedus <italic>et al.</italic> [<xref ref-type="bibr" rid="b5-sensors-11-07341">5</xref>] pointed out that the error firstly decreases and then increases as star Gaussian width is increased. Stanton <italic>et al.</italic> [<xref ref-type="bibr" rid="b6-sensors-11-07341">6</xref>] obtained a roughly sinusoid functional relationship between systematic error and the actual position of star point under fixed blur size. Alexander <italic>et al.</italic> [<xref ref-type="bibr" rid="b7-sensors-11-07341">7</xref>] analyzed the systematic error through a spatial-frequency-based approach caused by the center of mass algorithm. Jean [<xref ref-type="bibr" rid="b8-sensors-11-07341">8</xref>] supplemented Alexander&#x02019;s work and proposed a Fourier phase shift method to calculate the sub-pixel position under more complex signals. Rufino <italic>et al.</italic> [<xref ref-type="bibr" rid="b9-sensors-11-07341">9</xref>] obtained the starlight intensity distribution point spread function (PSF) considering diffraction and CCD defocus, and used the BP neural network method to compensate the systematic error. JIA <italic>et al.</italic> [<xref ref-type="bibr" rid="b10-sensors-11-07341">10</xref>] studied the systematic error utilizing a frequency domain method considering sampling frequency limitation and sampling window limitation. He also proposed an analytical compensation algorithm to reduce the systematic error of star centroid estimation.</p><p>This paper analyzes the systematic error caused by the center of mass (COM) centroid estimation algorithm. Through the frequency domain approach analysis and numerical simulations, it is found that the systematic error consists of an approximation error and a truncation error. The approximation error results from the discretization approximation, which is caused when the spacial frequency of a star image is higher than the sampling frequency of the detector. The truncation error will appear when the size of the sampling window is smaller than the Gaussian width of the star intensity distribution. A criterion for choosing the size of the sampling window is given to reduce the truncation error as much as possible. Through numerical simulations, the systematic error can be evaluated as a function of the actual star centroid positions under different Gaussian widths of the star intensity distribution. In order to eliminate the systematic error, a novel systematic error compensation algorithm based on the least squares support vector regression (LSSVR) with Radial Basis Function (RBF) kernel is proposed. This novel algorithm can control the function estimation kernel shape and prediction accuracy. The experimental results demonstrate that the proposed approach can improve the accuracy of the star centroid position estimation dramatically.</p><p>The rest of this paper is organized as follows. In Section 2, the error of star centroid estimation algorithm is analyzed from three aspects through a frequency domain approach and numerical simulations: the integral error, the approximation error and the truncation error. A detailed description of our novel compensation algorithm based on the LSSVR is given in Section 3. In Section 4, the performance of the LSSVR compensation algorithm is evaluated. Finally, the conclusions of the paper are drawn in Section 5.</p></sec><sec><label>2.</label><title>Error Analysis of Star Centroid Estimation Algorithm</title><p>It is well known that the star centroid calculation is used to pinpoint location. In order to adopt digital centroid algorithms to achieve sub-pixel accuracy in star centroid position estimation, the star sensor camera should be defocused slightly in order to spread the star energy over several neighboring pixels [<xref ref-type="bibr" rid="b11-sensors-11-07341">11</xref>]. The center of mass (COM) algorithm is the most widely method used to calculate the centroid position of star images, and the error analysis is based on the COM algorithm [<xref ref-type="bibr" rid="b1-sensors-11-07341">1</xref>,<xref ref-type="bibr" rid="b2-sensors-11-07341">2</xref>,<xref ref-type="bibr" rid="b4-sensors-11-07341">4</xref>,<xref ref-type="bibr" rid="b10-sensors-11-07341">10</xref>].</p><sec><label>2.1.</label><title>The Integral Error of Center of Mass (COM) Algorithm</title><p>It is evident that the sub-pixel accuracy star centriod cannot be obtained by one single pixel directly. The COM algorithm uses several neighbor pixels around the brightest pixel to calculate the sub-pixel star centroid position. The ideal star centroid position in the image plane is <italic>&#x00078;&#x00302;<sub>c</sub></italic> and <italic>&#x00177;<sub>c</sub></italic>, which can be computed by:
<disp-formula id="FD1"><label>(1)</label><mml:math id="M1"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>c</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi>W</mml:mi></mml:msub><mml:mrow><mml:mi>x</mml:mi><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dxdy</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi>W</mml:mi></mml:msub><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dxdy</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi>W</mml:mi></mml:msub><mml:mrow><mml:mi>y</mml:mi><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dxdy</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mrow><mml:msub><mml:mo>&#x0222b;</mml:mo><mml:mi>W</mml:mi></mml:msub><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dxdy</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <italic>W</italic> is the sampling window area that include all validated neighbor pixels around the starlight in the image plane, <italic>x</italic> and <italic>y</italic> are the coordinates of the pixels in <italic>W</italic>, <italic>I</italic>(<italic>x, y</italic>) is the detected signal irradiance intensity at pixel (<italic>x, y</italic>). <xref ref-type="disp-formula" rid="FD1">Equation (1)</xref> is the COM algorithm&#x02019;s theory model, it should be discretized when it used in digital computation. After the discretization, <xref ref-type="disp-formula" rid="FD1">Equation (1)</xref> can be written as:
<disp-formula id="FD2"><label>(2)</label><mml:math id="M2"><mml:mrow><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac><mml:mo>,</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where <italic>&#x00078;&#x00302;<sub>g</sub></italic> and <italic>&#x00177;<sub>g</sub></italic> are the actual star centroid position in the image plane after discretization. <italic>W</italic> in <xref ref-type="disp-formula" rid="FD1">Equation (1)</xref> replaces the discrete <italic>n</italic> pixels to constitute the sampling window, <italic>x<sub>i</sub></italic> and <italic>y<sub>i</sub></italic> are the coordinates of the geometric center of the <italic>i-th</italic> pixel, <italic>I<sub>i</sub></italic> and is the irradiance intensity integration of the <italic>i-th</italic> pixel.</p><p>From <xref ref-type="disp-formula" rid="FD2">Equation (2)</xref>, it can be found that there are three factors can influence the star centroid estimation accuracy: the size of sampling window <italic>W</italic>, the <italic>i-th</italic> pixel coordinates <italic>x<sub>i</sub></italic> in <italic>W</italic> and the signal intensity <italic>I<sub>i</sub></italic> in corresponding pixels. The systematic error is caused by the discrete approximation of the coordinate <italic>x<sub>i</sub></italic> and truncating the sampling window <italic>W</italic>, and the uncertainty in detecting <italic>I<sub>i</sub></italic> leads to random noise. The 1-D situation in the x direction will be discussed, and the analysis is also valid for both the x and y direction in 2-D situation. Assuming the systematic error and the random noise are small and not correlated, then the integral error of the COM can be described by the expression [<xref ref-type="bibr" rid="b9-sensors-11-07341">9</xref>]:
<disp-formula id="FD3"><label>(3)</label><mml:math id="M3"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:munderover><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:msubsup></mml:mrow><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mi>x</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>g</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msubsup><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>where <italic>&#x003c3;<sub>&#x00078;&#x00302;<sub>g</sub></sub></italic> is the integration error of <italic>&#x00078;&#x00302;<sub>g</sub></italic>, <italic>&#x003c3;<sub>x</sub></italic> is the systematic error resulting from the use of the pixel geometrical center to substitute the irradiance integration over a whole pixel and truncating the sampling window. <italic>&#x003c3;<sub>I</sub></italic> is the random error caused by various noises, namely, the short noise, dark current noise, CCD readout noise, and radiation noise <italic>etc.</italic></p><p>Firstly, we consider random error which is caused by the uncertainty in detecting <italic>I<sub>i</sub></italic>. We assume that the measured signal intensity <italic>I<sub>i</sub></italic> at the pixel <italic>x<sub>i</sub></italic> consists of two components: a &#x02018;true&#x02019; intensity <italic>E<sub>i</sub></italic>, and the noise intensity &#x003c3;<italic><sub>I</sub></italic>, then the <italic>I<sub>i</sub></italic> <italic>= E<sub>i</sub></italic> + <italic>&#x003c3;<sub>I</sub></italic>. The derivatives in <xref ref-type="disp-formula" rid="FD3">Equation (3)</xref> can be computed from <xref ref-type="disp-formula" rid="FD2">Equation (2)</xref>, and can be written as:
<disp-formula id="FD4"><label>(4)</label><mml:math id="M4"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>I</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mi>I</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mn>0</mml:mn><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mi>I</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula>where the total signal 
<inline-formula><mml:math id="M5"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, the &#x02018;true&#x02019; signal 
<inline-formula><mml:math id="M6"><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>, and the &#x02018;true&#x02019; star centroid position 
<inline-formula><mml:math id="M7"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>E</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>/</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mrow></mml:math></inline-formula>.</p><p>If the <italic>&#x003c3;<sub>I</sub></italic> is small, the <italic>I</italic><sub>0</sub> &#x02248; <italic>E</italic><sub>0</sub>, then through the <xref ref-type="disp-formula" rid="FD4">Equation (4)</xref>, we can find that the random error is inversely proportional to the signal to noise ratio (SNR). Enhancing the SNR can then reduce the random noise effectively. In this study, the random error analysis is not the key content. Many random noise elimination algorithms are described elsewhere [<xref ref-type="bibr" rid="b4-sensors-11-07341">4</xref>,<xref ref-type="bibr" rid="b12-sensors-11-07341">12</xref>] and are not covered in this paper.</p><p>In this paper, the analysis of systematic error is our main topic. From <xref ref-type="disp-formula" rid="FD3">Equation (3)</xref>, one also can use a derivative of the parameter <italic>x<sub>i</sub></italic> to determine the systematic error, and this can be expressed as:
<disp-formula id="FD5"><label>(5)</label><mml:math id="M8"><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msubsup><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mi>x</mml:mi></mml:msub><mml:msup><mml:mrow/><mml:mn>2</mml:mn></mml:msup><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfrac><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:mfrac></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>As we can see, the systematic error <italic>&#x003c3;<sub>&#x00058;&#x00303;<sub>g</sub>, x</sub></italic> cannot be calculated directly through <xref ref-type="disp-formula" rid="FD5">Equation (5)</xref>, because there is little information about the <italic>&#x003c3;<sub>x</sub></italic> in time domain. In order to get more information to express the systematic error explicitly, we will analyze the systematic error using the frequency domain based method and numerical simulations.</p></sec><sec sec-type="methods"><label>2.2.</label><title>Theoretical Analysis of the Systematic Approximation Error under Sampling Frequency Limitation</title><p>In this section, frequency domain analysis is adopted to get more information about the relationship between the systematic error and the ideal star centroid position just consideration of sampling frequency limitation. Under the condition of the spacial frequency of star image being higher than the sampling frequency of the detector, one type of systematic error named approximation error in calculating the star centroid position will be caused. We derive an approximate sinusoidal relationship between the approximation systematic error and the ideal star centroid position. The theoretical relationship function can inspire us to design some novel algorithms to compensate the systematic error.</p><p>The star image sampling process is illustrated in <xref ref-type="fig" rid="f1-sensors-11-07341">Figure 1</xref>, and can be divided into two steps. The waveform e(x) is the intensity profile of the starlight stripe projected on the surface of the CCD. The signal intensity function e(x) is convoluted with the pixel sensitivity function p(x) to generate the continuing pixel signal function f(x). After multiplying the pixel sampling function t(x), we can get the discrete signal function g(x), which can be written as:
<disp-formula id="FD6"><label>(6)</label><mml:math id="M9"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02297;</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x021d2;</mml:mo><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02297;</mml:mo><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>When the CCD&#x02019;s fill factor is approximated to 100%, the pixel sensitivity function p(x) is equal to a rectangle function. t(x) is the sampling function, its sampling frequency is <italic>f<sub>s</sub></italic> = 1/<italic>T</italic> and is a comb function, T is the length of pixel. The p(x) and t(x) are given as follows:
<disp-formula id="FD7"><label>(7)</label><mml:math id="M10"><mml:mrow><mml:mi>p</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">rect</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>,</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mi>t</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mi mathvariant="italic">comb</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mrow><mml:mi>k</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow></mml:munderover><mml:mrow><mml:mi>&#x003b4;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi mathvariant="italic">kT</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The Fourier transform of the continuous function f(x) can be written as:
<disp-formula id="FD8"><label>(8)</label><mml:math id="M11"><mml:mrow><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">isx</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>and the derivative of the <italic>F</italic>(<italic>s</italic>) can be expressed <italic>F</italic>&#x02032;(<italic>s</italic>) by as:
<disp-formula id="FD9"><label>(9)</label><mml:math id="M12"><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi mathvariant="italic">xf</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">isx</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dx</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>Then the ideal centroid position <italic>&#x00078;&#x00302;<sub>c</sub></italic> of f(x) can be calculated through <xref ref-type="disp-formula" rid="FD8">Equations (8)</xref> and <xref ref-type="disp-formula" rid="FD9">(9)</xref>, as stated by Alexander [<xref ref-type="bibr" rid="b7-sensors-11-07341">7</xref>]:
<disp-formula id="FD10"><label>(10)</label><mml:math id="M13"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>c</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi mathvariant="italic">xf</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dx</mml:mi></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dx</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>F</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iF</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>Likewise, the centroid of the sampled function <italic>&#x00078;&#x00302;<sub>g</sub></italic> can be written as:
<disp-formula id="FD11"><label>(11)</label><mml:math id="M14"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi mathvariant="italic">xg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dx</mml:mi></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi mathvariant="italic">dx</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>As described above, <italic>&#x00078;&#x00302;<sub>c</sub></italic> is the ideal star centroid position and <italic>&#x00078;&#x00302;<sub>g</sub></italic> is the actual star centroid position with approximation systematic error. The following step, we will begin to analyze the <italic>&#x00078;&#x00302;<sub>g</sub></italic> influenced by the approximation systematic error and get its theoretical model through frequency domain analysis.</p><p>Starlight can be viewed as point light sources, so the starlight signal intensity distribution spread point function is approximated reasonably by the Gaussian function and the 2-D situation function can be written as [<xref ref-type="bibr" rid="b2-sensors-11-07341">2</xref>,<xref ref-type="bibr" rid="b10-sensors-11-07341">10</xref>,<xref ref-type="bibr" rid="b13-sensors-11-07341">13</xref>]
<disp-formula id="FD12"><label>(12)</label><mml:math id="M15"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mi>y</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">PSF</mml:mi></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>y</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:msup><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">PSF</mml:mi></mml:msub></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mfrac><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula></p><p>For just considering the x direction, the 1-D case can be reduced to:
<disp-formula id="FD13"><label>(13)</label><mml:math id="M16"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow><mml:mrow><mml:msqrt><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mrow></mml:msqrt><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">PSF</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">PSF</mml:mi></mml:msub><mml:msup><mml:mrow/><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mfrac><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></disp-formula>where <italic>x</italic><sub>0</sub> represents the ideal star centroid position equal to <italic>&#x00078;&#x00302;<sub>c</sub></italic>, and the <italic>&#x003c3;<sub>PSF</sub></italic> is the Gaussian width parameter. Through the <xref ref-type="disp-formula" rid="FD13">Equation (13)</xref>, <italic>f</italic>(<italic>x</italic>) can be expressed by the <italic>f<sub>e</sub></italic>(<italic>x</italic>) shifted by offset d from the origin, <italic>i.e.</italic>:
<disp-formula id="FD14"><label>(14)</label><mml:math id="M17"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>f</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>d</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>From the <xref ref-type="disp-formula" rid="FD13">Equation (13)</xref>, it can find that the d equals to <italic>x</italic><sub>0</sub>. The Fourier transform of <italic>f</italic>(<italic>x</italic>) is written as:
<disp-formula id="FD15"><label>(15)</label><mml:math id="M18"><mml:mrow><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">ids</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula>where the <italic>F<sub>e</sub></italic>(<italic>s</italic>) is the Fourier transform of <italic>f<sub>e</sub></italic>(<italic>s</italic>).</p><p>From the <xref ref-type="disp-formula" rid="FD11">Equation (11)</xref>, the approximation systematic error <italic>&#x003c3;<sub>&#x00058;&#x00303;<sub>g</sub>, x</sub></italic> can be written by:
<disp-formula id="FD16"><label>(16)</label><mml:math id="M19"><mml:mrow><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:math></disp-formula></p><p>From <xref ref-type="disp-formula" rid="FD6">Equation (6)</xref>, the G(s) can be written by <italic>G</italic> (<italic>x</italic> ) = <italic>F</italic>(<italic>s</italic>) &#x000d7; <italic>T</italic>(<italic>s</italic>), according to the form of <italic>t</italic>(<italic>x</italic>) in <xref ref-type="disp-formula" rid="FD7">Equation (7)</xref> and sampling frequency <italic>f<sub>s</sub></italic> = 1/<italic>T</italic>, the G(s) can be given as:
<disp-formula id="FD17"><label>(17)</label><mml:math id="M20"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>n</mml:mi><mml:mo>/</mml:mo><mml:mi>T</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo></mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mi>F</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Then the derivative of <italic>G</italic> (<italic>s</italic>) is written by:
<disp-formula id="FD18"><label>(18)</label><mml:math id="M21"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mo>{</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo>*</mml:mo><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Then substituting <xref ref-type="disp-formula" rid="FD17">Equations (17)</xref> and <xref ref-type="disp-formula" rid="FD18">(18)</xref> into <xref ref-type="disp-formula" rid="FD16">(16)</xref> yields:
<disp-formula id="FD19"><label>(19)</label><mml:math id="M22"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msup><mml:mi>G</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">idG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:msub><mml:mrow><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mi>d</mml:mi></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">iG</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Substituting s = 0 into <xref ref-type="disp-formula" rid="FD19">Equation (19)</xref>, and noting that <italic>F<sub>e</sub></italic>(<italic>x</italic>) is even, and the <italic>F</italic>&#x02032;<italic><sub>e</sub></italic>(<italic>x</italic>) is odd. Then the numerator of the <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> in <xref ref-type="disp-formula" rid="FD19">Equation (19)</xref> can be calculated as:
<disp-formula id="FD20"><label>(20)</label><mml:math id="M23"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>From <xref ref-type="disp-formula" rid="FD17">Equation (17)</xref>, the denominator of <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> can be obtained as:
<disp-formula id="FD21"><label>(21)</label><mml:math id="M24"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mi>G</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mrow><mml:mo>|</mml:mo></mml:mrow><mml:mrow><mml:mi>s</mml:mi><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi mathvariant="italic">id</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mn>2</mml:mn><mml:mtext>cos</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Taking the <xref ref-type="disp-formula" rid="FD20">Equations (20)</xref> and <xref ref-type="disp-formula" rid="FD21">(21)</xref> into the <xref ref-type="disp-formula" rid="FD19">Equation (19)</xref> to get the approximation systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> as:
<disp-formula id="FD22"><label>(22)</label><mml:math id="M25"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mn>2</mml:mn><mml:mi>i</mml:mi><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>i</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mn>2</mml:mn><mml:mtext>cos</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mn>2</mml:mn><mml:mtext>cos</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>d</mml:mi><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi mathvariant="italic">nf</mml:mi><mml:mi>s</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula><italic>f<sub>s</sub></italic> = 1/<italic>T</italic> is the sampling frequency and we measure all distances in units of the pixel length (<italic>T</italic> = 1), and in <xref ref-type="disp-formula" rid="FD14">Equation (14)</xref> the d equals to <italic>x</italic><sub>0</sub>, so the <xref ref-type="disp-formula" rid="FD22">Equation (22)</xref> can be rewritten by:
<disp-formula id="FD23"><label>(23)</label><mml:math id="M26"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:mn>2</mml:mn><mml:mtext>cos</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>From <xref ref-type="disp-formula" rid="FD6">Equation (6)</xref>, it follows that:
<disp-formula id="FD24"><label>(24)</label><mml:math id="M27"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:mi>&#x02131;</mml:mi><mml:mo>{</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo><mml:mo>=</mml:mo><mml:mi>&#x02131;</mml:mi><mml:mo>{</mml:mo><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02297;</mml:mo><mml:mi mathvariant="italic">rect</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>}</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">PSF</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>
<disp-formula id="FD25"><label>(25)</label><mml:math id="M28"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>s</mml:mi><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">PSF</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mtext>cos</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>s</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>s</mml:mi></mml:mrow></mml:math></disp-formula>where &#x02131;{} denotes the Fourier transform operation. Therefore:
<disp-formula id="FD26"><label>(26)</label><mml:math id="M29"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mn>0</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>F</mml:mi><mml:mi>e</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02009;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo>&#x02265;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msubsup><mml:mi>F</mml:mi><mml:mi>e</mml:mi><mml:mo>&#x02032;</mml:mo></mml:msubsup><mml:mo stretchy="false">(</mml:mo><mml:mi>n</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:msub><mml:mi>I</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">PSF</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>Substituting <xref ref-type="disp-formula" rid="FD26">Equation (26)</xref> into <xref ref-type="disp-formula" rid="FD23">Equation (23)</xref> yields:
<disp-formula id="FD27"><label>(27)</label><mml:math id="M30"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>n</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mi>n</mml:mi></mml:msup><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">PSF</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>/</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:mrow></mml:math></disp-formula><xref ref-type="disp-formula" rid="FD27">Equation (27)</xref> is the theory expression of the approximation systematic error of star image centroid estimation with Gaussian distribution shape. Under the fixed sampling frequency (<italic>f<sub>s</sub></italic> = 1), it can be seen that the approximation error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> is related with Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> and the ideal star centroid position <italic>x</italic><sub>0</sub> and it decreases as the Gaussian width increases. Under the condition of <italic>&#x003c3;<sub>PSF</sub></italic> &#x0003e; 0.3, <xref ref-type="disp-formula" rid="FD27">Equation (27)</xref> can be written by:
<disp-formula id="FD28"><label>(28)</label><mml:math id="M31"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>&#x003c0;</mml:mi></mml:mfrac><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:mi mathvariant="italic">PSF</mml:mi></mml:mrow></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">]</mml:mo><mml:mtext>sin</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:mi>&#x003c0;</mml:mi><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>From the <xref ref-type="disp-formula" rid="FD28">Equation (28)</xref>, it is seen that there is an approximately sinusoidal relationship between <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> and <italic>x</italic><sub>0</sub>. The amplitude of <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub><italic>, x</italic></sub> decreases as the Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> increases. In the following part, we also use numerical simulations to verify the theoretical expression of the approximate systematic error in <xref ref-type="disp-formula" rid="FD28">Equation (28)</xref>.</p><p>Designing the numerical simulations, the ideal star centroid position <italic>x</italic><sub>0</sub> is varied from 0 to 1 with the interval of 0.002, and set the Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> from 0.1 to 1.2 with the interval of 0.1. Because the starlight signal intensity point spread function (PSF) is reasonable approximated by the 2-D Gaussian function in <xref ref-type="disp-formula" rid="FD12">Equation (12)</xref> and is symmetrical in the x and y direction. Just the 1-D situation in the x direction is considered. Therefore the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> can be calculated by the following equation:
<disp-formula id="FD29"><label>(29)</label><mml:math id="M32"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi mathvariant="italic">xg</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:mrow><mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mo>&#x0221e;</mml:mo></mml:mrow><mml:mo>&#x0221e;</mml:mo></mml:msubsup><mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow><mml:mrow><mml:msubsup><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>n</mml:mi></mml:msubsup><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>Then, the approximation systematic error can be expressed by:
<disp-formula id="FD30"><label>(30)</label><mml:math id="M33"><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></disp-formula></p><p>There is one premise should be stated. The fill factor of the active pixel sensors is assumed to be 100% and each pixel has the same photon response. Then, the detected signal intensity of the <italic>i-th</italic> pixel is:
<disp-formula id="FD31"><label>(31)</label><mml:math id="M34"><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:msubsup><mml:mo>&#x0222b;</mml:mo><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mrow><mml:mi>I</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mi>d</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula>where <italic>I</italic>(<italic>x</italic>, <italic>x</italic><sub>0</sub>) equals to <italic>f</italic>(<italic>x</italic>) in <xref ref-type="disp-formula" rid="FD13">Equation (13)</xref>.</p><p>The sampling window size is fixed at 5 &#x000d7; 5 pixels. Under different Gaussian widths, a group of curves between the approximation systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and the ideal star centroid position <italic>x</italic><sub>0</sub> can be obtained. The 3-D numerical simulation results of the relationships between <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and <italic>x</italic><sub>0</sub> is shown in <xref ref-type="fig" rid="f2-sensors-11-07341">Figure 2</xref>.</p><p>Through the <xref ref-type="fig" rid="f2-sensors-11-07341">Figure 2</xref>, it can be seen that the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and the <italic>x</italic><sub>0</sub> has an approximately sinusoidal relationship when the Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> is small (<italic>&#x003c3;<sub>PSF</sub></italic> &#x0003c; 0.5), and the result is consistent with the theoretical analysis in <xref ref-type="disp-formula" rid="FD28">Equation (28)</xref>, but, when the <italic>&#x003c3;<sub>PSF</sub></italic> is large, there is a linear relationship between <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and <italic>x</italic><sub>0</sub>. This is an interesting result, and we will introduce another type of systematic error named truncation systematic error here to describe this phenomenon. The approximation systematic error is caused by the sampling frequency limitation and the truncation systematic error is caused by the sampling window limitation. The truncation error will appear when the size of sampling window is smaller than Gaussian width and will be discussed in detail in the next section.</p></sec><sec sec-type="methods"><label>2.3.</label><title>Theoretical Analysis of the Systematic Truncation Error under Sampling Window Limitation</title><p>In this section, we will analyze the truncation error and give the criterion for choosing the sampling window size to reduce the systematic error as much as possible. The simulations above show that the truncation error will appear when the sampling window size is relatively small. The sampling window area decides how many validated neighbor pixels around the star signal in the image plane were involved in calculating the star centroid position. In <xref ref-type="fig" rid="f3-sensors-11-07341">Figure 3</xref>, we will demonstrate how the sampling window size introduces error into the star centroid position estimation.</p><p><xref ref-type="fig" rid="f3-sensors-11-07341">Figure 3(a)</xref>, shows that the Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> is larger than the sampling window size. We can see that the <italic>g</italic>(<italic>k</italic>) is a part of the <italic>g</italic>(<italic>x</italic>) and <italic>g</italic>(<italic>x</italic>) has truncated some effective pixels from the original star signal. Then, the <italic>g</italic>(<italic>k</italic>) has fewer pixels to be used in calculating the star centroid position and will introduce a truncation systematic error to the final star centroid position estimation. In <xref ref-type="fig" rid="f3-sensors-11-07341">Figure 3(b)</xref>, the sampling window size is larger than the Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic>. In this case, the <italic>g</italic>(<italic>k</italic>) contained all the information of the star signal <italic>g</italic>(<italic>x</italic>) and the size of the sampling window will not cause the truncation systematic error. Under this condition, the error is just dominated by the systematic approximation error.</p><p>Here, we also use the numerical simulations (designed in Section 2.2) to analyze the truncation systematic error. We select some Gaussian width from 0.1 to 1.2 to implement the simulations again and give the 2-D experiment results under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3, 0.4, 0.5, 0.7, 0.9, 1.1 in <xref ref-type="fig" rid="f4-sensors-11-07341">Figure 4</xref>, and also give out the number of pixels occupied by the Gaussian curve under different Gaussian widths in <xref ref-type="fig" rid="f5-sensors-11-07341">Figure 5</xref>.</p><p>From <xref ref-type="fig" rid="f4-sensors-11-07341">Figure 4</xref>, it can be seen that the relationship between <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and <italic>x</italic><sub>0</sub> changed from approximately sinusoidal to linear with the Gaussian width increases. Combining <xref ref-type="fig" rid="f4-sensors-11-07341">Figures 4</xref> and <xref ref-type="fig" rid="f5-sensors-11-07341">5</xref>, we can explain the reason of the truncation error clearly. When the Gaussian width is smaller than 0.5, we can find that the number of pixels occupied by the Gaussian curve in <xref ref-type="fig" rid="f5-sensors-11-07341">Figure 5</xref> is smaller than the 5-pixel window size (the sampling window size selected in our numerical simulations). In this case, the systematic error is just caused by the sampling frequency limitation and is dominated by the approximation error. When the Gaussian width is larger than 0.5, the number of pixels occupied by the Gaussian curve exceeds the 5-pixel window size. In this case, the star signal is truncated by the smaller sampling window size. Only partial effective pixels can be involved in calculating the star centroid position estimation. Under this condition, the error is dominated by the truncation systematic error.</p><p>In order to reduce the truncation error as much as possible, a criterion for choosing the size of the sampling window is put forth. The size of sampling window should be a little larger than the Gaussian width. The Gaussian width (PSF size) is decided by the defocusing. If a small displacement <italic>&#x003b4;<sub>Z</sub></italic> from the image plane, the Gaussian width will increase and its diameter is [<xref ref-type="bibr" rid="b14-sensors-11-07341">14</xref>]:
<disp-formula id="FD32"><label>(32)</label><mml:math id="M35"><mml:mrow><mml:mi>D</mml:mi><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>&#x003b4;</mml:mi><mml:mi>Z</mml:mi></mml:msub></mml:mrow><mml:mrow><mml:mi>F</mml:mi><mml:mo>#</mml:mo></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>where the F# is the optics number of the image sensor. The unit of the D is &#x003bc;m.</p><p>The size of sampling window can be chosen following the function below:
<disp-formula id="FD33"><label>(33)</label><mml:math id="M36"><mml:mrow><mml:msub><mml:mi>W</mml:mi><mml:mi mathvariant="italic">size</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi mathvariant="italic">fix</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mfrac><mml:mi>D</mml:mi><mml:mrow><mml:msub><mml:mi mathvariant="italic">Pixel</mml:mi><mml:mi mathvariant="italic">size</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:math></disp-formula>where fix is the corresponding function in MATLAB, which rounds the elements towards zero. The term <italic>pixel<sub>size</sub></italic> is the single pixel size of the image plane (e.g., STAR250 <italic>pixel<sub>size</sub></italic> = 25 <italic>&#x003bc;m</italic>), <italic>D/ pixel<sub>size</sub></italic> is the Gaussian width of the star signal. In order to let the sampling window size be larger than the Gaussian width, the sampling window size <italic>W<sub>size</sub></italic> adds one additional pixel on the Gaussian width. Under this operation, we can reduce the truncation systematic error as much as possible. Then, the systematic error of the COM algorithm is just dominated by the approximation error.</p><p>Through an appropriate numerical simulation, we can get the relationship between the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub>, the ideal star centroid position <italic>x</italic><sub>0</sub> and the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> contaminated by the error. From the <xref ref-type="disp-formula" rid="FD30">Equation (30)</xref>, we can calculate the ideal star centroid position <italic>x</italic><sub>0</sub> as follows:
<disp-formula id="FD34"><label>(34)</label><mml:math id="M37"><mml:mrow><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>X</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p></sec></sec><sec><label>3.</label><title>The LSSVR Compensation Algorithm</title><p>The relationship between the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> is the basis of our compensation algorithm. We will design a novel algorithm based on the least squares support vector regression (LSSVR) to estimate the systematic error, which can be used to eliminate the systematic error caused by the nature of the COM algorithm.</p><sec><label>3.1.</label><title>The Least Squares Support Vector Regression</title><p>The support vector machine (SVM) technique was developed by Vapnik in 1995 [<xref ref-type="bibr" rid="b15-sensors-11-07341">15</xref>]. SVM is motivated by statistical learning theory based on the principle of structural risk minimization, shown to be superior to the traditional empirical risk minimization principle employed by traditional neural networks. It can be applied in classification and regression. SVR is used to find out the underlying relationships between input and target output vector, especially for modeling nonlinear relationships. It has been proven to be a powerful method for solving problems in nonlinear density estimation and function estimation [<xref ref-type="bibr" rid="b16-sensors-11-07341">16</xref>,<xref ref-type="bibr" rid="b17-sensors-11-07341">17</xref>]. LSSVR, proposed by Suykens, is an alternate formulation of SVR [<xref ref-type="bibr" rid="b18-sensors-11-07341">18</xref>]. The reason for choosing LSSVR as the function estimation is its lower memory requirements, as well as the achievement of a global solution within a fast training speed [<xref ref-type="bibr" rid="b19-sensors-11-07341">19</xref>,<xref ref-type="bibr" rid="b20-sensors-11-07341">20</xref>]. The primary ridge regression model of LSSVR in the function estimation problem is formulated as:
<disp-formula id="FD35"><label>(35)</label><mml:math id="M38"><mml:mrow><mml:munder><mml:mrow><mml:mtext>min</mml:mtext></mml:mrow><mml:mrow><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi></mml:mrow></mml:munder><mml:mo>&#x1d4ad;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003b3;</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow></mml:mrow></mml:math></disp-formula>subject to the equality constraints:
<disp-formula id="FD36"><label>(36)</label><mml:math id="M39"><mml:mrow><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>&#x003c6;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula>where <italic>&#x003b3;</italic> is a positive real constant and <italic>&#x003be;<sub>i</sub></italic> is slack variable. In this function estimation problem, the Lagrangian is:
<disp-formula id="FD37"><label>(37)</label><mml:math id="M40"><mml:mrow><mml:msub><mml:mi>L</mml:mi><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo>;</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:msup><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>W</mml:mi><mml:mo>+</mml:mo><mml:mi>&#x003b3;</mml:mi><mml:mfrac><mml:mn>1</mml:mn><mml:mn>2</mml:mn></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mn>2</mml:mn></mml:msubsup></mml:mrow><mml:mo>&#x02212;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msup><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>&#x003c6;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mi>&#x003be;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>where <italic>&#x003b1;<sub>i</sub></italic> are Lagrange multipliers. The conditions for optimality are given by [<xref ref-type="bibr" rid="b21-sensors-11-07341">21</xref>]:
<disp-formula id="FD38"><label>(38)</label><mml:math id="M41"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo>;</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02202;</mml:mo></mml:mrow><mml:mi>W</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo><mml:mi>W</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mi>&#x003c6;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo>;</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02202;</mml:mo></mml:mrow><mml:mi>b</mml:mi></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo>;</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02202;</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mi>&#x003b3;</mml:mi><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:mfrac><mml:mrow><mml:mo>&#x02202;</mml:mo><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mi>N</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:mi>W</mml:mi><mml:mo>,</mml:mo><mml:mi>b</mml:mi><mml:mo>,</mml:mo><mml:mi>&#x003be;</mml:mi><mml:mo>;</mml:mo><mml:mi>&#x003b1;</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mo>&#x02202;</mml:mo></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:mfrac><mml:mo>=</mml:mo><mml:mn>0</mml:mn><mml:mo>&#x02192;</mml:mo><mml:msup><mml:mrow><mml:mi>W</mml:mi></mml:mrow><mml:mi>T</mml:mi></mml:msup><mml:mi>&#x003c6;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>+</mml:mo><mml:msub><mml:mrow><mml:mi>&#x003be;</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mrow><mml:mi>y</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>After eliminating the <italic>W</italic> and <italic>&#x003be;</italic>, the Karush-Kuhn-Tucker (KKT) system is obtained as:
<disp-formula id="FD39"><label>(39)</label><mml:math id="M42"><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd><mml:mtd><mml:mrow><mml:msubsup><mml:mi>I</mml:mi><mml:mi>n</mml:mi><mml:mi>T</mml:mi></mml:msubsup></mml:mrow></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mrow><mml:msub><mml:mi>I</mml:mi><mml:mi>n</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd><mml:mrow><mml:mi>K</mml:mi><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>&#x003b3;</mml:mi></mml:mrow><mml:mrow><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msup><mml:mi>E</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mi>b</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>&#x003b1;</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mtable><mml:mtr><mml:mtd><mml:mn>0</mml:mn></mml:mtd></mml:mtr><mml:mtr><mml:mtd><mml:mi>y</mml:mi></mml:mtd></mml:mtr></mml:mtable></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula>where <italic>I<sub>n</sub></italic> = [1,&#x02026;,1]<italic><sup>T</sup></italic>, <italic>&#x003b1;</italic> = [<italic>&#x003b1;</italic><sub>1</sub>,&#x02026;, <italic>&#x003b1;<sub>N</sub></italic>]<italic><sup>T</sup></italic>, <italic>y</italic> = [<italic>y</italic><sub>1</sub>,&#x02026;, <italic>y<sub>N</sub></italic>]<italic><sup>T</sup></italic>, <italic>K</italic> = <italic>K</italic>(<italic>x<sub>i</sub></italic><italic>,x<sub>j</sub></italic>) = <italic>&#x003c6;</italic>(<italic>x<sub>i</sub></italic>)<italic><sup>T</sup></italic> <italic>&#x003c6;</italic>(<italic>x<sub>j</sub></italic>). <italic>K</italic>(.,.) is the kernel function, which can be expressed as the inner product of two vectors in some feature space. There are many Mercer kernel functions <italic>K</italic>(<italic>x</italic>,.<italic>x<sub>i</sub></italic>) that can be chosen, such as 
<inline-formula><mml:math id="M43"><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mtext>tanh</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mi>k</mml:mi><mml:msubsup><mml:mi>x</mml:mi><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mi>&#x003b8;</mml:mi><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula> (hyperbolic tangent kernel), 
<inline-formula><mml:math id="M44"><mml:mrow><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>j</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msubsup><mml:mi>x</mml:mi><mml:mi>j</mml:mi><mml:mi>T</mml:mi></mml:msubsup><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mi>d</mml:mi></mml:msup></mml:mrow></mml:math></inline-formula> (polynomial kernel) and <italic>K</italic>(<italic>x<sub>i</sub></italic>,<italic>x<sub>j</sub></italic>) = exp{&#x02013;||<italic>x<sub>i</sub></italic> &#x02212; <italic>x<sub>j</sub></italic>||<sup>2</sup> / <italic>&#x003c3;</italic><sup>2</sup>} (the RBF kernel). Finally, for an input x, we can predict the output of the LSSVR model in response to the input x as:
<disp-formula id="FD40"><label>(40)</label><mml:math id="M45"><mml:mrow><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msup><mml:mi>W</mml:mi><mml:mi>T</mml:mi></mml:msup><mml:mi>&#x003c6;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:mi>b</mml:mi><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mi>b</mml:mi><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula>where 
<inline-formula><mml:math id="M46"><mml:mrow><mml:msubsup><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <italic>b</italic><italic><sup>*</sup></italic> are the optimal solutions of <xref ref-type="disp-formula" rid="FD39">Equation (39)</xref>.</p><p>Through the <xref ref-type="disp-formula" rid="FD40">Equation (40)</xref>, we can find that the LSSVR just calculates sets of linear Equations rather than solving the dual problem in SVR. Furthermore, if we use the RBF kernel, only two parameters (<italic>&#x003b3;, &#x003c3;</italic>) are needed for LSSVR in <xref ref-type="disp-formula" rid="FD39">Equation (39)</xref>. However, except for the parameters (<italic>&#x003b3;, &#x003c3;</italic>) are needed in SVR, the parameter <italic>&#x003be;</italic> also should be considered which is the regression error in the e-insensitive loss function. The advantage of low computation complex of LSSVR makes it suitable for our systematic error compensation algorithm.</p></sec><sec><label>3.2.</label><title>LSSVR Calculation</title><p>The LSSVR model is used for function estimation. In practice, we can&#x02019;t get the ideal star centroid position <italic>x</italic><sub>0</sub> but can get the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> calculated by <xref ref-type="disp-formula" rid="FD29">Equation (29)</xref>. According to the <xref ref-type="disp-formula" rid="FD40">Equation (40)</xref>, we can use the LSSVR to estimate the functional relationship between the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic>. If we use the RBF kernel, the estimation function can be written as:
<disp-formula id="FD41"><label>(41)</label><mml:math id="M47"><mml:mrow><mml:mi>&#x003c3;</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mtext>exp</mml:mtext><mml:mo stretchy="false">[</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>/</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mn>2</mml:mn><mml:msup><mml:mrow><mml:mi>&#x003c3;</mml:mi></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup></mml:mrow></mml:mrow></mml:math></disp-formula>where the x is the input of actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> in practical operation. 
<inline-formula><mml:math id="M48"><mml:mrow><mml:msubsup><mml:mi>&#x003b1;</mml:mi><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup></mml:mrow></mml:math></inline-formula> and <italic>b<sup>*</sup></italic> are the optimal solutions of <xref ref-type="disp-formula" rid="FD39">Equation (39)</xref>. Then, when we input the <italic>&#x00078;&#x00302;<sub>g</sub></italic> into the LSSVR model, it will predict its corresponding output of systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub>, and we can use <xref ref-type="disp-formula" rid="FD34">Equation (34)</xref> to calculate the ideal star centroid position <italic>x</italic><sub>0</sub>. Through this operation, we can achieve the aim of eliminating the systematic star centroid position error caused by the nature of the COM algorithm.</p></sec></sec><sec><label>4.</label><title>Experimental Results and Analysis</title><p>In this section, we design a number of experiments to verify the performance of the systematic error compensation algorithm based on the least square support vector regression. The experiments are prepared in three steps. Firstly, before using the LSSVR for function estimation, we should obtain the input training samples through the numerical simulations. Secondly, some parameters can influence the performance of the LSSVR for function estimation. We should use the cross-validation method to get the optimal value of the parameters to guarantee the fitting and prediction accuracy of the LSSVR model. Thirdly, we use our compensation algorithm in the processing of a simulated star image to judge the performance of our proposed LSSVR systematic error compensation algorithm. All these simulations are carried on MATLAB 7.1 software platform run on a Pentium IV 2.8 GHz processor.</p><sec><label>4.1.</label><title>Pre-Process the Training Samples</title><p>In order to use the LSSVR for regression the relationship between the ideal star centroid position <italic>x</italic><sub>0</sub>, the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic> (under the systematic error) and the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> under different Gaussian width in <xref ref-type="disp-formula" rid="FD34">Equation (34)</xref>, we should design a number of numerical simulations to get the relationship function among them. Considering the real image sensor STAR250, its image plane size is 512 &#x000d7; 512 pixels, single pixel size is 25 &#x003bc;m, FOV size is 8&#x000b0; &#x000d7; 8&#x000b0;. The starlight projected onto the image plane can be viewed as point light sources, and the starlight signal intensity spread point function is reasonable approximated by the Gaussian function. Just considering the x direction, it can be expressed by <xref ref-type="disp-formula" rid="FD13">Equation (13)</xref>. We also assume the fill factor of the active pixel sensors is 100% and each pixel has the same photon response. Then, the detected signal intensity function can be given by <xref ref-type="disp-formula" rid="FD31">Equation (31)</xref>. As mentioned in Sections 2.2 and 2.3, there are two situations that should be considered. The first one is when the sampling window size is larger than the Gaussian width; in this case the systematic error is dominated by the approximation error. Another is when the Gaussian width is larger than the sampling window size; in this case the systematic error is composed of the approximation error and the truncation error. In actual operation, the Gaussian width is increased as the star light intensity is strengthened, soif we use a set sized sampling window, such as 3 &#x000d7; 3 or 5 &#x000d7; 5 pixels, both situations above will exist. The experiments take full consideration of the two situations above, and we set the sampling window size to be 5 &#x000d7; 5 pixels. The Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic> is set to be 0.3 (situation 1) and 0.9 (situation 2), respectively. Other values of <italic>&#x003c3;<sub>PSF</sub></italic> also can be simulated using the same method and form the compensation template to eliminate the systematic error under different <italic>&#x003c3;<sub>PSF</sub></italic> scenarios.</p><p>We assume the one single starlight is projected on the position (50,160). Just considering the x direction, the star centroid position of the starlight in x direction will range from 50 to 51. We subdivide the one pixel into 300 equivalent parts, and the ideal star centroid position in x direction <italic>x</italic><sub>0</sub> from the 50.0033, 50.0066, &#x02026;, till 51, the simulation step is 0.0033 pixels. If higher star centroid position accuracy is desired, one can reduce the interval of the simulation step but then one must sacrifice the computation time for training the LSSVR. For every trial, we will record the <italic>x</italic><sub>0</sub> and the corresponding actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic>, then their different is the systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub>. Under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3 and 0.9, we can get their relationship, seen in <xref ref-type="fig" rid="f6-sensors-11-07341">Figure 6</xref>.</p><p>In <xref ref-type="fig" rid="f6-sensors-11-07341">Figure 6</xref>, we can see that the maximum systematic error is nearly 0.06 pixel under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3 and nearly 0.1 pixel under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9. In the STAR250, one pixel accuracy is 56.25&#x02033; Then, 0.06 pixel is approximately 4 arc-second, and the error is big enough to influence the accuracy of the star sensor. It is necessary to design a compensation algorithm to reduce the systematic error. Three hundred training samples can be used to train the LSSVR model to estimate the function above.</p></sec><sec><label>4.2.</label><title>The Fitting Accuracy of the LSSVR</title><p>The fitting and prediction accuracy are the two main aspects used to judge the quality of our LSSVR model. There are three main parameters that can influence the fitting and prediction accuracy, these are the parameter <italic>&#x003c3;</italic> of the RBF kernel, degree d of the polynomial function, and parameter <italic>&#x003b3;</italic> of slack variable in <xref ref-type="disp-formula" rid="FD37">Equation (37)</xref>. The number of training samples is 300, a relatively small number, so we employ the leave-one-out cross validation approach to choose the optimal parameters. In the optimization of these parameters, the root mean squared error of prediction (RMSEP) of the assessing set is used as an evaluation criterion:
<disp-formula id="FD42"><label>(42)</label><mml:math id="M49"><mml:mrow><mml:mtable columnalign="left"><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow><mml:msub><mml:mo>&#x1d4ad;</mml:mo><mml:mi mathvariant="italic">RMSEP</mml:mi></mml:msub></mml:mrow></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msup><mml:mrow><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mi>f</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:msqrt></mml:mrow></mml:mtd></mml:mtr><mml:mtr columnalign="left"><mml:mtd columnalign="left"><mml:mrow/></mml:mtd><mml:mtd columnalign="left"><mml:mrow><mml:mo>=</mml:mo><mml:msqrt><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:mrow><mml:msup><mml:mrow><mml:mo stretchy="false">[</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>Y</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:munderover><mml:mo>&#x02211;</mml:mo><mml:mrow><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>N</mml:mi></mml:munderover><mml:mrow><mml:msubsup><mml:mrow><mml:mi>&#x003b1;</mml:mi></mml:mrow><mml:mi>i</mml:mi><mml:mo>*</mml:mo></mml:msubsup><mml:mi>K</mml:mi><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mrow><mml:mi>x</mml:mi></mml:mrow><mml:mi>i</mml:mi></mml:msub><mml:mo>,</mml:mo><mml:mi>x</mml:mi><mml:mo stretchy="false">)</mml:mo><mml:mo>&#x02212;</mml:mo><mml:msup><mml:mrow><mml:mi>b</mml:mi></mml:mrow><mml:mo>*</mml:mo></mml:msup><mml:mo stretchy="false">)</mml:mo></mml:mrow><mml:mo stretchy="false">]</mml:mo></mml:mrow><mml:mn>2</mml:mn></mml:msup></mml:mrow></mml:mrow></mml:mrow></mml:msqrt><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mo>&#x02009;</mml:mo><mml:mi>i</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#x02026;</mml:mo><mml:mi>N</mml:mi></mml:mrow></mml:mtd></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula>where <italic>Y<sub>i</sub></italic> is the ideal star centroid position <italic>x</italic><sub>0</sub>, <italic>f</italic>(<italic>x</italic>) is the prediction output of LSSVR model(with input of actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic>). N is the number of prediction samples. Using the criterion of <xref ref-type="disp-formula" rid="FD42">Equation (42)</xref>, we compared the performance of RBF kernel and the polynomial kernel. The RMSEP of the RBF kernel is smaller than that of polynomial kernel by at least one order of magnitude, so we choose the RBF kernel and the LSSVR parameters <italic>&#x003c3;</italic> and <italic>&#x003b3;</italic> are optimized. 
<inline-formula><mml:math id="M50"><mml:mrow><mml:mi>&#x003b1;</mml:mi><mml:mo>=</mml:mo><mml:msqrt><mml:mn>2</mml:mn></mml:msqrt></mml:mrow></mml:math></inline-formula>, <italic>&#x003b3;</italic> = 2.6 &#x000d7; 10<sup>5</sup> are used in the calculation. The performance of the regression of the LSSVR is shown in <xref ref-type="fig" rid="f7-sensors-11-07341">Figure 7</xref>.</p><p>In <xref ref-type="fig" rid="f7-sensors-11-07341">Figure 7</xref>, we can see that the fitting curve nearly overlaps with the relationship function in <xref ref-type="fig" rid="f6-sensors-11-07341">Figure 6</xref>, and it illustrates that the fitting accuracy of the LSSVR is pretty high under two situations. The corresponding fitting errors of the LSSVR are shown in <xref ref-type="fig" rid="f8-sensors-11-07341">Figure 8</xref>.</p><p>The fitting error is defined by the difference between the actual systematic error <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> and the predicted systematic error <italic>&#x003c3;<sub>lssvr</sub></italic> which is the output of the LSSVR model. From <xref ref-type="fig" rid="f8-sensors-11-07341">Figure 8</xref>, we can see that under the two situations, the maximum fitting errors of the LSSVR are all smaller than 4 &#x000d7; 10<sup>&#x02212;5</sup> pixels, but a high fitting accuracy cannot illustrate the performance of the LSSVR model completely. What we are most concerned with is the prediction accuracy of the LSSVR model.</p></sec><sec><label>4.3.</label><title>The Prediction Accuracy of the LSSVR</title><p>Firstly, we should give the definition of the prediction accuracy of the LSSVR model. We use the LSSVR model to predict the systematic error <italic>&#x003c3;<sub>lssvr</sub></italic> with the input of the actual star centroid position <italic>&#x00078;&#x00302;<sub>g</sub></italic>, then the star centroid position after compensation can be calculated as:
<disp-formula id="FD43"><label>(43)</label><mml:math id="M51"><mml:mrow><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:mover></mml:mrow><mml:mi>g</mml:mi><mml:mo stretchy="false">^</mml:mo></mml:msubsup><mml:msup><mml:mrow/><mml:mo stretchy="false">^</mml:mo></mml:msup><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi mathvariant="italic">LSSVR</mml:mi><mml:mi mathvariant="italic">predict</mml:mi></mml:msub><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mi>g</mml:mi></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>&#x003c3;</mml:mi><mml:mi mathvariant="italic">lssvr</mml:mi></mml:msub></mml:mrow></mml:math></disp-formula>where <italic>&#x00078;&#x00302;<sub>g</sub></italic> is the actual star centroid position in practical operation (input of LSSVR), <italic>&#x003c3;<sub>lssvr</sub></italic> is the predicted systematic error (output of the LSSVR), and <italic>&#x00078;&#x00303;</italic><sub>0</sub> is the star centroid position after compensation. Through the <xref ref-type="disp-formula" rid="FD43">Equation (43)</xref>, we can get the prediction error of the LSSVR model in the following Equation:
<disp-formula id="FD44"><label>(44)</label><mml:math id="M52"><mml:mrow><mml:msub><mml:mi>&#x003b6;</mml:mi><mml:mi mathvariant="italic">predict</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mi>x</mml:mi><mml:mo>&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mn>0</mml:mn></mml:msub><mml:mo>&#x02212;</mml:mo><mml:msub><mml:mi>x</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:math></disp-formula>where <italic>x</italic><sub>0</sub> is the ideal star centroid position, <italic>&#x003b6;<sub>predict</sub></italic> is the prediction error of the LSSVR.</p><p>With the optimal parameters, a LSSVR model was trained using the 300 samples of data in Section 4.1. In order to test the prediction performance of the trained LSSVR model, we select 500 star points which are projected on the CCD image plane randomly. We also just consider the x direction, and all the 500 star centroid positions of the star in the x direction will range from 100 to 201. The experiments are shown in <xref ref-type="fig" rid="f9-sensors-11-07341">Figure 9</xref>.</p><p>The 500 random experiments results under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3 and <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9 are shown in the left side of <xref ref-type="fig" rid="f9-sensors-11-07341">Figure 9(a,b)</xref>. The right sides of <xref ref-type="fig" rid="f9-sensors-11-07341">Figure 9(a,b)</xref> are corresponding enlarged pictures of the left side. The blue line is the ideal star position <italic>x</italic><sub>0</sub> and the red line is the compensated star centroid position <italic>&#x00078;&#x00303;</italic><sub>0</sub>. From the right side of the <xref ref-type="fig" rid="f9-sensors-11-07341">Figure 9</xref>, we can see that every compensated <italic>&#x00078;&#x00303;</italic><sub>0</sub> is very close to its corresponding ideal position <italic>x</italic><sub>0</sub>. It demonstrates that our trained LSSVR model can achieve high prediction accuracy. The prediction error of the LSSVR model is shown in <xref ref-type="fig" rid="f10-sensors-11-07341">Figure 10</xref>.</p><p>From <xref ref-type="fig" rid="f10-sensors-11-07341">Figure 10</xref>, we can see that the prediction errors of our LSSVR model are smaller than 6 &#x000d7; 10<sup>&#x02212;5</sup> pixels under the two situations <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3 and <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9. The result shows that the proposed compensation algorithm can achieve high star centroid position accuracy under different Gaussian widths. The accuracy of our systematic compensation algorithm is much higher than methods proposed by other scholars, such as the neural network method [<xref ref-type="bibr" rid="b9-sensors-11-07341">9</xref>] that can reach 5 &#x000d7; 10<sup>&#x02212;3</sup> accuracy and the analytical compensation method [<xref ref-type="bibr" rid="b10-sensors-11-07341">10</xref>] which can reach 2 &#x000d7; 10<sup>&#x02212;4</sup> accuracy.</p></sec><sec><label>4.4.</label><title>The Performance of the Compensation Algorithm in Simulations</title><p>In addition to the single star point simulations, we also apply the compensation algorithm to simulated star image testing. We select a star sensor field of view (FOV) point randomly, and suppose the point&#x02019;s right ascension, declination and the angle rotation are (130, 60, 60). The FOV size is 18 degree, using the sky2000 version 4 star catalog (developed by the NASA&#x02019;s Goddard Space Flight Center), the stars&#x02019; magnitudes in the image are all lower than 6.5 and the <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. The simulated star image is shown in <xref ref-type="fig" rid="f11-sensors-11-07341">Figure 11</xref>.</p><p>In <xref ref-type="fig" rid="f11-sensors-11-07341">Figure 11</xref>, we can see that there are 20 stars in the star image. We select 10 of them to compare their errors before compensation and after compensation. The results are shown in <xref ref-type="table" rid="t1-sensors-11-07341">Table 1</xref>.</p><p>Through the experiments above, we can find that the systematic error compensation proposed by the Least Squares Support Vector Regression can achieve high accuracy star centroid positions estimation and meet the high attitude pointing accuracy requirements of star sensors.</p></sec><sec><label>4.5.</label><title>The Performance of the Compensation Algorithm in Actual Images Experiments</title><p>In addition to the simulated images testing, we also apply the compensation algorithm on some actual images. The actual night sky images were captured on NAOC&#x02019;s observation station in XingLong, Hebei Province (China), in December 2009. We took about 900 images under different directions. The CANON 20D camera is used, whose focal length is 50 mm, the pixel size is 6.42 &#x003bc;m, the field of view is 25.36 &#x000d7; 17.06 degree, and the plane size is 3,504 &#x000d7; 2,336 pixels. In order to reduce the effects of image distortion, we just used the 12 &#x000d7; 12 degree field of view in the center of each image. One night sky actual image is shown in <xref ref-type="fig" rid="f12-sensors-11-07341">Figure 12</xref>.</p><p>We used the zenith observation method to test the accuracy of the star tracker [<xref ref-type="bibr" rid="b22-sensors-11-07341">22</xref>,<xref ref-type="bibr" rid="b23-sensors-11-07341">23</xref>]. The zenith method takes the Earth as an evenly rotational turntable. It needs a high accuracy spirit level to make sure the star tracker is pointed in the zenith direction. The star tracker captured the pictures from the zenith direction and calculated the attitude. Then, we use our knowledge of astronomy to figure out the ideal zenith direction at the shooting time. Comparing the star tracker&#x02019;s attitude with the zenith ideal attitude, we can test the accuracy of the star tracker and thus prove the effectiveness of our LSSVR compensation algorithm.</p><p>In the 900 sky night actual images, there are about 100 images pointing at the zenith. We selected 66 images to test the accuracy of the star tracker and thus test our LSSVR compensation algorithm. The 66 images are taken under different noise conditions. Through the 66 actual images, we can calculate 66 attitude directions by the star tracker. According to the shooting time and place, we also can calculate 66 ideal zenith directions through the zenith observation method. Before calculating the accuracy of the star tracker, we should eliminate the constant bias on star tracker&#x02019;s optical axis caused by the assembly. We choose 10 images from the 66 images to calculate the mean of constant bias on the star tracker&#x02019;s optical axis. After eliminating the constant bias on the optical axis, we can get the accuracy of the star tracker on the yaw axis and roll axis. The experimental results are shown in <xref ref-type="fig" rid="f13-sensors-11-07341">Figure 13</xref>.</p><p>From <xref ref-type="fig" rid="f13-sensors-11-07341">Figure 13</xref>, we can see that the accuracy of the star tracker after compensation is higher than before compensation. The actual images experiments can test the performance of our compensation algorithm under different random noise conditions. The 66 actual images are taken under different random noise conditions. Through the <xref ref-type="fig" rid="f13-sensors-11-07341">Figure 13</xref>, we also can see that when the random noise is large, the compensation performance is not obvious. When the random noise is small, the accuracy of the star tracker is very high after compensation. The high performance of our LSSVR compensation algorithm under large random noise condition is to be further studied and improved in our future work.</p></sec></sec><sec><label>5.</label><title>Conclusions</title><p>This paper analyzed the systematic error of star image centroid estimation utilizing frequency domain analysis and numerical simulations. The sampling frequency limitation and sampling window size limitation are fully considered and the systematic error is then divided into an approximation error and a truncation error. Through the frequency domain analysis, an approximate sinusoidal and linear relationship between systematic error and actual star centroid position are obtained under sampling frequency limitation and under sampling window size limitation, respectively. A novel systematic error compensation algorithm based on the LSSVR is presented. According to the two types of systematic errors, a number of experiments are designed to test the LSSVR compensation algorithm. Simulation results show that after compensation, the residual systematic error of star centroid estimation is less than 6 &#x000d7; 10<sup>&#x02212;5</sup> pixels under 5 &#x000d7; 5 pixel sampling window size. Compared to the neural network method and the analytical compensation algorithm, the proposed method&#x02019;s accuracy is one or two orders of magnitude higher than that of these two algorithms and can meet the requirements of high accuracy star sensors. Since we have not considered the influence of random noise to the proposed method, the high performance of our LSSVR compensation algorithm under large random noise conditions is to be further studied in our future work.</p></sec></body><back><ack><p>This research was supported by the National Basic Research Program of China (973 Program, No.2010CB731800) and Chinese Aviation Science Foundation Grant (2008758003).</p></ack><ref-list><title>References</title><ref id="b1-sensors-11-07341"><label>1.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Liebe</surname><given-names>CC</given-names></name></person-group><article-title>Accuracy performance of star trackers&#x02013;A tutorial</article-title><source>IEEE Trans. Aero. Electron. Syst</source><year>2002</year><volume>38</volume><fpage>587</fpage><lpage>599</lpage></element-citation></ref><ref id="b2-sensors-11-07341"><label>2.</label><element-citation publication-type="other"><person-group person-group-type="author"><name><surname>Katake</surname><given-names>AB</given-names></name></person-group><article-title>Modeling, Image Processing and Attitude Estimation of High Speed Star Sensors</article-title><comment>Ph.D. Thesis, Texas A&#x00026;M University, College Station, TX, USA</comment><year>2006</year><fpage>33</fpage><lpage>37</lpage></element-citation></ref><ref id="b3-sensors-11-07341"><label>3.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Jahne</surname><given-names>B</given-names></name></person-group><source>Practical Handbook on Image Processing for Scientific Application</source><edition>2nd ed</edition><publisher-name>CRC Press</publisher-name><publisher-loc>Boca Raton, FL, USA</publisher-loc><year>2004</year></element-citation></ref><ref id="b4-sensors-11-07341"><label>4.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Grossman</surname><given-names>SB</given-names></name><name><surname>Emmons</surname><given-names>RB</given-names></name></person-group><article-title>Performance analysis and size optimization of focal planes for point-source tracking algorithm applications</article-title><source>Opt. Eng</source><year>1984</year><volume>23</volume><fpage>167</fpage><lpage>176</lpage></element-citation></ref><ref id="b5-sensors-11-07341"><label>5.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Hegedus</surname><given-names>ZS</given-names></name><name><surname>Small</surname><given-names>GW</given-names></name></person-group><article-title>Shape measurement in industry with sub-pixel definition</article-title><source>Acta Polytech. Scand. Appl</source><year>1985</year><volume>150</volume><fpage>101</fpage><lpage>104</lpage></element-citation></ref><ref id="b6-sensors-11-07341"><label>6.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Stanton</surname><given-names>RH</given-names></name><name><surname>Alexander</surname><given-names>JW</given-names></name><name><surname>Dennison</surname><given-names>EW</given-names></name><name><surname>Glavich</surname><given-names>TA</given-names></name><name><surname>Hovland</surname><given-names>LF</given-names></name></person-group><article-title>Optical tracking using charge-coupled devices</article-title><source>Opt. Eng</source><year>1987</year><volume>26</volume><fpage>930</fpage><lpage>938</lpage></element-citation></ref><ref id="b7-sensors-11-07341"><label>7.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Alexander</surname><given-names>BF</given-names></name><name><surname>Kim</surname><given-names>CN</given-names></name></person-group><article-title>Elimination of systematic error in subpixel accuracy centroid estimation</article-title><source>Opt. Eng</source><year>1991</year><volume>30</volume><fpage>1320</fpage><lpage>1330</lpage></element-citation></ref><ref id="b8-sensors-11-07341"><label>8.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jean</surname><given-names>PF</given-names></name></person-group><article-title>Subpixel accuracy location estimation from digital signals</article-title><source>Opt. Eng</source><year>1992</year><volume>31</volume><fpage>2465</fpage><lpage>2471</lpage></element-citation></ref><ref id="b9-sensors-11-07341"><label>9.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Rufino</surname><given-names>G</given-names></name><name><surname>Accardo</surname><given-names>D</given-names></name></person-group><article-title>Enhancement of the centroiding algorithm for star tracker measure refinement</article-title><source>Acta Astronaut</source><year>2003</year><volume>53</volume><fpage>135</fpage><lpage>147</lpage></element-citation></ref><ref id="b10-sensors-11-07341"><label>10.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Jia</surname><given-names>H</given-names></name><name><surname>Yang</surname><given-names>JK</given-names></name><name><surname>Li</surname><given-names>XJ</given-names></name><name><surname>Yang</surname><given-names>JC</given-names></name><name><surname>Yang</surname><given-names>MF</given-names></name><name><surname>Liu</surname><given-names>YW</given-names></name><name><surname>Hao</surname><given-names>YC</given-names></name></person-group><article-title>Systematic error analysis and compensation for high accuracy star centroid estimation of star tracker</article-title><source>Sci. China Ser. E: Eng. Mater. Sci</source><year>2010</year><volume>53</volume><fpage>3145</fpage><lpage>3152</lpage></element-citation></ref><ref id="b11-sensors-11-07341"><label>11.</label><element-citation publication-type="confproc"><person-group person-group-type="author"><name><surname>Eisenman</surname><given-names>AR</given-names></name><name><surname>Liebe</surname><given-names>CC</given-names></name></person-group><article-title>The Advancing State-of-the Art in Second Generation Star Trackers</article-title><conf-name>Proceedings of the 2th IEEE International Conference on Aerospace Application</conf-name><conf-loc>Aspen, CO, USA</conf-loc><conf-date>1&#x02013;4 September 1998</conf-date></element-citation></ref><ref id="b12-sensors-11-07341"><label>12.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Faraji</surname><given-names>H</given-names></name><name><surname>Maclean</surname><given-names>WJ</given-names></name></person-group><article-title>CCD noise removal in digital images</article-title><source>IEEE T. Image. Proc</source><year>2006</year><volume>15</volume><fpage>2676</fpage><lpage>2685</lpage></element-citation></ref><ref id="b13-sensors-11-07341"><label>13.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>YF</given-names></name><name><surname>Hao</surname><given-names>ZH</given-names></name></person-group><article-title>Research of hyper accuracy subpixel subdivision location algorithm for star image</article-title><source>Opt. Technol</source><year>2005</year><volume>31</volume><fpage>666</fpage><lpage>671</lpage></element-citation></ref><ref id="b14-sensors-11-07341"><label>14.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Smith</surname><given-names>WJ</given-names></name></person-group><source>Modern Lens Design: A Resourse Manual</source><publisher-name>McGraw-Hill</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>1992</year><volume>47</volume></element-citation></ref><ref id="b15-sensors-11-07341"><label>15.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Vapnik</surname><given-names>V</given-names></name></person-group><source>The Nature of Statistical Learning Theory</source><publisher-name>Springer-Verlag</publisher-name><publisher-loc>New York, NY, USA</publisher-loc><year>1995</year></element-citation></ref><ref id="b16-sensors-11-07341"><label>16.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Vapnik</surname><given-names>V</given-names></name><name><surname>Golowich</surname><given-names>S</given-names></name><name><surname>Smola</surname><given-names>A</given-names></name></person-group><article-title>Support vector method for function approximation, regression estimation and signal processing</article-title><source>Adv. Neural Inf. Proc. Syst</source><year>1996</year><volume>9</volume><fpage>281</fpage><lpage>287</lpage></element-citation></ref><ref id="b17-sensors-11-07341"><label>17.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Scholkopf</surname><given-names>B</given-names></name><name><surname>Smola</surname><given-names>A</given-names></name></person-group><article-title>A tutorial on support vector regression</article-title><source>Stat. Comput</source><year>2004</year><volume>14</volume><fpage>199</fpage><lpage>222</lpage></element-citation></ref><ref id="b18-sensors-11-07341"><label>18.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Suykens</surname><given-names>JAK</given-names></name><name><surname>Vandewalle</surname><given-names>J</given-names></name></person-group><article-title>Least squares support vector machine classifiers</article-title><source>Neuroendocrinol. Proc. Lett</source><year>1999</year><volume>9</volume><fpage>293</fpage><lpage>300</lpage></element-citation></ref><ref id="b19-sensors-11-07341"><label>19.</label><element-citation publication-type="book"><person-group person-group-type="author"><name><surname>Suykens</surname><given-names>JAK</given-names></name><name><surname>Gestel</surname><given-names>TV</given-names></name><name><surname>Brabanter</surname><given-names>JD</given-names></name><name><surname>Moor</surname><given-names>BD</given-names></name><name><surname>Vandewalle</surname><given-names>J</given-names></name></person-group><source>Least Squares Support Vector Machines</source><publisher-name>World Scientific</publisher-name><publisher-loc>Singapore</publisher-loc><year>2002</year></element-citation></ref><ref id="b20-sensors-11-07341"><label>20.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>YK</given-names></name><name><surname>Shao</surname><given-names>XG</given-names></name><name><surname>Cai</surname><given-names>WS</given-names></name></person-group><article-title>A consensus least squares support vector regression (LS-SVR) for analysis of near-infrared spectra of plant samples</article-title><source>Talanta</source><year>2007</year><volume>72</volume><fpage>217</fpage><lpage>222</lpage><pub-id pub-id-type="pmid">19071605</pub-id></element-citation></ref><ref id="b21-sensors-11-07341"><label>21.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Goodarzi</surname><given-names>M</given-names></name><name><surname>Freitas</surname><given-names>MP</given-names></name><name><surname>Wu</surname><given-names>CH</given-names></name><name><surname>Duchowicz</surname><given-names>PR</given-names></name></person-group><article-title>pK<sub>a</sub> modeling and prediction of a series of pH indicators through genetic algorithm-least square support vector regression</article-title><source>Chemom. Intell. Lab</source><year>2010</year><volume>101</volume><fpage>102</fpage><lpage>109</lpage></element-citation></ref><ref id="b22-sensors-11-07341"><label>22.</label><element-citation publication-type="journal"><person-group person-group-type="author"><name><surname>Li</surname><given-names>CY</given-names></name><name><surname>Li</surname><given-names>HF</given-names></name><name><surname>Sun</surname><given-names>CH</given-names></name></person-group><article-title>Astronomical calibration method and observation analysis for high-accuracy star sensor</article-title><source>Opt. Precis. Eng</source><year>2006</year><volume>14</volume><fpage>558</fpage><lpage>562</lpage></element-citation></ref><ref id="b23-sensors-11-07341"><label>23.</label><mixed-citation publication-type="webpage">IERS Technical Note No. 32. Available online: <ext-link ext-link-type="uri" xlink:href="http://www.iers.org/nn_11216/SharedDocs/Publikationen/EN/IERS/Publications/tn/TechnNote32/tn32,templateId=raw,property=publicationFile.pdf/tn32.pdf">http://www.iers.org/nn_11216/SharedDocs/Publikationen/EN/IERS/Publications/tn/TechnNote32/tn32,templateId=raw,property=publicationFile.pdf/tn32.pdf</ext-link> (accessed on 25 April 2010).</mixed-citation></ref></ref-list></back><floats-group><fig id="f1-sensors-11-07341" position="float"><label>Figure 1.</label><caption><p>The process of star image sampling: e(x) is the starlight stripe intensity profile function; p(x) is the pixel sensitivity function; f(x) is the continuing pixel signal function; t(x) is the sampling function; g(x) is the discrete pixel signal function.</p></caption><graphic xlink:href="sensors-11-07341f1"/></fig><fig id="f2-sensors-11-07341" position="float"><label>Figure 2.</label><caption><p>Numerical simulations of the relationship between the approximation systematic error of the COM algorithm and the ideal star centroid positions under different Gaussian widths.</p></caption><graphic xlink:href="sensors-11-07341f2"/></fig><fig id="f3-sensors-11-07341" position="float"><label>Figure 3.</label><caption><p>(<bold>a</bold>) The width of Gaussian is larger than the sampling window size; (<bold>b</bold>) The width of Gaussian is smaller than the sampling window size.</p></caption><graphic xlink:href="sensors-11-07341f3"/></fig><fig id="f4-sensors-11-07341" position="float"><label>Figure 4.</label><caption><p>The 2-D result of systematic error of star centroid position estimation under different Gaussian widths.</p></caption><graphic xlink:href="sensors-11-07341f4"/></fig><fig id="f5-sensors-11-07341" position="float"><label>Figure 5.</label><caption><p>The number of pixels occupied of star under different Gaussian width <italic>&#x003c3;<sub>PSF</sub></italic>.</p></caption><graphic xlink:href="sensors-11-07341f5"/></fig><fig id="f6-sensors-11-07341" position="float"><label>Figure 6.</label><caption><p><bold>(a)</bold> The relationship curve between <italic>&#x00078;&#x00302;<sub>g</sub></italic> and <italic>&#x003c3;</italic><sub><italic>&#x00058;&#x00303;</italic><sub><italic>g</italic></sub>, <italic>x</italic></sub> under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. <bold>(b)</bold> For <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9.</p></caption><graphic xlink:href="sensors-11-07341f6"/></fig><fig id="f7-sensors-11-07341" position="float"><label>Figure 7.</label><caption><p>(<bold>a</bold>) The fitting performance of the LSSVR under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. (<bold>b</bold>) For <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9.</p></caption><graphic xlink:href="sensors-11-07341f7"/></fig><fig id="f8-sensors-11-07341" position="float"><label>Figure 8.</label><caption><p>(<bold>a</bold>) The fitting accuracy of the LSSVR under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. (<bold>b</bold>) For <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9.</p></caption><graphic xlink:href="sensors-11-07341f8"/></fig><fig id="f9-sensors-11-07341" position="float"><label>Figure 9.</label><caption><p>(<bold>a</bold>) Experiments of random star positions under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. (<bold>b</bold>) For <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9.</p></caption><graphic xlink:href="sensors-11-07341f9"/></fig><fig id="f10-sensors-11-07341" position="float"><label>Figure 10.</label><caption><p>(<bold>a</bold>) The star centroid position error before and after compensation under <italic>&#x003c3;<sub>PSF</sub></italic> = 0.3. (<bold>b</bold>) For <italic>&#x003c3;<sub>PSF</sub></italic> = 0.9.</p></caption><graphic xlink:href="sensors-11-07341f10"/></fig><fig id="f11-sensors-11-07341" position="float"><label>Figure 11.</label><caption><p>The simulated star image pointing at (130, 60, 60).</p></caption><graphic xlink:href="sensors-11-07341f11"/></fig><fig id="f12-sensors-11-07341" position="float"><label>Figure 12.</label><caption><p>One night sky actual image with FOV 12 &#x000d7; 12 degree.</p></caption><graphic xlink:href="sensors-11-07341f12"/></fig><fig id="f13-sensors-11-07341" position="float"><label>Figure 13.</label><caption><p>(<bold>a</bold>) The accuracy of the star tracker on the yaw axis. (<bold>b</bold>) The accuracy of the star tracker on the roll axis.</p></caption><graphic xlink:href="sensors-11-07341f13"/></fig><table-wrap id="t1-sensors-11-07341" position="float"><label>Table 1.</label><caption><p>The systematic error before and after compensation of the simulated star image.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Star number</bold></th><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Ideal x position</bold></th><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Actual x position before compensation</bold></th><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Error before compensation (pixel)</bold></th><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Actual x position after compensation</bold></th><th align="center" valign="middle" rowspan="1" colspan="1"><bold>Error after compensation (pixel)</bold></th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">188.533005</td><td align="center" valign="middle" rowspan="1" colspan="1">188.574817</td><td align="center" valign="middle" rowspan="1" colspan="1">0.041812</td><td align="center" valign="middle" rowspan="1" colspan="1">188.5330528</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000478</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">2</td><td align="center" valign="middle" rowspan="1" colspan="1">33.886746</td><td align="center" valign="middle" rowspan="1" colspan="1">33.898649</td><td align="center" valign="middle" rowspan="1" colspan="1">0.011903</td><td align="center" valign="middle" rowspan="1" colspan="1">33.8867553</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000093</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">3</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;83.046154</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;83.009843</td><td align="center" valign="middle" rowspan="1" colspan="1">0.036311</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;83.04461024</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000516</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">4</td><td align="center" valign="middle" rowspan="1" colspan="1">200.032901</td><td align="center" valign="middle" rowspan="1" colspan="1">199.976565</td><td align="center" valign="middle" rowspan="1" colspan="1">0.056336</td><td align="center" valign="middle" rowspan="1" colspan="1">200.0329395</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000385</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">5</td><td align="center" valign="middle" rowspan="1" colspan="1">94.366492</td><td align="center" valign="middle" rowspan="1" colspan="1">94.328661</td><td align="center" valign="middle" rowspan="1" colspan="1">0.037831</td><td align="center" valign="middle" rowspan="1" colspan="1">94.3664767</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000153</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">6</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;38.586794</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;38.600159</td><td align="center" valign="middle" rowspan="1" colspan="1">0.013365</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;38.5867838</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000102</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">7</td><td align="center" valign="middle" rowspan="1" colspan="1">24.180883</td><td align="center" valign="middle" rowspan="1" colspan="1">24.170196</td><td align="center" valign="middle" rowspan="1" colspan="1">0.010687</td><td align="center" valign="middle" rowspan="1" colspan="1">24.1808541</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000289</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">8</td><td align="center" valign="middle" rowspan="1" colspan="1">79.488555</td><td align="center" valign="middle" rowspan="1" colspan="1">79.526198</td><td align="center" valign="middle" rowspan="1" colspan="1">0.037643</td><td align="center" valign="middle" rowspan="1" colspan="1">79.4885707</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000157</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">9</td><td align="center" valign="middle" rowspan="1" colspan="1">69.740746</td><td align="center" valign="middle" rowspan="1" colspan="1">69.773062</td><td align="center" valign="middle" rowspan="1" colspan="1">0.032316</td><td align="center" valign="middle" rowspan="1" colspan="1">69.7407809</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000349</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">10</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;95.161995</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;95.120380</td><td align="center" valign="middle" rowspan="1" colspan="1">0.041615</td><td align="center" valign="middle" rowspan="1" colspan="1">&#x02212;95.1620123</td><td align="center" valign="middle" rowspan="1" colspan="1">0.0000173</td></tr></tbody></table></table-wrap></floats-group></article>
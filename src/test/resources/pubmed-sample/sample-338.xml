
<article xmlns:ali="http://www.niso.org/schemas/ali/1.0" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sensors (Basel)</journal-id><journal-id journal-id-type="iso-abbrev">Sensors (Basel)</journal-id><journal-id journal-id-type="publisher-id">sensors</journal-id><journal-title-group><journal-title>Sensors (Basel, Switzerland)</journal-title></journal-title-group><issn pub-type="epub">1424-8220</issn><publisher><publisher-name>MDPI</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">25763649</article-id><article-id pub-id-type="pmc">4435140</article-id><article-id pub-id-type="doi">10.3390/s150305820</article-id><article-id pub-id-type="publisher-id">sensors-15-05820</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Fortified Anonymous Communication Protocol for Location Privacy in WSN: A Modular Approach</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Abuzneid</surname><given-names>Abdel-Shakour</given-names></name><xref ref-type="aff" rid="af1-sensors-15-05820">1</xref><xref rid="c1-sensors-15-05820" ref-type="corresp">*</xref></contrib><contrib contrib-type="author"><name><surname>Sobh</surname><given-names>Tarek</given-names></name><xref ref-type="aff" rid="af1-sensors-15-05820">1</xref></contrib><contrib contrib-type="author"><name><surname>Faezipour</surname><given-names>Miad</given-names></name><xref ref-type="aff" rid="af1-sensors-15-05820">1</xref></contrib><contrib contrib-type="author"><name><surname>Mahmood</surname><given-names>Ausif</given-names></name><xref ref-type="aff" rid="af1-sensors-15-05820">1</xref></contrib><contrib contrib-type="author"><name><surname>James</surname><given-names>John</given-names></name><xref ref-type="aff" rid="af2-sensors-15-05820">2</xref></contrib></contrib-group><contrib-group><contrib contrib-type="editor"><name><surname>Reindl</surname><given-names>Leonhard M.</given-names></name><role>Academic Editor</role></contrib></contrib-group><aff id="af1-sensors-15-05820"><label>1</label>Computer Science and Engineering Department, University of Bridgeport, Bridgeport, CT 06604, USA; E-Mails: <email>sobh@bridgeport.edu</email> (T.S.); <email>mfaezipo@bridgeport.edu</email> (M.F.); <email>Mahmood@bridgeport.edu</email> (A.M.) </aff><aff id="af2-sensors-15-05820"><label>2</label>Department of Electrical Engineering &#x00026; Computer Science, United States Military Academy, West Point, NY 10996, USA; E-Mail: <email>john.james@usma.edu</email></aff><author-notes><corresp id="c1-sensors-15-05820"><label>*</label>Author to whom correspondence should be addressed; E-Mail: <email>abuzneid@bridgeport.edu</email>; Tel.: +1-203-576-4113; Fax: +1-203-576-4401.</corresp></author-notes><pub-date pub-type="epub"><day>10</day><month>3</month><year>2015</year></pub-date><pub-date pub-type="collection"><month>3</month><year>2015</year></pub-date><volume>15</volume><issue>3</issue><fpage>5820</fpage><lpage>5864</lpage><history><date date-type="received"><day>19</day><month>11</month><year>2014</year></date><date date-type="accepted"><day>02</day><month>3</month><year>2015</year></date></history><permissions><copyright-statement>&#x000a9; 2015 by the authors; licensee MDPI, Basel, Switzerland.</copyright-statement><copyright-year>2015</copyright-year><license><license-p><!--CREATIVE COMMONS-->This article is an open access article distributed under the terms and conditions of the Creative Commons Attribution license (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>).</license-p></license></permissions><abstract><p>Wireless sensor network (WSN) consists of many hosts called sensors. These sensors can sense a phenomenon (motion, temperature, humidity, average, max, min, <italic>etc.</italic>) and represent what they sense in a form of data. There are many applications for WSNs including object tracking and monitoring where in most of the cases these objects need protection. In these applications, data <italic>privacy</italic> itself might not be as important as the privacy of source location. In addition to the source location privacy, sink location privacy should also be provided. Providing an efficient end-to-end privacy solution would be a challenging task to achieve due to the open nature of the WSN. The key schemes needed for end-to-end location privacy are anonymity, observability, capture likelihood, and safety period. We extend this work to allow for countermeasures against multi-local and global adversaries. We present a network model protected against a sophisticated threat model: passive /active and local/multi-local/global attacks. This work provides a solution for end-to-end anonymity and location privacy as well. We will introduce a framework called fortified anonymous communication (FAC) protocol for WSN.</p></abstract><kwd-group><kwd>WSN</kwd><kwd>anonymity</kwd><kwd>privacy</kwd><kwd>source location privacy</kwd><kwd>sink privacy</kwd><kwd>contextual privacy</kwd><kwd>routing privacy</kwd><kwd>temporal privacy</kwd><kwd>traffic privacy</kwd><kwd>observability</kwd><kwd>safety period</kwd></kwd-group></article-meta></front><body><sec><title>1. Introduction</title><p>Wireless sensor networks (WSNs) consist of many hosts called sensor nodes (SNs). A wireless sensor device is a simple autonomous host device. It can sense a phenomenon, convert the sensed information into a form of data, process the data and then transmit the data to a sink or a base-station (BS) for further usage or analysis. The sensor host is very limited in terms of storage, cache memory, processing and computing power, communication capabilities and battery lifetime [<xref rid="B1-sensors-15-05820" ref-type="bibr">1</xref>,<xref rid="B2-sensors-15-05820" ref-type="bibr">2</xref>,<xref rid="B3-sensors-15-05820" ref-type="bibr">3</xref>,<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>]. There are many different applications adopting sensor nodes. However, this work focus on monitoring and tracking applications where sensor nodes monitor a certain area and track the presence of a certain object of interest such as an animal in the wildlife, a patient or a doctor in a hospital, or a fellow soldier or a vehicle in the battlefield. When the sensor node senses the object, it reports data to the sink (or to multiple sinks) either directly or through other neighboring sensors. One of the most common applications discussed in source location privacy (SLP) literature is the <italic>panda monitoring game</italic> [<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>,<xref rid="B5-sensors-15-05820" ref-type="bibr">5</xref>]. When a sensor node detects a panda in a certain area, it should report via a message transmitted through intermediate nodes to the sink. In order to protect the panda from hunters or adversaries (ADVs), we need to implement in place an efficient source location privacy scheme (SLP). In such a scenario, location privacy is much more important than the confidentiality of the sensed data itself. Source location privacy is even more important in military, homeland security, and law enforcement, in addition to many other civilian applications [<xref rid="B6-sensors-15-05820" ref-type="bibr">6</xref>]. In addition, base-station location privacy (BLP) is very crucial for every WSN since it aggregates all the data.</p></sec><sec><title>2. Problem Statement</title><p>Privacy in WSN is typically categorized into two categories: <italic>data privacy</italic> and <italic>context privacy</italic> [<xref rid="B7-sensors-15-05820" ref-type="bibr">7</xref>,<xref rid="B8-sensors-15-05820" ref-type="bibr">8</xref>,<xref rid="B9-sensors-15-05820" ref-type="bibr">9</xref>,<xref rid="B10-sensors-15-05820" ref-type="bibr">10</xref>]. The data privacy includes <italic>data aggregation</italic> and <italic>data query</italic>. The context privacy includes <italic>routing privacy</italic>, <italic>identity privacy</italic>, <italic>location privacy</italic> and <italic>timing privacy.</italic> In this work, we shall focus on using anonymity to provide <italic>location privacy</italic>, which includes two subcategories, source location privacy and base-station location privacy. One of the first works to classify context privacy was done by Kamat <italic>et al.</italic> [<xref rid="B11-sensors-15-05820" ref-type="bibr">11</xref>,<xref rid="B12-sensors-15-05820" ref-type="bibr">12</xref>], where they addressed the panda hunter game. They claim that the routing scheme is responsible for hiding source location of a subject. They have used two metrics to measure SLP: <italic>Safety period</italic> and <italic>capture likelihood</italic>. Safety period is the number of messages a source sends before it is captured. The capture likelihood is the probability that an adversary can capture the source within a certain period. There are generally two ways to locate a source using passive attacks: <italic>Traffic analysis</italic> [<xref rid="B7-sensors-15-05820" ref-type="bibr">7</xref>,<xref rid="B13-sensors-15-05820" ref-type="bibr">13</xref>] and <italic>packet tracing</italic> [<xref rid="B7-sensors-15-05820" ref-type="bibr">7</xref>,<xref rid="B14-sensors-15-05820" ref-type="bibr">14</xref>,<xref rid="B15-sensors-15-05820" ref-type="bibr">15</xref>]. The traffic analysis can determine the source or sink locations by analyzing the traffic. Packet tracing can also be used to find the source location since adversaries may use radio-frequency localization techniques to perform a hop-by-hop trace. The adversary can move quickly during packet trace. It could be used to trace mobile nodes due to its fast response compared to traffic analysis [<xref rid="B7-sensors-15-05820" ref-type="bibr">7</xref>,<xref rid="B14-sensors-15-05820" ref-type="bibr">14</xref>]. We provide a framework that can be tested against other solutions using the following metrics: (i) <italic>Security</italic>: the probability that the adversary successfully identifies the source, the intermediary SNs or the sink; (ii) <italic>energy cost</italic>; (iii) <italic>storage and memory cost</italic>; (iv) <italic>delivery time</italic>; (v) <italic>safety period</italic>: how long it takes the adversary to capture the first sensor node in the network. Our proposed framework provides a modular system that could be configured for a variety of network models and for a variety of threat models. The rest of this paper is organized as follows: in <xref ref-type="sec" rid="sec3-sensors-15-05820">Section 3</xref>, we give some background and literature survey. In <xref ref-type="sec" rid="sec4-sensors-15-05820">Section 4</xref>, we will explain the suggested system model, network model, threat model and the traffic model. In <xref ref-type="sec" rid="sec5-sensors-15-05820">Section 5</xref>, we will introduce the anonymity module. In <xref ref-type="sec" rid="sec6-sensors-15-05820">Section 6</xref>, we will discuss the module of data authentication and integrity. In <xref ref-type="sec" rid="sec7-sensors-15-05820">Section 7</xref>, we will discuss temporal privacy. In <xref ref-type="sec" rid="sec8-sensors-15-05820">Section 8</xref>, we will have a thorough security analysis. In <xref ref-type="sec" rid="sec9-sensors-15-05820">Section 9</xref>, we will have performance analysis and evaluation. In <xref ref-type="sec" rid="sec10-sensors-15-05820">Section 10</xref>, we will summarize our work and suggest some additional development to the framework in the future work.</p></sec><sec id="sec3-sensors-15-05820"><title>3. Background and Literature Survey</title><p>There are many solutions that have been presented to solve the problems of SLP and BLP. Li <italic>et al.</italic> [<xref rid="B8-sensors-15-05820" ref-type="bibr">8</xref>] discussed some of the solutions for SLP but they did not aim to create a survey. The comprehensive survey for SLP was presented in the work by Conti <italic>et al</italic>. [<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>], where they categorized the solutions into eleven groups. They have discussed many solutions and compared them in terms of power consumption, the attack/threat model, view of the network, exposed information, and efficiency in providing SLP. They also discussed some issues that each solution exhibits. </p><p>Anonymity is an old issue that was discussed for mobile networks, Ad Hoc networks and Internets. Recently, it has become a concern for WSNs. We have identified solutions for location privacy using anonymity in WSN. We have included them chronologically in <xref ref-type="table" rid="sensors-15-05820-t001">Table 1</xref>.</p><p>An important solution against a global adversary introduced by Chen <italic>et al.</italic> [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>] called efficient anonymous communication (EAC) provides sender, link and sink anonymity. We know that anonymity is not enough to achieve fortified end-to-end privacy. There are some solutions based on fake data sources where SNs send out fake packets to other nodes within the network. Some literature call them dummy packets. A fake packet does not contain any real information about any real events but it helps to obfuscate the real traffic and to divert the adversary by mimicking the presence of a fake source. The literature shows reasonable solutions using fake sources. Some of them are designed to handle a local adversary and some of them are suitable for a global adversary. Some of the literature presume a certain routing scheme, topology, network and threat models. Ouyang <italic>et al.</italic> [<xref rid="B17-sensors-15-05820" ref-type="bibr">17</xref>] introduced three different solutions to handle the global adversary problem. The first solution is the globally optimal algorithm (GOA). Each SN has a pseudo random number generator that defines the interval time. The second solution by Ouyang <italic>et al.</italic> [<xref rid="B17-sensors-15-05820" ref-type="bibr">17</xref>], is the heuristic greedy algorithm (HGA) where SNs follow the same procedure as in GOA except that the SN does not know the complete topology, but it only has the information of its location and the seeds of its neighbors. The third solution by Ouyang <italic>et al.</italic> [<xref rid="B17-sensors-15-05820" ref-type="bibr">17</xref>] is the probabilistic algorithm (PBA) where nodes still follow the procedure of HGA, except that they do not send fake messages at the end of every interval. It uses probability <italic>p</italic> to decide whether to send a fake message or not. The value of <italic>p</italic> will reduce the communication overhead at the expense of SLP.</p><p>We can enhance SLP and BLP by having temporal privacy against the hop-by-hop trace attack or timing analysis attack [<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>]. There are some literature addressed this using issuing packet delay techniques. Hong <italic>et al.</italic> [<xref rid="B18-sensors-15-05820" ref-type="bibr">18</xref>] introduced probabilistic reshaping (<italic>PRESH</italic>) to counter the adversary that uses timing analysis techniques and also introduced and upgraded PRESH to be extended probabilistic reshaping (<italic>exPRESH</italic>) to counter such a scenario. The SN will delay the packet in its buffer again up to <italic>D</italic> time. Kamat <italic>et al.</italic> [<xref rid="B19-sensors-15-05820" ref-type="bibr">19</xref>] introduced rate controlled adaptive delaying (<italic>RCAD</italic>).</p><table-wrap id="sensors-15-05820-t001" position="float"><object-id pub-id-type="pii">sensors-15-05820-t001_Table 1</object-id><label>Table 1</label><caption><p>Solutions for location privacy using anonymity [<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>]. SAS, Simple Anonymity Scheme; CAS, Cryptographic Anonymity Scheme; HIR, Hashing-Based ID Randomization; RHIR, Reverse HIR; APR, Anonymous Path Routing; ACS, Anonymous Communications Scheme; DCARPS, Destination Controlled Anonymous Routing Protocol for Sensor Nets; MAQ, Max Query Aggregation; PhID, Phantom ID; EAC, Efficient Anonymous Communication.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">No.</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Scheme</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">View of the Adversary</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Anonymity Technique</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Passive Attacks</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Active Attacks</th></tr></thead><tbody><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">1</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">SAS &#x00026; CAS [<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Global</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, SN compromise, limited traffic analysis</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">-</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">2</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">HIR &#x00026; RHIR [<xref rid="B21-sensors-15-05820" ref-type="bibr">21</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Global</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, SN compromise</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">-</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">3</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">APR [<xref rid="B22-sensors-15-05820" ref-type="bibr">22</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Local</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, hops-tracing</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">SN compromise</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">4</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">DCARPS &#x00026; Global DCARPS [<xref rid="B6-sensors-15-05820" ref-type="bibr">6</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Global</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, hops-tracing</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">-</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">5</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">ACS [<xref rid="B23-sensors-15-05820" ref-type="bibr">23</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Local</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Rate monitoring, time correlation, identity analysis, hops-trace</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">-</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">6</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">MQA [<xref rid="B24-sensors-15-05820" ref-type="bibr">24</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Global</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Aggregation</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, hops-tracing</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Packet injection</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">7</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">PhID [<xref rid="B4-sensors-15-05820" ref-type="bibr">4</xref>,<xref rid="B25-sensors-15-05820" ref-type="bibr">25</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Local</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, traffic analysis</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">-</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">8</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">EAC [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>]</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Global</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Pseudonyms</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Eavesdropping, traffic analysis</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">DoS, SN compromise, Traffic injection</td></tr></tbody></table></table-wrap><p>In this work, we shall enhance EAC, the efficient anonymous communicating protocol [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B26-sensors-15-05820" ref-type="bibr">26</xref>]. An extension to EAC called <italic>Enhanced Communication Protocol for Anonymity and Location Privacy in WSN</italic> (E<sup>2</sup>AC) was presented in [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>]. We will call our scheme FAC, <italic>a fortified anonymous communication protocol for WSN.</italic> EAC does not handle the pseudonyms synchronization very well. There are many situations where the system will get unsynchronized. It also could not handle multi-colluding adversaries and lacks a mechanism for time correlation attack. Most of the other solutions do not handle global or multi-colluding adversaries. Each of the different solutions focus on certain selected attack scenarios. Our work is aimed to be comprehensive. We propose a solution against anonymity attacks, temporal attacks, transmission rate-analysis attacks, and statistical attacks, which altogether will provide a fortified source and sink location privacy.</p></sec><sec id="sec4-sensors-15-05820"><title>4. System, Network, Threat and Traffic Models</title><p>In this work, a framework for end-to-end location privacy using anonymity and temporal privacy is presented. The framework provides the following security elements: Sender anonymity, receiver anonymity, link anonymity, SLP, BLP, data privacy, safety period, and energy preservation. We use sink and BS alternatively throughout this work. The system would be fed with inputs such as the nature of the adversaries in the network, the residual energy in the SNs, the desired lifetime or safety period. We assume bi-directional links where two nodes are considered neighbors if and only if they can hear each other [<xref rid="B6-sensors-15-05820" ref-type="bibr">6</xref>].The network considers one sink, which collects/aggregates sensed data (stimuli) from all the SNs. The sink works as an interface for WSN to the wired network [<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>]. Data packets generated by SNs are ultimately destined uplink to the sink and never destined to another SN. However, it could go through a multi-hop path. Control packets can be sent from the sink, downlink, to the SNs by unicast or by broadcast messages. To enhance BLP, the sink acts like any other SN in the network while communicating with the SNs to make it absolutely indistinguishable. Most of the literature show that the operation of WSN network goes through two or more phases. However, generally speaking, the WSN runs in three phases: <italic>Pre-deployment phase</italic>, <italic>setup phase</italic>, and <italic>communication phase.</italic> We assume that the SNs have the ability to obfuscate the addresses at the MAC level header [<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>,<xref rid="B28-sensors-15-05820" ref-type="bibr">28</xref>]. All sensors are time synchronized using <italic>time synchronization protocol</italic> [<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>].</p><p>The WSN will need a protocol for <italic>network topology discovery</italic> that allows the sink to view the global topology of the network without revealing the location of the sink [<xref rid="B6-sensors-15-05820" ref-type="bibr">6</xref>]. The adversary nodes have very strong capabilities compared to the SNs. They are resource-rich; sufficient energy supply, computation/processing capabilities, and unlimited storage memory. An adversary could run both <italic>passive</italic> and <italic>active</italic> attacks. We presume <italic>Kerchhoff&#x02019;s Principle</italic> [<xref rid="B29-sensors-15-05820" ref-type="bibr">29</xref>] for our framework, where the adversary knows everything about the system except the <italic>keys</italic> and <italic>IDs</italic>. The framework will be able to handle both passive and active attacks. We presume that only few compromised nodes could coexist at one time due to the implementation of intrusion detection system (IDS) [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B30-sensors-15-05820" ref-type="bibr">30</xref>,<xref rid="B31-sensors-15-05820" ref-type="bibr">31</xref>,<xref rid="B32-sensors-15-05820" ref-type="bibr">32</xref>,<xref rid="B33-sensors-15-05820" ref-type="bibr">33</xref>]. We assume a global adversary, which can monitor the traffic of the entire network and can determine the node responsible for the initial transmission, as in <xref ref-type="fig" rid="sensors-15-05820-f001">Figure 1</xref>. </p><fig id="sensors-15-05820-f001" position="float"><label>Figure 1</label><caption><p>The view of adversary in WSN: local, global and multi-local.</p></caption><graphic xlink:href="sensors-15-05820-g001"/></fig><p>Assuming a global adversary means: (a) the worst-case scenario for area coverage where colluding sensors can cooperate to cover the whole network area [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>]; and (b) the worst-case scenario for timing where the coverage area of the adversary is not known to the privacy protocol at any time [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>]. We also assume that the adversary is capable of observing transmissions over extended periods. It is, however, not able to break the encryption algorithms or the hash functions used for securing data during transmission. We presume <italic>abundant</italic> traffic where sensors detect and transmit many packets such as in the applications of environment monitoring. Such networks can resist global eavesdroppers easily comparted to <italic>scarce</italic> traffic networks due to the volume of transmissions that could happen at one time. The framework is built of many blocks of <italic>functions</italic> and <italic>protocol</italic>. We have adopted some of the solutions provided in the literature such as solutions for localization and time synchronization. <xref ref-type="fig" rid="sensors-15-05820-f002">Figure 2</xref> provides a list of all the blocks that we have provided solutions for and the blocks that we have adopted. The BS will be able to control the network by assigning the value of different parameters.</p><fig id="sensors-15-05820-f002" position="float"><label>Figure 2</label><caption><p>Adopted and provided modules for the framework.</p></caption><graphic xlink:href="sensors-15-05820-g002"/></fig></sec><sec id="sec5-sensors-15-05820"><title>5. Module I: Anonymity</title><p>The communication process is divided into three phases, namely: Pre-deployment phase, setup phase and communication phase.</p><sec><title>5.1. Pre-Deployment Phase</title><p>Prior to actual distribution of the SNs in the field of application, the SNs need to be tested, fully charged, and preloaded with some parameters. We will use subcase letters i and j to describe source and intermediary nodes consecutively. We will use <italic>BS</italic> to describe the sink or the base station. <xref ref-type="table" rid="sensors-15-05820-t002">Table 2</xref> summarizes all the parameters and terms used in this work.</p><table-wrap id="sensors-15-05820-t002" position="float"><object-id pub-id-type="pii">sensors-15-05820-t002_Table 2</object-id><label>Table 2</label><caption><p>Reference of important parameters and terms used by FAC.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Notation</th><th align="center" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Definition</th><th align="center" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Source</th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">ID<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">ID of sensor i</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">a<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Random number shared between SN<sub>i</sub> &#x00026; BS</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">b<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Random number shared between SN<sub>i</sub> &#x00026; neighbors</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">c<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Random number shared between SN<sub>i</sub> &#x00026; neighbors</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">H1</td><td align="center" valign="top" rowspan="1" colspan="1">Hash function to create pseudonyms and the keys</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">H</td><td align="center" valign="top" rowspan="1" colspan="1">Hash function to create data digest</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">k<sub>i&#x02194;bs</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Pair-wise key shared between SN<sub>i</sub> &#x00026; BS</td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">kb<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Broadcast key for SN<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">fkb<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Fake broadcast key for SN<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Preloaded</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">N</td><td align="center" valign="top" rowspan="1" colspan="1">Number of SNs in WSN</td><td align="center" valign="top" rowspan="1" colspan="1">Learned</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">N<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Number of neighboring for SN<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">HC<sub>i&#x02194;bs</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Hop-count between SN<sub>i</sub> &#x00026; BS</td><td align="center" valign="top" rowspan="1" colspan="1">Learned</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">PID<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Pseudonym ID shared between SN<sub>i</sub> &#x00026; BS</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">BPID<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Broadcast pseudonym ID</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">a<sub>i&#x02194;j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Random value shared between SN<sub>i</sub> &#x00026; SN<sub>j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">k<sub>i&#x02194;j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Pair-wise key shared between SN<sub>i</sub> &#x00026; SN<sub>j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">OHPID <sub>i&#x02194;j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Pseudonym ID shared between SN<sub>i</sub> &#x00026; SN<sub>j</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">APID<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">ACK pseudonym ID for SN<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">FBPID<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Fake broadcast pseudonym ID</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">T<sub>i</sub></td><td align="center" valign="top" rowspan="1" colspan="1">Table in SN<sub>i</sub> for shared parameters</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">TIME_STAMP</td><td align="center" valign="top" rowspan="1" colspan="1">Time stamp</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">SEQ_NO</td><td align="center" valign="top" rowspan="1" colspan="1">Sequence number for a message</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">TTL</td><td align="center" valign="top" rowspan="1" colspan="1">Time to live</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">MCG_LGTH</td><td align="center" valign="top" rowspan="1" colspan="1">Message size</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">
<inline-formula><mml:math id="mm1"><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>&#x00394;</mml:mi></mml:mstyle><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></inline-formula>
</td><td align="center" valign="top" rowspan="1" colspan="1">Residual energy</td><td align="center" valign="top" rowspan="1" colspan="1">Calculated</td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">&#x02295;</td><td align="center" valign="top" rowspan="1" colspan="1">XOR Operation</td><td align="center" valign="top" rowspan="1" colspan="1">Operation</td></tr><tr><td align="center" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">||</td><td align="center" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">Concatenation operation</td><td align="center" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">Operation</td></tr></tbody></table></table-wrap></sec><sec><title>5.2. Setup Phase</title><p>It is typical to presume the WSN is considered secure for some short period after the deployment of sensors and before the steady communication phase. Zhu <italic>et al.</italic> [<xref rid="B35-sensors-15-05820" ref-type="bibr">35</xref>] presented that WSN has a lower bound on the time interval (T<sub>min</sub>) before the adversary is able to compromise a SN. During this time, the sensors can communicate and exchange all needed information safely. The sink needs to know the location of all the SNs participating in the WSN. Likewise, the SNs need to know their relative locations to the sink and to their neighbors. There are many <italic>localization schemes</italic> which, are proposed in the literature [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>,<xref rid="B36-sensors-15-05820" ref-type="bibr">36</xref>,<xref rid="B37-sensors-15-05820" ref-type="bibr">37</xref>]. We presume the network will adopt one of the available efficient localization schemes. Localization allows each SN to know its smallest <italic>hop-count</italic> to the BS (<italic>HC<sub>i&#x02194;bs</sub></italic>).</p><sec><title>5.2.1. Creating Pseudonyms</title><p>The key idea is to use pseudonyms instead of using real IDs for the SNs and the BS during communication. Therefore, one disposable pseudonym per one transmission is used. This way, the ADV cannot trace back to the source using multiple messages containing the real ID. There are five kinds of transmissions that could happen in the WSN: (i) Multi- hop transmission between SN<sub>i</sub> and BS; (ii) transmission between two sensor neighbors i and j; (iii) broadcast sent by SN<sub>i</sub> or BS; (iv) acknowledgement; and (v) fake broadcast. The process starts by creating a pseudonym ID for each SN<sub>i</sub>, we call it for short (PID<italic><sub>i</sub></italic>) which is computed using Equation (1):
<disp-formula>PID<sub>i</sub> = H<sub>1</sub>(ID<sub>i</sub> &#x02295; a<sub>i</sub>) <label>(1)</label></disp-formula></p><p>The SN<sub>i</sub> can calculate the broadcast pseudonym ID (BPID<sub>i</sub>) according to Equation (2):
<disp-formula>BPID<sub>i</sub> = H<sub>1</sub>(ID<sub>i</sub> &#x02295; b<sub>i</sub>) <label>(2)</label></disp-formula></p><p>The SN<sub>i</sub> can calculate the fake broadcast pseudonym ID (FBPID<sub>i</sub>) according to Equation (3):
<disp-formula>FBPID<sub>i</sub> = H<sub>1</sub>(ID<sub>i</sub> &#x02295; c<sub>i</sub>) <label>(3)</label></disp-formula></p><p>SN<sub>i</sub> should, by now, know its entire neighbor set (N<sub>i</sub>). SN<sub>i</sub> will send a broadcast discovery message (M<sub>discovery</sub>), to exchange parameters with all one-hop neighbors. The format of the message is stated in Equation (4):
<disp-formula>M<sub>discovery</sub> = K<sub>dis</sub>(TTL || ID<sub>i</sub> || k<sub>i&#x02194;bs</sub> || kb<sub>i</sub> || fkb<sub>i</sub> || a<sub>i</sub> || b<sub>i</sub> || c<sub>i</sub> || &#x00394;<sub>i</sub> || HC<sub>i&#x02194;bs</sub>) <label>(4)</label></disp-formula>
where TTL should be 1 for this transmission. K<sub>dis</sub> is a shared common encryption key to secure the discovery message. SN<sub>i</sub> will receive also a similar broadcast message from SN<sub>j</sub> and from all other neighbors. Both SN<sub>i</sub> and SN<sub>j</sub> will calculate a new random value (a<sub>i&#x02194;j</sub>) according to Equation (5):
<disp-formula>a<sub>i&#x02194;j</sub> = H<sub>1</sub>(ID<sub>i</sub> &#x02295; ID<sub>j</sub>) <label>(5)</label></disp-formula></p><p>Both SN<sub>i</sub> and SN<sub>j</sub> will calculate also a new pair-wise key k<sub>i&#x02194;j</sub> according to Equation (6):
<disp-formula>k<sub>i&#x02194;j</sub> = H<sub>1</sub>(k<sub>i&#x02194;bs</sub> &#x02295; k<sub>j&#x02194;bs</sub>) <label>(6)</label></disp-formula></p><p>SN<sub>i</sub> also calculates broadcast pseudonym ID for SN<sub>j</sub> (BPID<sub>j</sub>) according to expression Equation (2) since SN<sub>i</sub> has already received the values of ID<sub>j</sub> and b<sub>j</sub> through M<sub>discovery</sub>. It also calculates the one-hop pseudonym ID (OHPID <sub>i&#x02194;j</sub>) shared between SN<sub>i</sub> and SN<sub>j</sub> as expressed in Equation (7):
<disp-formula>OHPID <sub>i&#x02194;j</sub> = H<sub>1</sub>(a<sub>i</sub> &#x02295; a<sub>j</sub>) <label>(7)</label></disp-formula></p><p>Finally, acknowledgement pseudonym ID for SN<sub>i</sub> (APID<sub>i</sub>) will be calculated according to Equation (8):
<disp-formula>APID<sub>i</sub> =H<sub>1</sub>(ID<sub>i</sub>) <label>(8)</label></disp-formula></p><p>SN<sub>i</sub> will create a table (T<sub>i</sub>) which contains the shared values with the neighbors as listed in <xref ref-type="table" rid="sensors-15-05820-t003">Table 3</xref>. In conclusion, we have replaced the ID with <italic>quintuple pseudonyms</italic> to reference the SN during the communication.</p><table-wrap id="sensors-15-05820-t003" position="float"><object-id pub-id-type="pii">sensors-15-05820-t003_Table 3</object-id><label>Table 3</label><caption><p>Shared values among sensor neighbors. If SN<sub>i</sub> has N<sub>i</sub> neighbors, then T<sub>i</sub> will have N<sub>i</sub> tuples.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Information in T<sub>i</sub> Per Each Neighbor</th><th align="center" valign="top" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Tuple for SN<sub>j</sub></th></tr></thead><tbody><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared random number</td><td align="center" valign="top" rowspan="1" colspan="1">a<sub>i&#x02194;j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared broadcast random number</td><td align="center" valign="top" rowspan="1" colspan="1">b<sub>j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared fake broadcast random number</td><td align="center" valign="top" rowspan="1" colspan="1">c<sub>j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared broadcast key</td><td align="center" valign="top" rowspan="1" colspan="1">BPID<sub>j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared fake broadcast key</td><td align="center" valign="top" rowspan="1" colspan="1">FPID<sub>j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Shared one-hop key</td><td align="center" valign="top" rowspan="1" colspan="1">k<sub>i&#x02194;j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Current one-hop pseudonym ID</td><td align="center" valign="top" rowspan="1" colspan="1">OHPID <sub>i&#x02194;j</sub></td></tr><tr><td align="center" valign="top" rowspan="1" colspan="1">Link direction</td><td align="center" valign="top" rowspan="1" colspan="1">link<sub>i&#x02192;j</sub></td></tr><tr><td align="center" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">Residual energy level</td><td align="center" valign="top" style="border-bottom:solid thin" rowspan="1" colspan="1">&#x00394;<sub>j</sub></td></tr></tbody></table></table-wrap></sec><sec><title>5.2.2. Deleting Security Information</title><p>After storing all required pseudonyms, parameters and keys in T<sub>i</sub>, it would be the time to delete all unnecessary information from SN<sub>i</sub> memory for the purpose of security [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>]. In addition, it will release some memory storage space [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B26-sensors-15-05820" ref-type="bibr">26</xref>]. Most importantly, SN<sub>i</sub> will delete ID<sub>i</sub> and HC<sub>i&#x02194;bs</sub>, which could be critical information for the adversary. In addition, SN<sub>i</sub> shall delete all discovery messages.</p></sec></sec><sec><title>5.3. Communication Phase</title><p>During the communication phase, when sensing and sending data to the BS takes place, there are seven operations that continue until network lifetime ends. These operations are: (i) Sense and send a message to a neighbor; (ii) forward a message hop-by-hop; (iii) broadcast a real message; (iv) acknowledgement; (v) broadcast a fake message; (vi) SN removal; and (vii) SN addition. A SN will have three roles, in terms of data transmission, during the communication phase: (i) Role as a sensor; (ii) as a message forwarder; and (iii) as a broadcaster. In the following sections, we will use SN<sub>i</sub> as a source node and SN<sub>j</sub> as a neighbor to the source.</p><sec><title>5.3.1. Transmission as a Sensor</title><p>When SN<sub>i</sub> senses data, it needs to send a message hop-by-hop to the BS. The SN<sub>i</sub> only recognizes itself by its (PID<sub>i</sub>), and the BS will recognize the source of the message by its PID<sub>i</sub> as well. Thus, the PID<sub>i</sub> of the source needs to be included in the message until the BS receives it. Consequently, the PID of a sensor will be updated after every transmission. The SN<sub>i</sub> needs to select one neighbor from N<sub>i</sub> to forward the message to it. The selection process goes through a probabilistic protocol, which guarantees that SN<sub>i</sub> does not use one neighbor all the time when forwarding its data; first, for routing privacy, and second for increasing the lifetime of the WSN. SN<sub>i</sub> will form the message in the following format:
<disp-formula>M<sub>i&#x02192;j</sub> = OHPID<sub>i&#x02194;j</sub> || E<sub>ki&#x02192;j</sub> (PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>i</sub>)) <label>(9)</label></disp-formula>
where D<sub>i</sub> includes the sensed data. Once SN<sub>i</sub> knows that the message (M<sub>i&#x02192;j</sub>) is delivered to the the neighbor, it needs to dispose of the current pseudonym PID<sub>i</sub> and issue a new one for the next transmission as indicated in Equation (10):
<disp-formula>PID<sub>i</sub> = H<sub>1</sub>(PID<sub>i</sub> &#x02295; a<sub>i</sub>) <label>(10)</label></disp-formula></p><p>In addition, both SN<sub>i</sub> and SN<sub>j</sub> will dispose of the current OHPID<sub>i&#x02192;j</sub> and issue a new one for the next communication between the two neighbors according to Equation (11):
<disp-formula>OHPID<sub>i&#x02192;j</sub> = H<sub>1</sub>(OHPID<sub>i&#x02192;j</sub> &#x02295; a<sub>i&#x02192;j</sub>) <label>(11)</label></disp-formula></p><p>The message (M) will then be reformatted by the recipient SN<sub>j</sub> and again forwarded to the next node, say SN<sub>r</sub>, and so on, until it gets to the BS. If SN<sub>j</sub> was the BS, then the BS uses the shared one-hop key between the sensor and the BS, to decrypt the data and to get the PID<sub>i</sub>, which the BS can use to recognize the source SN<sub>i</sub>. Only at this point of time, BS can update the value of PID<sub>i</sub> of SN<sub>i</sub>. It also reads the data (D<sub>i</sub>) which the BS can decrypt using k<sub>i&#x02194;bs</sub>.</p></sec><sec><title>5.3.2. Transmission as a Forwarder</title><p>When SN<sub>i</sub> sends the message one-hop uplink to the neighbor SN<sub>j</sub>, then SN<sub>j</sub> needs to forward the message to another intermediary node. Upon receiving M<sub>i&#x02192;j</sub>, SN<sub>j</sub> will match OHPID<sub>i&#x02192;j</sub> in its table, T<sub>j</sub>. If there is no match, then the message definitely is not addressed for SN<sub>j</sub> and it will be dropped immediately. If it matches, then the message is decrypted using k<sub>i&#x02192;j</sub>. The message will be forwarded to SN<sub>r</sub> after (M) is reformatted as in Equation (12):
<disp-formula>M<sub>j&#x02192;r</sub> = OHPID<sub>j&#x02194;r</sub> || E<sub>kj&#x02192;r</sub> (PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>i</sub>)) <label>(12)</label></disp-formula></p><p>Right after the data is <italic>received</italic> by SN<sub>j</sub> and <italic>forwarded</italic> to the next one-hop SN<sub>r</sub>, the SN<sub>j</sub> updates the pseudonym OHPID<sub>i&#x02194;j</sub>. SN<sub>j</sub> now is ready to exchange another message with SN<sub>i</sub> using the new pseudonym OHPID<sub>i&#x02194;j</sub>. However, SN<sub>j</sub> is not yet ready to send data to SN<sub>r</sub> since SN<sub>r</sub> does not update the OHPID<sub>j&#x02194;r</sub> until (D<sub>i</sub>) is forwarded to the next hop, say NS<sub>v</sub>. See <xref ref-type="fig" rid="sensors-15-05820-f003">Figure 3</xref> for the sequence of transmissions for a message from SN<sub>i</sub> to the BS.</p><fig id="sensors-15-05820-f003" position="float"><label>Figure 3</label><caption><p>The sequence of a message transmission from SN<sub>i</sub> to the BS. (<bold>a</bold>) SN<sub>j</sub> receives a message from SN<sub>i</sub>; (<bold>b</bold>) SN<sub>j</sub> forwards the message to a neighbor SN<sub>r</sub>; (<bold>c</bold>) BS receives the message and processes it.</p></caption><graphic xlink:href="sensors-15-05820-g003"/></fig></sec><sec><title>5.3.3. Acknowledgement</title><p>As expected in data networks, message could be lost or could be corrupted. In either case, retransmission is required. Because SNs change PIDs after each transmission, synchronizing PIDs is crucial. Updating the pseudonyms depends on successful message delivery. Ideally, the source should update the pseudonyms only after making sure the BS receives the data. However, the lack of direct connection between the source and the BS makes it a bit complicated process.</p><p>The BS cannot send direct acknowledgement to the source if it is multiple hops away. We have to depend on multiple acknowledgements along the path between the source and the BS. SN<sub>i</sub> needs to calculate the Acknowledgement pseudonym ID (APID<sub>i</sub>) according to Equation (13):
<disp-formula>APID<sub>i</sub> = H<sub>1</sub>(APID<sub>i</sub> &#x02295; b<sub>i</sub>) <label>(13)</label></disp-formula></p><p>The message will be sent out to the neighbor with the current value for APID<sub>i</sub>. Thus, we will rewrite M<sub>i&#x02192;j</sub> as it appears in Equation (14):
<disp-formula>M<sub>i&#x02192;j</sub> = Padding || OHPID<sub>i&#x02194;j</sub> || E<sub>ki&#x02192;j</sub> (APID<sub>i</sub> || PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>i</sub>)) <label>(14)</label></disp-formula></p><p>Padding is added to make sure all the one-hop messages have the same size to prevent <italic>size correlation</italic> attacks. When SN<sub>j</sub> receives the message, it will reformat the message as in expression Equation (15) and then send it to SN<sub>r</sub>:
<disp-formula>M<sub>j&#x02192;r</sub> = APID<sub>i</sub> || OHPID<sub>j&#x02194;r</sub> || E<sub>j&#x02192;r</sub> (APID<sub>j</sub> || PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>i</sub>)) <label>(15)</label></disp-formula></p><p>The transmission of M<sub>j&#x02192;r</sub> should be heard by all the neighbors including both SN<sub>i</sub> and SN<sub>r</sub>. If SN<sub>i</sub> hears the message and reads (APID<sub>i</sub>), the SN<sub>i</sub> knows that M<sub>i&#x02192;j</sub> was received correctly by SN<sub>j</sub>. Only at this time, SN<sub>i</sub> updates the value of OHPID<sub>i&#x02194;j</sub>. PID<sub>i</sub> will get updated, as well, since SN<sub>i</sub> is the source of the message. This is exhibited in <xref ref-type="fig" rid="sensors-15-05820-f004">Figure 4</xref>. Here are two scenarios:</p><p><italic>Scenario 1:</italic> The packet sent by SN<sub>i</sub> is lost or got corrupted. In this case, SN<sub>j</sub> considers nothing happened, so it will not forward any message onward. Meanwhile, SN<sub>i</sub> will wait for (<italic>&#x003b6;</italic>) time to expire. It will send the message again with updated APID<sub>i</sub>. Once the message is acknowledged according to the procedure explained earlier, then PID<sub>i</sub>, OHPID<sub>i</sub> and APID<sub>i</sub> will be updated. If it is intermediary SN, only OHPID<sub>i</sub> and APID<sub>i</sub> is updated as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f005">Figure 5</xref>.</p><p><italic>Scenario 2:</italic> SNj receives the packet correctly; the new packet M<sub>j&#x02192;r</sub> is sent out which contains the acknowledgement (APID<sub>i</sub>), and SN<sub>j</sub> updated the value of OHPID<sub>i&#x02194;j</sub>. However, SN<sub>i</sub> does not hear the forwarded message M<sub>j&#x02192;r</sub> within time (<italic>&#x003b6;</italic>). At this moment SN<sub>i</sub> does not know for sure if the message was delivered (<italic>resembles scenario 1</italic>), or the acknowledgement is lost. It has to account for the worst case. A copy of the message will be retransmitted to SN<sub>j</sub> with the current OHPID<sub>i</sub> and updated APID<sub>i</sub>. SN<sub>j</sub> can recognize the message because of the value of old OHPID<sub>i</sub>. After receiving the <italic>retransmitted</italic> message, it now sends a direct acknowledgement to SN<sub>i</sub> as in Equation (16).
<disp-formula>ACK<sub>i&#x02190;j</sub> = APID<sub>i</sub>|| Padding <label>(16)</label></disp-formula></p><fig id="sensors-15-05820-f004" position="float"><label>Figure 4</label><caption><p>Using APID<sub>i</sub> for acknowledgement with no errors.</p></caption><graphic xlink:href="sensors-15-05820-g004"/></fig><fig id="sensors-15-05820-f005" position="float"><label>Figure 5</label><caption><p>Acknowledgement for a message with errors.</p></caption><graphic xlink:href="sensors-15-05820-g005"/></fig><p><xref ref-type="fig" rid="sensors-15-05820-f006">Figure 6</xref> shows the process. BS is treated similar to a normal SN, so it has to acknowledge every message it receives. After the message is delivered to the BS, and after the message is acknowledged, the PID<sub>i</sub> (of the source) will be updated on the BS tables while it has been already updated in the sensor itself after the first acknowledgement.</p><fig id="sensors-15-05820-f006" position="float"><label>Figure 6</label><caption><p>Handling lost acknowledgement.</p></caption><graphic xlink:href="sensors-15-05820-g006"/></fig><p>Both the SN<sub>i</sub> and the BS will be ready to exchange a new message. As long the new message does not reach to the BS before the old PID<sub>i</sub> is updated, the system will remain synchronized. This way, we have a possible window of one message only. We propose implementing a <italic>sliding window</italic> mechanism as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f007">Figure 7</xref> [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>]. For each sensor, we can have a window of (W) slots.</p><fig id="sensors-15-05820-f007" position="float"><label>Figure 7</label><caption><p>Sliding window for received PIDs [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g007"/></fig></sec><sec><title>5.3.4. Transmission as a Broadcaster</title><p>Typically, the BS is required to broadcast a message for control and management purposes. Likewise, a sensor might need to broadcast a message to the BS or to the neighbors for network setup, maintenance and other management issues. The framework requires keeping all the messages indistinguishable throughout the network, so all the messages need to have the same size. Each SN is preloaded with a broadcast key (kb<sub>i</sub>) and assigned broadcast pseudonym (BPID<sub>i</sub>). The broadcast message sent by SN<sub>i</sub> is formatted as in Equation (17):
<disp-formula>M<sub>b</sub> = Padding || BPID<sub>i</sub> || E<sub>kbi</sub>(D<sub>b</sub>) <label>(17)</label></disp-formula></p><p>All the neighbors will receive the broadcast message from a source SNi. SN<sub>i</sub> and the recipients will update BPID<sub>i</sub> according to Equation (18).
<disp-formula>BPID<sub>i</sub> = H<sub>1</sub>(BPID<sub>i</sub> &#x02295; b<sub>i</sub>) <label>(18)</label></disp-formula></p><p>Upon receiving the broadcast message (M<sub>b</sub>), SN<sub>j</sub> decrypts the message using (kb<sub>i</sub>) stored in the table (T<sub>j</sub>). It then encrypts it again using (kb<sub>j</sub>) and broadcasts (M<sub>b</sub>) to its one-hop neighbors set (N<sub>j</sub>) as in Equation (19):
<disp-formula>M<sub>b</sub> = BPID<sub>i</sub> || BPID<sub>j</sub> || Ekb<sub>j</sub>(D<sub>b</sub>) <label>(19)</label></disp-formula></p><p>When the BS receives a broadcast message, it is ultimately the destination, so intuitively it does not need to broadcast the message again. Our proposed framework assumes that the BS behaves similar to a normal sensor. To maintain this pre-course, we require the BS to broadcast the message again for acknowledgement purpose. Thus, we introduce the limited broadcast where the BS will be able to broadcast to only one hop (TTL = 1).</p></sec><sec><title>5.3.5. Limited Broadcast Messages</title><p>A sensor inside network maze can only recognize the neighboring sensors and the BS. When SN broadcasts a message uplink (towards the BS), then all neighbors should hear it. The neighbor should broadcast the message again if and only if the message comes from a SN with a bigger hop-count (HC). This will conserve a lot of unnecessary traffic and energy dissipation. The broadcast message will contain (TTL = HC). The value will keep decreasing by one until it gets to the BS. In contrast, the downlink broadcast messages (by the BS to the SNs) should have (TTL = 0) where the intermediary sensors would rebroadcast the message if and only if it comes from a neighbor with a smaller (HC). A special case when (TTL = 1) where the message will be broadcasted to one-hop neighbors only. FAC also may adopted a more sophisticated optimized flooding algorithm for wireless multi-hop network, such as CDS-based algorithms [<xref rid="B38-sensors-15-05820" ref-type="bibr">38</xref>,<xref rid="B39-sensors-15-05820" ref-type="bibr">39</xref>].</p></sec><sec><title>5.3.6. Fake Broadcast Message</title><p>The sensors need to send fake messages to prevent <italic>time correlation</italic>, <italic>rate analysis</italic> and <italic>statistical analysis</italic>. A fake message is technically a one-hop broadcast message. However, to prevent correlation, the message needs to behave similar to real messages. Therefore, the message needs to be encrypted and have similar size as the real message to make it completely <italic>indistinguishable</italic>. Since it has to carry a dummy data, it will contain the <italic>residual energy</italic> (&#x00394;) of the issuing sensor. This information will be extracted by the recipient neighbors and saved in the related tuple in the table (T). The fake broadcast message sent by SN<sub>i</sub> is as in Equation (20):
<disp-formula>M<sub>f</sub> = Padding || FPID<sub>i</sub> || E<sub>kfi</sub>(&#x00394;<sub>i</sub>) <label>(20)</label></disp-formula></p><p>All the neighbors will receive the fake broadcast message from SNi. SN<sub>i</sub> and the recipients will then update FPID<sub>i</sub> according to Equation (21):
<disp-formula>FPID<sub>i</sub> = H<sub>1</sub>(FPID<sub>i</sub> &#x02295; c<sub>i</sub>) <label>(21)</label></disp-formula></p><p>There is no need to worry about the pseudonyms synchronization since the main purpose of the fake messages is to show activity in idle sensors to obfuscate real messages.</p></sec></sec><sec><title>5.4. SN Removal</title><p>There are many reasons why a sensor should be removed from WSN. For instance, when the battery of a sensor is about to deplete, it should refrain from participation. This would protect against data loss and maintain the pseudonyms synchronized. In some other cases, WSN use IDS [<xref rid="B40-sensors-15-05820" ref-type="bibr">40</xref>,<xref rid="B41-sensors-15-05820" ref-type="bibr">41</xref>] to protect against active attacks, so once a sensor is captured, it must be banished from the network. Procedurally, if SN<sub>i</sub> opts to be removed, it will send a message to the BS as in Equation (22):
<disp-formula>M<sub>i&#x02192;j</sub> = OHPID<sub>i&#x02194;j</sub> || E<sub>ki&#x02192;j</sub> (PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>remove</sub>)) <label>(22)</label></disp-formula>
where (D<sub>remove</sub>) is a command to banish the sensor. The tuple of the SN<sub>i</sub> in the BS tables will be disabled permanently. In addition, SN<sub>i</sub> will send a broadcast message to the neighbors as in Equation (23):
<disp-formula>M<sub>b</sub> = Padding || BPID<sub>i</sub> || E<sub>kbi</sub>(D<sub>remove</sub>) <label>(23)</label></disp-formula></p><p>Once the neighbors get the message (D<sub>remove</sub>), they will delete the tuple related to SN<sub>i</sub> from the table (T) and banish the sensor. The BS for sensor removal could use the same process.</p></sec><sec><title>5.5. SN Addition</title><p>To add a new sensor to the network, the sensor will be preloaded with the required parameters: ID<sub>i</sub>, a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>, H1, k<sub>i&#x02194;bs</sub> and kb<sub>i</sub>, and fkb<sub>i</sub>. Right after deployment, the sensor calculates the shared parameters with its neighbors. The BS should be trusted to run the process. The BS will send special key (<italic>k<sub>add</sub></italic>) to all the neighbors. SN<sub>i</sub> will be preloaded with the same key as well. SN<sub>i</sub> and the neighbors will use this special key to authenticate with each other. Initially, the BS sends the following message to the one-hop neighbors of the new sensor as in Equation (24):
<disp-formula>M<sub>b</sub> = Padding || BPID<sub>bs</sub> || E<sub>kb-bs</sub>(D<sub>add</sub>) <label>(24)</label></disp-formula>
where (D<sub>add</sub>) is expressed in Equation (25):
<disp-formula>D<sub>add</sub> = hc || k<sub>add</sub><label>(25)</label></disp-formula></p><p>The initial value for hc is <italic>zero</italic>. It will be incremented every time the message is forwarded.</p></sec><sec><title>5.6. Contribution of Anonymity Module</title><p>Other works have provided anonymity using pseudonyms and aggregation to provide SN anonymity while very few provided BS anonymity. Our anonymity module has contributed with an innovative approach by using 100% anonymous communication. We have provided to have anonymous real, fake, acknowledgment, unicast and broadcast message transmission. Moreover, we have provided anonymous transmission for the BS by providing limited onion encryption. Compromising a SN in some other works would lead to the discovery of the pseudonyms, which are, related the SN, which could help the adversary to carry further attacks. In our module, capturing a SN will not lead to pseudonyms&#x02019; leakage. The module will fight against local, multi-local and global adversary. Although, some solutions claimed fighting global anonymity, keeping the pseudonyms synchronized was not possible. We have provided a complete mechanism for synchronization, secure sensor addition and removal. The module will fight both passive and active attacks. A complete anonymity and security analysis is be provided in <xref ref-type="sec" rid="sec8-sensors-15-05820">Section 8</xref>. <xref ref-type="sec" rid="sec9-sensors-15-05820">Section 9</xref>, explains how the solution remains light compared to the other works.</p></sec></sec><sec id="sec6-sensors-15-05820"><title>6. Module II: Data Authentication and Integrity</title><p>The data is encrypted before transmission to protect against passive attacks such as eavesdropping. For active attacks, such as data and transaction falsification, message authentication is required. The two important security aspects to achieve: (i) Verify that the content of the message is not altered and; (ii) the source is authentic. We could achieve authentication by either using a message authentication code (<italic>MAC</italic>), or one-way hash function (<italic>OWH</italic>). MAC would require the sender (SN<sub>i</sub>) and receiver (BS) to share a secret key. The authentication code is calculated as <italic>MAC = F (k, D)</italic>. <italic>DES</italic> or other algorithms can be used to generate the code. The OWH also accepts a variable size message (<italic>D</italic>) as input and produces a fixed sized digest <italic>MD = H (D)</italic> as output. Examples for OWH are <italic>SHA</italic>, <italic>MD5</italic>, <italic>Whirlpool and</italic> HMAC. The advantage of OWH over MAC is the fact that it does not use encryption, which is quite slow. Comes in the middle, HMAC which is a MAC derived from OWH such as <italic>SHA-1</italic>. It could be expressed as: MD <italic>=</italic> HMAC (K, D).</p><p>If we opt to use HMAC as an example, the (M<sub>i&#x02192;j</sub>) will be rewritten as in Equation (26):
<disp-formula>M<sub>i&#x02192;j</sub> = APID<sub>i</sub> || OHPID<sub>i&#x02194;j</sub> || E<sub>ki&#x02192;j</sub> (APID<sub>i</sub> || PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (Di)) || <bold>HMAC<sub>ki&#x02194;bs</sub></bold> (<bold>PID<sub>i</sub></bold> || <bold>D<sub>i</sub></bold>) <label>(26)</label></disp-formula></p><p>The key (k<sub>i&#x02194;bs</sub>) is shared between SN<sub>i</sub> and the BS. The message could be authenticated with MD using OWH as in Equation (27):
<disp-formula>M<sub>i&#x02192;j</sub> = APID<sub>i</sub> || OHPID<sub>i&#x02194;j</sub> || E<sub>ki&#x02192;j</sub> (APID<sub>i</sub> || PID<sub>i</sub> || E<sub>ki&#x02194;bs</sub> (D<sub>i</sub>) || <bold>H(PID<sub>i</sub></bold> || <bold>E<sub>ki&#x02194;bs</sub></bold> (<bold>D<sub>i</sub></bold>))) <label>(27)</label></disp-formula></p><p>As it is transparent from expression Equation (27), we need more processing time and therefore more power consumption because we have encrypted a sizable packet. There is a tradeoff between higher security and energy conservation. The first approach is more appropriate. Authentication for the broadcast messages is done as in Equation (28):
<disp-formula>M<sub>b</sub> = Padding || BPID<sub>i</sub> || E<sub>kbi</sub>(D<sub>b</sub>) || HMAC<sub>kbi</sub>(D<sub>b</sub>)) <label>(28)</label></disp-formula></p><p>Alternatively, it can be achieved using Equation (29):
<disp-formula>M<sub>b</sub> = Padding || BPID<sub>i</sub> || E<sub>kbi</sub>(D<sub>b</sub> || H(kb<sub>i</sub> || D<sub>b</sub>)) <label>(29)</label></disp-formula></p><p>The message could contain other important information such as <italic>sequence number</italic> (similar to the well-known <italic>HDLC</italic> and <italic>TCP</italic> protocols) and <italic>time stamp</italic>. The receiver uses the sequence number to verify the order of messages. Time stamp is used to check the delay threshold. Both checks will enhance protection against various active attacks. The message core data (D<sub>i</sub>) could have the following format:
<disp-formula>D<sub>i</sub> = SEQ_NO || TIME_STAMP || MSG_LGTH || SENSED_DATA <label>(30)</label></disp-formula></p><p>Providing authentication to protect against active attacks is crucial in any communication. The innovation of our authentication module is by providing message authentication for every transmission in the network without limiting it to real messages unlike many other works proposed. The adversary can utilize any captured transmission to launch attacks against the network, which could include real, fake and acknowledgement messages. Our module can use MAC, OWHF and HMAC according to the security needs of the WSN. The network can adjust the parameters according to the security situation using adaptive framework. Integrating the authentication module with the anonymity module without hindering the performance of either one is a necessity, which we have achieved in this work.</p></sec><sec id="sec7-sensors-15-05820"><title>7. Module III: Temporal Privacy</title><p>WSN could suffer from time correlation attacks [<xref rid="B11-sensors-15-05820" ref-type="bibr">11</xref>,<xref rid="B13-sensors-15-05820" ref-type="bibr">13</xref>,<xref rid="B14-sensors-15-05820" ref-type="bibr">14</xref>,<xref rid="B23-sensors-15-05820" ref-type="bibr">23</xref>,<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>] by observing the time between correlative packets sent and received in a certain neighborhood. The adversary can trace forward and backward the messages until they reach to the BS or to the source. Hence, hiding temporal information is crucial for both anonymity and location privacy. Using routing schemes to protect against time correlation attacks is found to be efficient to certain extent where local adversary usually has limited mobility and partial view of the network traffic. However, routing based schemes do not work for global adversary where the traffic of the whole network can be easily monitored with a full spatial view and the adversaries can collude together to promptly detect the origin and time information of the event [<xref rid="B18-sensors-15-05820" ref-type="bibr">18</xref>,<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>]. A mechanism is required to divert attention of the adversary when there is event-driven transmissions, especially with the presence of global adversary [<xref rid="B43-sensors-15-05820" ref-type="bibr">43</xref>]. <xref ref-type="fig" rid="sensors-15-05820-f008">Figure 8</xref> exhibits a probabilistic distribution for the fake messages.</p><fig id="sensors-15-05820-f008" position="float"><label>Figure 8</label><caption><p>Nodes transmit fake messages according to a probabilistic distribution. When real messages are sent, the system should maintain the required distribution by delaying some fake messages [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>,<xref rid="B44-sensors-15-05820" ref-type="bibr">44</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g008"/></fig><p>The distribution of events changes which could be a reason for the adversary to detect the event timing and thereafter the source of the event. The message distribution (both real and fake) needs to be adjusted to prevent time correlation. In some applications, such as monitoring and surveillance, we cannot guarantee a certain event distribution. The literature talk about three ways to maintain an obfuscated message distribution: (i) By issuing message delays; and (ii) by issuing fake messages; and (ii) by using both delays and fake messages. Using delays works well against local adversary but might not be suitable for time sensitive networks. In contrast, using fake messages is required to protect against multi-local and global adversary, however, it is very expensive in terms of energy dissipation. Furthermore, adversary with good statistical analysis can easily detect the message distribution if the scheme is not designed carefully [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>]. Some work in the literature clearly differentiates between two terms: the <italic>event</italic> (of transmission) and the <italic>interval</italic> (of transmission). If every interval has only one transmission, then event and interval are the same, however, this might not be the case when we have multiple transmissions during one interval. So, the anonymity level depends on the capability of the adversary to distinguish between real and fake transmissions. This means, given multiple transmissions by a SN, the adversary must be unable to distinguish, with significant confidence, between transmissions carry real data and transmissions carry fake data. Alomair <italic>et al.</italic> [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>] suggested that transmission &#x0201c;indistinguishability&#x0201d; is not enough. They claim that indistinguishability is achieved when adversary monitoring the network over multiple time intervals, in which some intervals contain real event transmissions and others do not, is unable to determine, with significant confidence, which of the intervals contain the real traffic. If intervals are indistinguishable, the individual transmissions within the interval should also be indistinguishable.</p><p>We should have a mechanism to quantify anonymity while it is used, in the literature, in different ways. However, in our work, anonymity means how to prevent the adversary from knowing the source of the message. In other words, the adversary could know that a particular sensor sent a message at one time, but it should not know that sensor is the source of the message. By delaying the real messages and by issuing multiple messages at one interval would mislead the adversary. As an example, for one transmission and one adversary, where the adversary can guess either the message is real or fake without any anonymity measurement taken, it should be 0.5 (either fake or real). Let us presume &#x00471; donates one adversary strategy for breaching the anonymity of the system among a set of strategies. Let us presume P<sub>r</sub> is the probability that the adversary succeeds using strategy&#x003c8;. The anonymity A as defined in [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>] with the existence of a strategy&#x003c8;, is presented in Equation (31):
<disp-formula>A<sub>&#x003c8;</sub>: = 1 &#x02013; P<sub>r</sub>, where 0 &#x02264; P<sub>r</sub> &#x02264; 1 <label>(31)</label></disp-formula></p><p>If we presume that &#x003a3; represents all possible strategies for the adversary to breach the anonymity of the WSN, the accumulated anonymity will be as in Equation (32):
<disp-formula>A: = min (A<sub>&#x003c8;</sub>), where &#x003c8; &#x02208; &#x003a3; <label>(32)</label></disp-formula></p><p>It is very important to increase anonymity for every individual SN in the network especially with the presence of multi-local or global adversaries. Presence of colluding adversaries could cause the anonymity to drop exponentially [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>]. Take <xref ref-type="fig" rid="sensors-15-05820-f009">Figure 9</xref> as an example, where WSN has a moving Panda from point &#x0201c;a&#x0201d;, to &#x0201c;b&#x0201d;, to &#x0201c;c&#x0201d;, then finally to &#x0201c;d&#x0201d; where each location has a SN to report the Panda&#x02019;s movement. If the anonymity of each sensor is A = 0.8, then the anonymity at node &#x0201c;b&#x0201d; is A = 0.8<sup>2</sup> = 0.64 and at point &#x0201c;d&#x0201d; is A = 0.8<sup>4</sup> = 0.41. Having global adversary makes it super necessary to design a strong anonymity model which can resist the time correlation attack [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>].</p><p>In this work, we assume the worst case for time correlation attacks which is a global or laptop-class adversary attacks [<xref rid="B17-sensors-15-05820" ref-type="bibr">17</xref>]. Having an anonymity scheme to protect against the global adversary will be very expensive solution in terms of energy preservation and thus the lifetime of the network. In the following two subsections, we propose two schemes, the simple global anti temporal (SGAT) and the energy controlled anti temporal (ECAT).</p><fig id="sensors-15-05820-f009" position="float"><label>Figure 9</label><caption><p>Having multiple colluding nodes will reduce system anonymity exponentially [<xref rid="B34-sensors-15-05820" ref-type="bibr">34</xref>,<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>,<xref rid="B44-sensors-15-05820" ref-type="bibr">44</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g009"/></fig><sec><title>7.1. Simple Global Anti Temporal Scheme (SGAT)</title><p>When an event-driven message is sent out, the adversary can trace back the message to the SN or forward to the BS. Sending few other transmissions in the network within the range of the adversary confuses it and prevents the adversary from having known path to follow. In this work, we presume the lifetime of the network (&#x003a9;) is divided into a number of intervals (<italic>I</italic>) and each interval time is (&#x003c9;), where:
<disp-formula>&#x003a9; = I &#x000d7; &#x003c9;<sub><italic>i</italic></sub><label>(33)</label></disp-formula></p><p>The value of &#x003a9; can be predicted as a range between a minimum value (worst case) &#x003a9;<italic><sub>min</sub></italic> and a maximum value (best case) &#x003a9;<italic><sub>max</sub></italic>. It all depends on how real/fake transmissions are facilitated. The SNs will send either a fake or a real message during one interval. The message is sent at the end of each interval or it is adjusted to be sent during the interval to create some variable delays through the route to the BS, which would confuse the adversary more and would prevent it from gaining useful knowledge about the network based on time correlation. SN<sub>i</sub> that has sensed the event or received the real data from another SN<sub>j</sub>, will send the real message (<italic>M<sub>r</sub></italic>) through a hop-by-hop path to the BS, and some other nodes will send fake messages (<italic>M<sub>f</sub></italic>) during the same time to disrupt the adversary. There are two questions: <italic>How long the message will be held in the SN after it is sensed?</italic> Simplistically, M<sub>r</sub> and M<sub>f</sub> are sent at the end of the interval <italic>I</italic>. The time from arrival of the data to the end of the period time (&#x003c4;<sub>w</sub>) expressed in Equation (34):
<disp-formula>&#x003c4;<sub>w</sub> = &#x003c9;<sub>i</sub> &#x02212; t<sub>a</sub> where: t<sub>0</sub> &#x02264; t<sub>a</sub> &#x02264; t<sub>s</sub> &#x02264; &#x003c9;<sub>i</sub><label>(34)</label></disp-formula>
where: t<sub>0</sub> is the beginning of the interval I<sub>i</sub>, t<sub>a</sub> is the arrival time, t<sub>0 &#x02264;</sub> t<sub>a</sub>.</p><p>Ideally, the message will be sent immediately after it is sensed or received which makes &#x003c4;<sub>w</sub> = 0. Theoretically, &#x003c4;<sub>w</sub> could be a value: 0 &#x02264; &#x003c4; <sub>w</sub> &#x02264;&#x003c9;<sub>i</sub> as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f010">Figure 10</xref>.</p><p><italic>How many SNs in the network will send fake message during one interval time and which ones?</italic> Simplistically, every SN in the network, which is in the range of the adversary and in the range of source SN, should send a fake message while SNs that have real messages will send the real messages only.</p><fig id="sensors-15-05820-f010" position="float"><label>Figure 10</label><caption><p>Timing for receiving a real message and then sending it out during the interval period assigned to the sensor node. The total delay will include the processing time, transmission time and the withhold time [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g010"/></fig><p>There are many technical issues regarding the determination of the optimal configuration for both questions mentioned earlier. For instance, it is not possible for the neighboring nodes to know in advance when a SN is going to sense an event. It is a completely unpredictable random-distribution for the events. The need to transmit fake messages becomes even much more crucial if we do not have busy-network. Therefore, all SNs with no real messages need to send fake messages during the interval <italic>I<sub>i</sub></italic>, in the worst case, or only selected nodes according to a probabilistic protocol. Having high number of fake message transmissions will reduce the lifetime of the network in favor of privacy. Doing the reverse will jeopardize the privacy of the sensor nodes. The adversary could learn the mechanism of sending real and fake messages at the end of the interval. However, it is not very dangerous if the network sends enough fake messages at the same time. Having variable withhold time (<italic>&#x003c4;<sub>w</sub></italic>) is useful for privacy and for reducing the average network delay. The delivery time (<italic>&#x003c4;<sub>d</sub></italic>) presuming that the message is always sent at the end of the interval <italic>I<sub>i</sub></italic> is:
<disp-formula>&#x003c4;<sub>d</sub> = &#x003c4;<sub>w</sub> + &#x003c4;<sub>trans</sub> + &#x003c4;<sub>proc</sub><label>(35)</label></disp-formula>
where: &#x003c4;<sub>d</sub> is delivery time, &#x003c4;<sub>trans</sub> is transmission time, &#x003c4;<sub>proc</sub> is processing time.</p><p>If we presume &#x003c4; <sub>proc</sub> is much smaller than &#x003c4;<sub>trans</sub>, then &#x003c4;<sub>d</sub> can be rewritten as the following:
<disp-formula>&#x003c4;<sub>d</sub> = &#x003c4;<sub>w</sub> + &#x003c4;<sub>trans</sub><label>(36)</label></disp-formula></p><p>If the message needs to go through (<italic>U</italic>) hops to the BS, and if we assume that the transmission only happens at the end of the Interval <italic>I<sub>i</sub></italic>, then <italic>t<sub>s</sub></italic>, equals to <italic>&#x003c9;<sub>i</sub></italic>, and the total delivery time (<italic>&#x003c4;<sub>d-total</sub></italic>) can be calculated according to the expression below [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>]:
<disp-formula id="FD1"><label>(37)</label><mml:math id="mm2"><mml:mrow><mml:msub><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>&#x003c4;</mml:mi></mml:mstyle><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>U</mml:mi></mml:munderover><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p>Having <italic>t<sub>s</sub></italic> equals to <italic>&#x003c9;<sub>i</sub></italic>; <italic>i.e.</italic>, sending message at the end of the interval, will increase the delay of the delivery presuming that every <italic>&#x003c4;<sub>trans</sub></italic> is equal [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>]. Thus, optimizing <italic>&#x003c4;<sub>d-total</sub></italic> is a function of <italic>&#x003c4;<sub>w</sub></italic> according to Equation (38):
<disp-formula id="FD2"><label>(38)</label><mml:math id="mm3"><mml:mrow><mml:msub><mml:mtext>&#x003c4;</mml:mtext><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mtext>f</mml:mtext><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mi>w</mml:mi></mml:msub><mml:mo stretchy="false">)</mml:mo><mml:mo>=</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:munderover><mml:mstyle mathsize="140%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mi>u</mml:mi><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mi>U</mml:mi></mml:munderover><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p>Each SN will be informed during the setup phase about &#x003c9;<italic><sub>i</sub></italic> for the lifetime of the network. The BS also can alter this value by broadcast when the conditions of the WSN changes (closed-loop control). The value of &#x003c9;<sub>i</sub> should be calculated to achieve at least the minimum expected lifetime span &#x003a9;<sub>min</sub> without jeopardizing the privacy and data integrity. Thus:
<disp-formula>&#x003a9;<sub>high-th</sub> &#x02265; &#x003a9;<sub>i</sub> &#x02265; &#x003a9;<sub>low-th</sub><label>(39)</label></disp-formula>
where &#x003a9;<sub>high-th</sub> is the highest possible value for &#x003a9;<sub>i</sub> and, &#x003a9;<sub>low-th</sub> is the lowest expected value for &#x003a9;<sub>i</sub>. When SN does not have a real message to send before the end of the interval period <italic>I<sub>i</sub></italic>, it will send a fake message according to the procedure explained in the anonymity module. When SN has a real message, it will send it to one node from the neighborhood set (N<sub>i</sub>).</p><sec><title>7.1.1. Security Analysis</title><p>The adversary sees every SN sending a message at a fixed data rate at any one time. It also cannot distinguish any message from the rest of the messages in the network since none has similar ID. If we have N nodes in the WSN, the probability that one adversary can locate the sending node is:
<disp-formula id="FD3"><label>(40)</label><mml:math id="mm4"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>We can calculate anonymity as:
<disp-formula id="FD4"><label>(41)</label><mml:math id="mm5"><mml:mrow><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mi>A</mml:mi></mml:mstyle><mml:mo>=</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:mn>1</mml:mn></mml:mstyle><mml:mo>&#x02212;</mml:mo><mml:mstyle mathvariant="bold" mathsize="normal"><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mstyle></mml:mrow></mml:math></disp-formula></p></sec><sec><title>7.1.2. Delivery Time</title><p>Message follows hop-by-hop path until it gets to the BS as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f011">Figure 11</xref>. In this scheme, the message waits until the end of the interval. The delay will be calculated according to the expression below [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>]:
<disp-formula id="FD5"><label>(42)</label><mml:math id="mm6"><mml:mrow><mml:msub><mml:mtext>&#x003c4;</mml:mtext><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#x02212;</mml:mo><mml:mi>t</mml:mi><mml:mi>o</mml:mi><mml:mi>t</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mrow><mml:msub><mml:mi>w</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:mrow></mml:msub><mml:mo>+</mml:mo><mml:mo stretchy="false">(</mml:mo><mml:mtext>HC</mml:mtext><mml:mo>&#x02212;</mml:mo><mml:mn>1</mml:mn><mml:mo stretchy="false">)</mml:mo><mml:mtext>*</mml:mtext><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>+</mml:mo><mml:msub><mml:mi>&#x003c4;</mml:mi><mml:mrow><mml:mi>t</mml:mi><mml:mi>r</mml:mi><mml:mi>a</mml:mi><mml:mi>n</mml:mi><mml:msub><mml:mi>s</mml:mi><mml:mi>u</mml:mi></mml:msub></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p>It axiomatic that most delay accumulates from holding the message until the end of the interval periods.</p><fig id="sensors-15-05820-f011" position="float"><label>Figure 11</label><caption><p>Total delay required to send a message from source to the BS through (<italic>U</italic>) hopes [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g011"/></fig></sec><sec><title>7.1.3. Energy Cost</title><p>We presume in this scheme that every node would send one message at the end of each interval. The message could be either real or fake. If we have (N) nodes in the WSN, then we expect (N) messages during each interval <italic>I<sub>i</sub></italic>. The energy spent for transmission is almost constant since we have fixed size messages. However, we can evaluate how expensive it would be to use fake messages for privacy enhancement. If we have (Q) percent of the nodes send real messages at each interval, then we are wasting (1-Q) percent of the energy and of the bandwidth.</p><p>We can adjust the amount of energy consumed by increasing the interval period &#x003c9;<sub>i.</sub> However, increasing &#x003c9;<sub>i</sub>, would increase the delays. If a SN receives multiple messages in one interval, then it will <italic>queue</italic> the messages for transmission. Because the SN needs to wait until the end of the interval, it could arrange the messages in a queue and send them randomly at the end of interval. This should also increase the privacy and security of the data. It could also select a different forward node for each message. In conclusion, SGAT is energy-expensive due to sending fake/real messages by every node per each interval of time. However, SGAT provides the maximum message <italic>entropy</italic>. <xref ref-type="fig" rid="sensors-15-05820-f012">Figure 12</xref> exhibits the network transmissions for two consecutive intervals.</p><fig id="sensors-15-05820-f012" position="float"><label>Figure 12</label><caption><p>Anonymity with fake messages. (<bold>a</bold>) Sensors sense events and send real messages while the rest send fake messages. With Fake MSG&#x02019;s: <inline-formula><mml:math id="mm27"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>N</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>48</mml:mn></mml:mfrac><mml:mo>=</mml:mo><mml:mn>2</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>, Without Fake MSG&#x02019;s: <inline-formula><mml:math id="mm28"><mml:mrow><mml:msub><mml:mi>P</mml:mi><mml:mi>r</mml:mi></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mi>n</mml:mi></mml:mfrac><mml:mo>=</mml:mo><mml:mfrac><mml:mn>1</mml:mn><mml:mn>11</mml:mn></mml:mfrac><mml:mo>=</mml:mo><mml:mn>9</mml:mn><mml:mo>%</mml:mo></mml:mrow></mml:math></inline-formula>; (<bold>b</bold>) Sensors send or forward real messages will not send fake messages. The more the network gets busy the less fake messages are transmitted.</p></caption><graphic xlink:href="sensors-15-05820-g012"/></fig></sec></sec><sec><title>7.2. Energy Controlled Anti Temporal Scheme (ECAT)</title><p>There are three major drawbacks in <italic>SGAT</italic>: (i) Having fixed interval time &#x003c9;<sub>i</sub> while it is possible to adjust the value for a better traffic and energy control; (ii) not considering the residual energy as a metric for selecting the forward hop; (iii) high rate of traffic due to fake messages.</p><sec><title>7.2.1. Changing &#x003c9;<sub>i</sub> from Fixed to Variable</title><p>Having a fixed interval time, &#x003c9;<sub>i</sub> could be a glitch for network performance. If &#x003c9;<sub>i</sub> is set to be a large value, then the delay will be high which could be a serious problem in some time sensitive applications. If &#x003c9;<sub>i</sub> is set to be a small value, then a huge amount of fake messages will be sent at the end of each interval, which will reduce the lifetime of SNs and accordingly the lifetime of the WSN. We propose that we have variable &#x003c9;<sub>i</sub> as presented in [<xref rid="B17-sensors-15-05820" ref-type="bibr">17</xref>]. Every node will be calculating its &#x003c9;<sub>i</sub> using a pseudo-random number generator (PRNG). We suggest a uniform distribution algorithm such as multiplicative congruential algorithm [<xref rid="B45-sensors-15-05820" ref-type="bibr">45</xref>,<xref rid="B46-sensors-15-05820" ref-type="bibr">46</xref>], which is the basis for many of the random number generators in use today. Lehmer&#x02019;s generators [<xref rid="B47-sensors-15-05820" ref-type="bibr">47</xref>] involve three integer parameters, <italic>r</italic>, <italic>s</italic>, and <italic>m</italic>, and an initial value, <italic>x<sub>0</sub></italic>, called the seed. A sequence is generated by the following modified formula:
<disp-formula>X<sub>k+1</sub> = b &#x000d7; ((r&#x000b7;X<sub>k</sub> + s) mod m + f) <label>(43)</label></disp-formula></p><p>The result of the modified PRNG will be a sequence of integer values between (b &#x000d7; f) and (b &#x000d7; (m + f &#x02212; 1)). Each SN needs to be preloaded with the seed &#x000d7;0, r, s, m, b and f values. The seed range is 0 to (m &#x02212; 1) and it is uniformly assigned to the sensor nodes. If b = 2, f = 1 and m = 4 then sequence of four intervals will be: &#x003c9;<sub>i</sub> &#x003f5; [2,4,6,8] time-units as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f013">Figure 13</xref>. We could have up to (m!) different sequences that are uniformly distributed on the SNs. For instance, we can have Equation (24) different sequences for our example and if we have Equation (48) nodes in the network, so each sequence should be provided to two nodes only.</p><fig id="sensors-15-05820-f013" position="float"><label>Figure 13</label><caption><p>The generation of the sequence of intervals assigned for each sensor. The sequence keeps repeating for the sensor. Fake messages transmitted only at the end of the interval. However, real message could be transmitted at any subinterval.</p></caption><graphic xlink:href="sensors-15-05820-g013"/></fig><p>Each node will be dynamically assigned an interval value, which needs to change after each transmission. Taking the example above, the first <inline-formula><mml:math id="mm7"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>m</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> th (more or less) of the sensors will send data after 2 time-units. Then, the second <inline-formula><mml:math id="mm8"><mml:mrow><mml:mfrac><mml:mn>1</mml:mn><mml:mi>m</mml:mi></mml:mfrac></mml:mrow></mml:math></inline-formula> th will transmit after 4 time-units, and so on. At any point of time, the adversary will be faced by enough transmissions in the network that it could divert its attention far away from the SNs sending real data. By having (m) interval values where each SN will be generating one &#x003c9;<italic><sub>i</sub></italic> using the PRNG, we have reduced the average interval time from &#x003c9;<sub>max</sub> to &#x003c9;<sub>ave</sub>. That is explained in the inequality Equation (44):
<disp-formula id="FD6"><label>(44)</label><mml:math id="mm9"><mml:mrow><mml:msub><mml:mtext>&#x003c9;</mml:mtext><mml:mrow><mml:mi>m</mml:mi><mml:mi>a</mml:mi><mml:mi>x</mml:mi></mml:mrow></mml:msub><mml:mo>&#x0003e;</mml:mo><mml:msub><mml:mtext>&#x003c9;</mml:mtext><mml:mrow><mml:mi>a</mml:mi><mml:mi>v</mml:mi><mml:mi>e</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mi>T</mml:mi><mml:mn>1</mml:mn></mml:msub><mml:mo>+</mml:mo><mml:mo>&#x02026;</mml:mo><mml:mo>+</mml:mo><mml:msub><mml:mi>T</mml:mi><mml:mi>m</mml:mi></mml:msub></mml:mrow><mml:mi>m</mml:mi></mml:mfrac><mml:mo>&#x0003e;</mml:mo><mml:msub><mml:mtext>&#x003c9;</mml:mtext><mml:mrow><mml:mi>m</mml:mi><mml:mi>i</mml:mi><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p>Considering the earlier example, we have &#x003c9;<italic><sub>max</sub></italic> = 8, &#x003c9;<italic><sub>min</sub></italic> = 2 and &#x003c9;<italic><sub>ave</sub></italic> = 5. That is: we have reduced the delay interval by 37.5%. If m = 8, then delay reduced by 44%. The transmission of real and fake messages is exhibited in <xref ref-type="fig" rid="sensors-15-05820-f014">Figure 14</xref>.</p><fig id="sensors-15-05820-f014" position="float"><label>Figure 14</label><caption><p>SN is assigned a sequence of intervals, which repeat until sensor lifetime ends. At the end of each interval, the sensor sends a fake message if it does not have an event to report. This should cause different delay times depending on the event relative arrival time and the length of the interval.</p></caption><graphic xlink:href="sensors-15-05820-g014"/></fig></sec><sec><title>7.2.2. Reducing the Amount of Fake Messages and Delay for Real Messages</title><p>We have created a mechanism for dynamic interval allocation. Let us call <inline-formula><mml:math id="mm10"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> the <italic>big interval</italic> which has <italic>subintervals</italic> &#x003c9;<sub>i</sub>. It still makes sense to send fake messages at the end of each interval. However, having the real message wait until the end of the interval time, as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f015">Figure 15</xref>, is not commendable because it increases the delay at each node. Let us presume the current subinterval &#x003c9;<sub>i</sub> is the maximum, which is 8 time-units according to the example discussed earlier. Let us presume that the message was sensed at 2 time-units and it is ready to be sent at 4 time-units. Following the SGAT rules, it still needs to wait for another 4 time-units to be sent out! However, we know for sure that many other nodes have different &#x003c9;<sub>i</sub> subinterval values. Thus, during the time subintervals 2, 4, 6, and 8 there is enough traffic in the network. We propose that when the data is ready, the SN<sub>i</sub> should send the data during the next subinterval slot within the current interval &#x003c9;<sub>i</sub>. Consequently, if we are at interval &#x003c9;<italic><sub>max</sub></italic> = 8 which has four subintervals at (2, 4, 6, and 8), and for our example, at 6 time-units the data can be sent out. This way, we save about 2 time-units delay while we can guarantee that the adversary will not be able to infer the source of transmission because we have enough traffic distributed in the network.</p><fig id="sensors-15-05820-f015" position="float"><label>Figure 15</label><caption><p>Any node assigned subinterval &#x003c9;<sub>i</sub> = 2 will send a fake message if it does not have a real message to report. All the nodes in the network can send real messages within any subinterval.</p></caption><graphic xlink:href="sensors-15-05820-g015"/></fig><p>If we select higher values for <inline-formula><mml:math id="mm11"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>, then we can further reduce the number of fake messages transmitting at one subinterval, however, we are increasing the average delay as well. Selecting a value for <inline-formula><mml:math id="mm12"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> could be a tool to adjust security <italic>versus</italic> energy conservation. We have improved the fake message efficacy (<italic>FME</italic>) [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>,<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>] which could be calculated as indicated below:
<disp-formula id="FD7"><label>(45)</label><mml:math id="mm13"><mml:mrow><mml:mtext>FME</mml:mtext><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msubsup><mml:mstyle mathsize="50%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mtext>i</mml:mtext><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mtext>i</mml:mtext><mml:mo>=</mml:mo><mml:mtext>m</mml:mtext></mml:mrow></mml:msubsup><mml:mfrac><mml:mrow><mml:msub><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:mover accent="true"><mml:mtext>&#x003c9;</mml:mtext><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>SI</mml:mtext></mml:mrow><mml:mtext>i</mml:mtext></mml:msub></mml:mrow></mml:mfrac><mml:mo>&#x02212;</mml:mo><mml:mtext>m</mml:mtext></mml:mrow><mml:mrow><mml:msubsup><mml:mstyle mathsize="50%" displaystyle="true"><mml:mo>&#x02211;</mml:mo></mml:mstyle><mml:mrow><mml:mtext>i</mml:mtext><mml:mo>=</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mrow><mml:mtext>i</mml:mtext><mml:mo>=</mml:mo><mml:mtext>m</mml:mtext></mml:mrow></mml:msubsup><mml:mfrac><mml:mrow><mml:msub><mml:mo>&#x000a0;</mml:mo><mml:mrow><mml:mover accent="true"><mml:mtext>&#x003c9;</mml:mtext><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mtext>SI</mml:mtext></mml:mrow><mml:mtext>i</mml:mtext></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula>
where <inline-formula><mml:math id="mm14"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula> is the big interval value, (SIi) the subinterval value, (m) the total number of subintervals. For example, if SN assigned a sequence <inline-formula><mml:math id="mm15"><mml:mrow><mml:msub><mml:mi>&#x003c9;</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x02208;</mml:mo><mml:mo stretchy="false">[</mml:mo><mml:mn>4</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>6</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>2</mml:mn><mml:mo>,</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mn>8</mml:mn><mml:mo stretchy="false">]</mml:mo></mml:mrow></mml:math></inline-formula>, fake messages could be sent at the following subintervals [4, 10, 12, 20, 24, 30, 32, .....], and the real messages could be sent at the following sub intervals [2, 4, 6, 8, 10, 12, ....]. By substituting &#x003c9;<sub>i</sub> = 8, SI<sub>i</sub> = 2 and m = 4, FME will be 60%. <xref ref-type="fig" rid="sensors-15-05820-f014">Figure 14</xref> exhibits the transmission of fake and real messages for two consecutive subintervals.</p></sec><sec><title>7.2.3. Energy Conservation by Forwarding Messages to Energy-Rich SNs</title><p>When a node senses data or receives data that needs to be forwarded to the BS, it has to select the next one-hop node from the neighborhood set N<sub>i</sub>. During the setup phase, each SN<sub>i</sub> has information about the hop-distance for each of the neighbors stored in its table T<sub>i</sub>. Typically, there are three sets: one set where the hop-distance is less than its own (uplink set), a set where the hop-distance equals to itself (equal-link set) and a set where the hop-distance is larger than itself (downlink set). Choosing a node randomly or by round robin from the uplink set will be ideal in terms of delays since it will give the shortest path to the BS. However, that will cause the nodes in this set to consume more energy compared to the other two sets of the neighbors. After each transmission, the SN consumes some energy. The residual energy for SN<sub>i</sub> will be calculated as below:
<disp-formula id="FD8"><label>(46)</label><mml:math id="mm16"><mml:mrow><mml:msub><mml:mtext>&#x00394;</mml:mtext><mml:mrow><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>i</mml:mi><mml:mi>d</mml:mi><mml:mi>u</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfrac><mml:mrow><mml:msub><mml:mtext>&#x00394;</mml:mtext><mml:mrow><mml:mi>c</mml:mi><mml:mi>u</mml:mi><mml:mi>r</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mrow><mml:msub><mml:mtext>&#x00394;</mml:mtext><mml:mrow><mml:mi>i</mml:mi><mml:mi>n</mml:mi><mml:mi>i</mml:mi><mml:mi>t</mml:mi><mml:mi>i</mml:mi><mml:mi>a</mml:mi><mml:mi>l</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:mfrac></mml:mrow></mml:math></disp-formula></p><p>Each node will calculate its residual energy and share it with its one-hop neighbors. When the node sends fake messages, it will send its residual energy with it. The neighbor SN<sub>j</sub> will store the value in its T<sub>j</sub> for each of its neighboring nodes. This way, any sensor node will have some information about the residual energy level for its immediate neighbors. <xref ref-type="fig" rid="sensors-15-05820-f016">Figure 16</xref> exhibits the mechanism for selecting the forward node.</p><fig id="sensors-15-05820-f016" position="float"><label>Figure 16</label><caption><p>How to choose the forwarding node according to the energy levels of the neighbors. The sensor calculates the average energy levels for all the neighbors. Then it will select a neighbor, which has energy level higher than the calculated average energy, from uplink nodes if it is available. If not, then from equal-link nodes and then from downlink nodes.</p></caption><graphic xlink:href="sensors-15-05820-g016"/></fig></sec><sec><title>7.2.4. Handling Rate Attack</title><fig id="sensors-15-05820-f017" position="float"><label>Figure 17</label><caption><p>Higher transmission rate next to the BS. The figure exhibits about 20 transmissions near by the BS while one other area has 9 transmissions for the same period. This could be a bed for rate attack where the ADV can locate the BS [<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>].</p></caption><graphic xlink:href="sensors-15-05820-g017"/></fig><fig id="sensors-15-05820-f018" position="float"><label>Figure 18</label><caption><p>The area coverage of a central sink is higher than a peripherally sink. To balance the higher data rate nearby the sink, we acquire a higher density sensor distribution.</p></caption><graphic xlink:href="sensors-15-05820-g018"/></fig><p>One issue that WSN with one sink could suffer from is having higher transmission rate next to the BS where messages ultimately need to reach out to the BS as the final destination. In contrast, periphery sensors far from the BS could have light transmission rates. <xref ref-type="fig" rid="sensors-15-05820-f017">Figure 17</xref> illustrates the issue. This could jeopardize the location privacy of the BS. One solution is to have multiple sinks distributed in the network. This contradicts with the pre assumptions we set for our framework so we will not address this solution in this work. The framework needs to maintain similar average rate among all the sensors. This could be achieved by increasing the number of fake messages transmitted by less busy nodes, which means increasing the bandwidth usage and the power consumption. We need also to reduce the fake messages sent by busy nodes or delay the real messages to maintain similar rates. The latter is achieved automatically since the sensors do not send fake messages when they have real messages. However, this could be better tuned for average busy nodes as well. Having balanced rate in the WSN could help to maintain balanced average lifetime for the nodes in the network. Presuming that all the nodes are heterogeneous in terms of energy would mean that busy nodes would be depleted sooner that could create an empty coverage area or a buffer zone between the sink and the peripheral SNs. This makes it a double fold problem. The first approach is to select a suitable location for the BS in the network map. Most of the literature shows a side location for the BS. It is maybe because it is more suitable for the applications in hand where the BS is connected to the backbone network in a reachable area and sensors are unattended in out of reach areas. <xref ref-type="fig" rid="sensors-15-05820-f018">Figure 18</xref> exhibits that the coverage area of a central BS is much better than a side BS. The density of nodes closer to the BS should be higher. The range of transmission for sensors in higher density areas may need adjustment to control energy dissipation. We could have multiple density areas around the BS where the density is reduced, as it gets distant from the BS. <xref ref-type="fig" rid="sensors-15-05820-f018">Figure 18</xref> exhibits only two density areas for simplicity. If the storage of the sensor is not big enough, which is unrealistic case with increasing storage technology in the sensors, then the sensor does not need to include all the neighbors in the tables. The network will be divided into two areas, near (A<sub>n</sub>) and far (A<sub>f</sub>). The framework will set average transmission rate (ATR) thresholds, R<sub>max</sub> and R<sub>min</sub>. Sensors in A<sub>n</sub> will be loaded with R<sub>max</sub> where the sensors need to queue messages to maintain the threshold. In reverse, sensors in A<sub>f</sub> will be loaded with R<sub>min</sub> to maintain the lower threshold by sending more fake messages as needed. The sensor will calculate its average transmission rate over a period of time T<sub>atr,</sub> which is preset by the framework.</p></sec></sec><sec><title>7.3. Contribution of Temporal and Rate Privacy Module</title><p>Our innovation in this module is by providing both temporal and rate privacy. Many works have provided solutions for temporal privacy by either using delays or fake messages, but few has addressed the rate privacy as an independent threat to the WSN. In our module, we have used delay and fake messages to provide an efficient solution for such attacks. We took in consideration, the need to reduce the delays in the real-time applications and the necessity to reduce the energy dissipation. In addition, very few works has addressed the rate privacy for the BS presuming it is physically protected. In this framework, we always considered the BS as a normal sensor node, which requires privacy. <xref ref-type="sec" rid="sec9-sensors-15-05820">Section 9</xref> provides a thorough analysis and simulation for the delays, entropy and energy. The three modules of anonymity, authentication, temporal/rate privacy altogether will provide source, link and sink location privacy.</p></sec></sec><sec id="sec8-sensors-15-05820"><title>8. Anonymity and Security Analysis</title><p>We need to analyze FAC for both passive and active adversary attacks. The adversary (ADV) model has a global view of the network. ADV could target the source, intermediary and BS nodes. Usually, ADV starts by monitoring transmission somewhere in the network and then attempts to acquire sources (downlink direction) or BS (uplink direction). Passive attack is ordinarily the base for active attack. Once ADV determines the identity and location of a source or the BS, it consequently can launch various active attacks against certain nodes or disrupt the operation of the entire WSN. The main strength of passive ADV is the fact that neither SNs nor the BS will know about their existence. Nonetheless, active attacks can be detected if the framework instruments reasonable IDS. Any comprehensive solution for location privacy should protect against anonymity attacks, temporal attacks and rate discovery attacks. We believe that routing privacy is useful only against local advisory and once the WSN faced with a global or a multi-local adversary, routing privacy is not crucial. Thus, we have chosen short-path routing technique for this work. Any other routing protocols should be utilized to reduce delays and energy consumption.</p><sec><title>8.1. Security against Passive Attacks</title><p>SNs use disposable pseudonyms to identify each other instead of using real IDs. No real ID stored in the sensor and no pseudonym is used more than once. Data is encrypted all the way from the source to the BS using shared pair-wise keys. For <italic>eavesdropping and content analysis</italic>, ADV can intercept messages without being able to read them because data is encrypted all the way to the BS. The only information ADV can get from the captured messages is the pseudonyms: OHPID, BPID or FPID, which are all temporary IDs and have no use except to calculate a new set of pseudonyms. Fortunately, the ADV cannot get from the captured messages, important parameters a<sub>i&#x02194;j</sub>,b<sub>i</sub> or c<sub>i</sub> which are all required to calculated new pseudonyms. Source PIDs are all encrypted during transmission. For <italic>hop-by-hop trace</italic>, ADV can track a stream of messages from one node to another by overhearing the messages. The ADV will be challenged with many real and fake transmissions throughout the WSN. Furthermore, each node will retransmit the messages through different routes. For <italic>size-correlation</italic>, ADV will be able to understand relationship between incoming and outgoing messages by analyzing sizes of the messages. This attack does not work for our framework since all the messages have commensurate size. For <italic>identity correlation</italic>, ADV cannot relate overheard identities to their nodes. It is not possible since SNs use different pseudonyms every time a message is transmitted. For <italic>rate monitoring</italic>, ADV tries to collect some statistical information about transmission rates. For instance, WSN will have a higher transmission rate nearby the sink. This is handled by issuing fake messages to maintain a similar transmission rate. For <italic>angle-of-arrival (AoA)</italic>, ADV uses special hardware to determine the signal direction. The framework did not account for specific countermeasure; however, it becomes a more serious issue with mobile SNs. Furthermore, <italic>AoA</italic> would not perform well in our framework because of the uniform message distribution by using real and fake messages. For <italic>received-signal-strength (RSS)</italic>, ADV uses special hardware to measure signal strength to calculate distance to the source. This is not an issue for our framework since every transmitter has fixed transmission power and SNs are immobile.</p></sec><sec><title>8.2. Security against Active Attacks</title><p>In principle, we assume ADV knows encryption protocols used by the framework; however, the framework needs to hide <italic>encryption keys</italic> and <italic>IDs</italic>. Active attacks can be categorized into <italic>soft</italic> and <italic>hard</italic>. For soft-active attacks, ADV tries to compromise SNs to get some information related to security of the sensors such as <italic>keys</italic> and <italic>IDs</italic>. Consequently, it will monitor all messages traversing through the compromised nodes to discover the source and the BS locations. ADV hides its presence by acting passively (soft) but once it captures privacy information, it reports the information to an external executer to do further damages (such as killing the Panda in the Panda game). For that, it is harder for the IDS to detect the attack. In hard-active attacks, ADV captures SNs and invasively forge messages, sent replay messages <italic>etc</italic>. Moreover, ADV could load powerful devices with the captured credentials to launch more catastrophic attacks. Hard-active attacks could be detected by IDS; however, it could depend very much on the sophistication of the IDS used. With that, it remains very challenging to countermeasure hard-active attacks. In the following two subsections, we will analyze the security of our framework against active attacks.</p><sec><title>8.2.1. Soft-Active Attacks</title><p>If ADV <italic>physically</italic> compromises SN<sub>i</sub>, then it captures two sets of information:
<list list-type="simple"><list-item><label>(i)</label><p>Information related to the node itself: the current <italic>PID</italic>, the parameters used to calculate the pseudonyms, the hash functions, the keys and other information as listed in <xref ref-type="table" rid="sensors-15-05820-t002">Table 2</xref>.</p></list-item><list-item><label>(ii)</label><p>Information related to the neighbors as listed in <xref ref-type="table" rid="sensors-15-05820-t003">Table 3</xref>.</p></list-item></list></p><p>The ADV would have all it needs to issue new valid pseudonyms and to send messages out to neighbors. Let us look closely at few scenarios:</p><p><italic>Scenario 1</italic>: If ADV physically compromises SN<sub>i</sub>, and if SN<sub>j</sub> and SN<sub>r</sub> &#x003f5; N<sub>i</sub>, so SN<sub>i</sub> knows some information about both SN<sub>j</sub> and SN<sub>r</sub>. However, it cannot calculate important information such as a<sub>j&#x02194;r</sub> which is required for one-hop communication between SN<sub>j</sub> and SN<sub>r</sub> [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>], because SN<sub>i</sub> would need ID<sub>j</sub> and ID<sub>r</sub> which are both deleted permanently at the end of the setup phase. If SN<sub>i</sub> hears a message, it cannot determine, with high confidence, the sender among neighbors while communicating with each other. If SN<sub>i</sub> receives message from sources &#x02209; N<sub>i</sub>, then it would not be able to determine the source.</p><p><italic>Scenario 2</italic>: If ADV <italic>physically</italic> compromises multiple SNs, let us call it set N<sub>cs</sub>, and collects number of messages, let us call it set N<sub>cm</sub>. Then, the number of compromised PIDs equal to N<sub>cm</sub> since each message has unique PID. If the source SN<sub>i</sub>&#x02209; N<sub>cs</sub>, then ADV cannot know the source node [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>].</p><p><italic>Scenario 3</italic>: If the message sent, by source SN<sub>i</sub> as in <italic>scenario</italic>, 2 passes thought SN<sub>j</sub> &#x003f5; N<sub>cs</sub> or even through multiple compromised nodes, it will not be able to correlate the captured PID<sub>i</sub> with SN<sub>i</sub>. </p><p><italic>Scenario 4</italic>: If a message sent by source SN<sub>i</sub> and &#x02200; SN &#x003f5; N<sub>i</sub> is also &#x003f5; N<sub>cs</sub> (all neighbors are compromised), then ADV will be able to know that SN<sub>i</sub> is the source. It is unrealistic situation to have many compromised nodes in one area. However, this proves single or few compromised nodes cannot locate the identity of the source. In addition, a compromised node does not actually need to locate the sources within its range since it can detect the objects of interest (Panda) knowing that the ultimate goal of the adversary is to capture the <italic>object</italic> not the sensor reporting the object.</p><p>In summary, while we cannot prevent physical capturing of sensors, we need to make sure capturing sensors do not have destructive effects on other sensors. It is clear that our anonymity model protects against the <italic>avalanche</italic> or the <italic>domino effect</italic> behavior once one or few sensors are physically captured.</p></sec><sec><title>8.2.2. Hard-Active Attacks</title><p>If ADV physically compromises SN<sub>i</sub> then it can launch denial of service attacks (DoS), which is an effort to temporarily or indefinitely suspend transmission in the network. It consumes the resources such as bandwidth, memory, storage, and processor time. When ADV compromises SNs, it would be able to send massive valid messages to consume system resources. The ADV will be able also to launch replay attacks where ADV gets credentials of the some sensors and attempts to mimic the sensors to send messages to other neighbors. The other attacks such as, forging attack, packet alternation, packet dropping and packet injection are all only possible to physically captured nodes. However, it cannot propagate easily behind neighbors. Nothing could be worse than having physically captured nodes where ADV has full control over the sensors. Good IDS can detect such attacks and respond by removing the compromised nodes immediately. The most danger tactic of hard-active attacks is to prevent the real messages from following normal paths to the BS and force the messages to traverse through certain routes. Our main contribution to handle this attack is to put in place a seamless and efficient protocol to add and remove SNs while WSN in action.</p></sec></sec><sec id="sec8dot3-sensors-15-05820"><title>8.3. Sink Security</title><p>ADV can learn that a sensor has received a message in two ways: (i) When the sensor retransmits the message, which was tracked beforehand to another sensor; (ii) the ADV is able to make a correlation between the captured ID and the physical recipient sensor. The adversary cannot locate the BS location by compromising only one neighboring sensor because each transmission uses a different pseudonym. It actually will need to compromise multiple colluding sensors along the path to the BS or many neighbors of the BS. While we cannot prevent having many physically fallen sensors, our framework&#x02019;s goal is to delay the capturing of the BS if there are many colluding captured sensors in the WSN. A very interesting <italic>scenario</italic> is <italic>exhibited</italic> in <xref ref-type="fig" rid="sensors-15-05820-f019">Figure 19</xref>. Let us presume SN<sub>r</sub> &#x003f5; N<sub>cs</sub>. It issues a message with D<sub>bomb</sub> such that: <italic>APID<sub>r</sub> || OHPID<sub>r&#x02194;u</sub> || E<sub>r&#x02192;u</sub> (APID<sub>r</sub> || PID<sub>r</sub> || E<sub>kr&#x02194;bs</sub> (D<sub>bomb</sub>))</italic>. IF ADV compromise multiple nodes along the path to the BS where each sensor decrypts the data to read this <italic>signature</italic> at every hop: <italic>(PID<sub>r</sub> || E<sub>kr&#x02194;bs</sub> (D<sub>bomb</sub>).</italic> Providing the colluding sensors, in the path to the BS, read similar signature while it knows by design that every message should be directed uplink to the BS, the ADV could follow through to the BS. Having multiple compromised paths (with compromised sensors) reading the same pattern will give adversary more clues. Compromised nodes can even collude to force the real messages to route through fixed suspected areas in effort to focus the capturing process, which becomes a function of: (i) the size of the network; (ii) The traffic density; (iii) the number of compromised nodes. To solve this issue, we have to wipe out the signature before each transmission. Thus, every message will be forwarded to the next hop as below:
<disp-formula>M<sub>u&#x02192;x</sub> = APID<sub>u</sub> || OHPID<sub>u&#x02194;x</sub> || E<sub>u&#x02192;x</sub> (APID<sub>u</sub> || PID<sub>r</sub> || <bold>PID<sub>u</sub></bold> || <bold>E</bold><sub>ku&#x02194;bs</sub> (E<sub>kr&#x02194;bs</sub> (D<sub>i</sub>))) <label>(47)</label></disp-formula></p><p>We have added a multiple levels of encryption, which will be done at every hop using the shared key between the hop and the BS. In addition, PID of the hop will be added in sequence so the BS can do the decryption in sequence. This solution increases the size of the message proportionally to the number of hops. We suggest having the onion encryption done for a distance of few hops, O<sub>h</sub>. So, if O<sub>h</sub> = 2, then we have only two extra encryptions. In addition, we need to account for O<sub>h</sub> PID&#x02019;s added to the message.</p><fig id="sensors-15-05820-f019" position="float"><label>Figure 19</label><caption><p>Hard-active Attack tries to get the BS by inserting a signature in the transmitted message.</p></caption><graphic xlink:href="sensors-15-05820-g019"/></fig><p>We have implemented using Matlab a WSN of 100 SNs uniformly distributed over 30 &#x000d7; 30 area where the average distance between the SNs 3.7 as in <xref ref-type="fig" rid="sensors-15-05820-f012">Figure 12</xref>. The nodes are homogeneous in terms of initial energy. The WSN adopted one BS located at the side of the network. The SNs were preloaded with all the initial pseudonyms, so the simulation started right at the communication phase.</p><p>Sensors issue real messages according to a normal distribution using SGAT. To simulate how the network behaves to protect the BS, the simulation inserted some random compromised sensors. The compromised sensors sent some bomb messages as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f019">Figure 19</xref> and colluded to track the location of the BS. We have protected the BS by using the onion encryption so, we have simulated for O<sub>h</sub> equals to 1, 2 and 3. The adversary succeeds when it identifiers all the nodes forming the curve around the BS; SNs have 1, 2 and 3 hc from the BS, consecutively. <xref ref-type="fig" rid="sensors-15-05820-f020">Figure 20</xref> exhibits the number of transmissions required before the adversary can succeed. It is clear that with higher value for O<sub>h</sub>, the network will be able to send more messages before the BS is compromised. Having a higher number of compromised nodes in the WSN will make it faster to capture the BS, as well.</p><fig id="sensors-15-05820-f020" position="float"><label>Figure 20</label><caption><p>Protecting the BS by having onion encryption. Increasing O<sub>h</sub> and decreasing the number of compromised nodes will increase the total number of messages successfully transmitted to the BS before it is captured.</p></caption><graphic xlink:href="sensors-15-05820-g020"/></fig></sec><sec><title>8.4. Link Anonymity</title><p>Link anonymity is to prevent the ADV from knowing the relationship between the sender and the receiver. If a message leaves a sender and subsequently leaves the recipient without change, the ADV would know the relationship between the two nodes. This is secured in our framework since every message is completely changed after each retransmission including the IDs. In addition, it maintains fixed size. Applying different delays and different next-hop direction should also increase the privacy of the link. Furthermore, the adversary cannot know if the link carries real or fake data.</p></sec><sec><title>8.5. Timing Privacy</title><p>By using fake messages at variable interval times and message delays, it becomes super hard for the ADV to correlated messages being transmitted over the network as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f012">Figure 12</xref>.</p></sec><sec><title>8.6. Routing Privacy</title><p>Although short-path routing is used in this framework, choosing the next hop is done according to certain <italic>probabilistic</italic> algorithm, which accounts for the residual energy of the sensors and the usage frequency to increase the route privacy, as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f016">Figure 16</xref>. ADV cannot relate routes to nodes due to the triple anonymity. Even if two messages for one sensor follow the exact same route, ADV will see them as if they are two different routes since each hop along the route carries messages with different PIDs.</p></sec><sec><title>8.7. Data Privacy</title><p>All the data is encrypted before transmission and encrypted again at every hop along the route to the BS. A message digest will authenticate data. The only time data is not protected when the sensors are physically compromised. The compromised nodes are able to inject data in the network. If ADV uses the compromised nodes actively, a good IDS can detect the falsified data. The framework provides a secure facility to remove compromised sensors and to add valid sensors, if needed, to the WSN.</p></sec><sec><title>8.8. SLP and BLP</title><p>SLP and BLP are achieved at first by having the triple anonymity (<italic>source</italic>, <italic>BS</italic>, <italic>link</italic>) which was argued earlier. ADV cannot infer any information from the intercepted messages. Passive attacks will not endanger the location privacy. However, strong active attacks could hinder the location privacy without having good IDS. Secondly, we have provided a solution for temporal privacy using ECAT. Thirdly, we have provided a solution for rate attacks. The three security measures will work hand in hand to provide location privacy.</p></sec></sec><sec id="sec9-sensors-15-05820"><title>9. Performance Evaluation</title><p>In this section, we evaluate the performance of the FAC framework, including delays, energy dissipation, data rate privacy, storage, processing, computational, and communication costs.</p><sec id="sec9dot1-sensors-15-05820"><title>9.1. Delay</title><p>In SGAT, sensors transmit/forward the data at the end of the interval, which would cause a huge delay considering the volume of messages that each sensor needs to transmit during the network real-time operation. In addition, the messages traverse through multiple hops until it gets to the BS, which makes the accumulated delays significant. The other alternative scheme is having the sensors select one of the following subintervals (&#x003c9;) randomly to forward the message. This also will cause some unnecessary delays although it could help in hiding the temporal behavior of the sensors. ECAT scheme divides <inline-formula><mml:math id="mm17"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mover accent="true"><mml:mtext>&#x003c9;</mml:mtext><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></inline-formula> into subintervals (&#x003c9;), so the transmission will happen at the first available subinterval when the message is ready. We have simulated a smaller network to the one descripted in <xref ref-type="sec" rid="sec8dot3-sensors-15-05820">Section 8.3</xref> for the transmission delays. It includes 48 SNs only with &#x003c9; distribution as presented in <xref ref-type="fig" rid="sensors-15-05820-f022">Figure 15</xref>. We have three simulations using SGAT, ECAT, and random delays. <xref ref-type="fig" rid="sensors-15-05820-f021">Figure 21</xref> shows that delay per one-transmission increases throughout the network as the number of transmitted messages increases which could cause unjustifiable delays especially in the real time applications. <xref ref-type="fig" rid="sensors-15-05820-f022">Figure 22</xref> also shows the average delays for the three schemes. It shows that using ECAT has improved delays by 64% compared to SGAT. The total delay for one message from a source to a destination (BS) is calculated according to expression Equation (37). It is a function of the distance from the BS (hc) which we technically have no control over after sensors deployment. In addition, it is a function of the chosen (<inline-formula><mml:math id="mm18"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>) and (&#x003c9;) values for the system. The larger the (&#x003c9;), the more delays accumulated. We have simulated the same network using ECAT for the total delay as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f023">Figure 23</xref>. It shows that the delay rises as the <italic>hc</italic> increases and as the size of the intervals widens. We conclude of these simulations that the performance of ECAT is better than SGAT while it continues to provide a good temporal privacy. Using a fixed delay will reduces the delays slightly but it provides a very week temporal privacy.</p><fig id="sensors-15-05820-f021" position="float"><label>Figure 21</label><caption><p>Total accumulated delay per one node increases as number of messages increases in the WSN. ECAT sends the message only one subinterval after the message arrival. SGAT sends the message at the end of the big interval <inline-formula><mml:math id="mm29"><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow></mml:math></inline-formula>. In between, the approach of selecting one of the following subinterval randomly to send the message. Clearer image?</p></caption><graphic xlink:href="sensors-15-05820-g021"/></fig><fig id="sensors-15-05820-f022" position="float"><label>Figure 22</label><caption><p>Average accumulated delay per one node. ECAT shows the good performance of a minimum average delay since it sends the message only one subinterval after the message arrival.</p></caption><graphic xlink:href="sensors-15-05820-g022"/></fig><fig id="sensors-15-05820-f023" position="float"><label>Figure 23</label><caption><p>The accumulated delay is a function of the hop count (hc) and the size of &#x003c9;.</p></caption><graphic xlink:href="sensors-15-05820-g023"/></fig></sec><sec><title>9.2. Energy Cost</title><p>In our work, we will assume a simple energy dissipation model [<xref rid="B27-sensors-15-05820" ref-type="bibr">27</xref>,<xref rid="B42-sensors-15-05820" ref-type="bibr">42</xref>,<xref rid="B48-sensors-15-05820" ref-type="bibr">48</xref>,<xref rid="B49-sensors-15-05820" ref-type="bibr">49</xref>]. The radio dissipates &#x00510; nJ/bit for both transmission and reception by the sensors circuitry. Moreover, it consumes &#x00511; nJ/bit/m<sup>2</sup> for the transmitter amplifier to achieve an acceptable signal to noise ratio. Therefore, to transmit <italic>k</italic> bits for <italic>r</italic> distance, the total transmission energy dissipation will be:
<disp-formula id="FD9"><label>(48)</label><mml:math id="mm19"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext><mml:mtext>t</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mtext>k&#x000a0;</mml:mtext><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mi>&#x00510;</mml:mi><mml:mo>+</mml:mo><mml:mtext>k</mml:mtext><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mtext>&#x000a0;r</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000d7;</mml:mo><mml:mtext>&#x003b5;</mml:mtext></mml:mrow></mml:math></disp-formula></p><p>In addition, the receiver would consume for reception of k-bit message:
<disp-formula id="FD10"><label>(49)</label><mml:math id="mm20"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext><mml:mtext>r</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mtext>k</mml:mtext><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mtext>&#x00510;</mml:mtext></mml:mrow></mml:math></disp-formula></p><p>SGAT assumes that every node would send one message at the end of each interval where the message could be either real or fake. If we have <italic>N</italic> nodes in the network, then we expect <italic>N</italic> messages during each interval. The energy spent for transmission or reception is similar per one message because we have unified-size messages to prevent size correlation attacks by the adversary. If we have <italic>p</italic> percent of the nodes issue or forward real data at each interval, then <italic>1 &#x02212; p</italic> percent of the energy and the bandwidth is wasted on fake messages. We can adjust the amount of energy consumed by increasing the interval time (&#x003c9;). However, increasing (&#x003c9;), would increase the delay. The consumption of transmitting fake messages is a double fold since the transmitter will consume <inline-formula><mml:math id="mm21"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext><mml:mtext>t</mml:mtext></mml:msub></mml:mrow></mml:math></inline-formula> for every message and all the neighbors (<italic>Ni</italic>) will consume <inline-formula><mml:math id="mm22"><mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub><mml:mo>&#x000d7;</mml:mo><mml:msub><mml:mi>E</mml:mi><mml:mi>r</mml:mi></mml:msub></mml:mrow></mml:math></inline-formula>). When the transmission range increases, <italic>N<sub>i</sub></italic> increases. The total energy consumed in the network to send real and fake messages in one interval [<xref rid="B48-sensors-15-05820" ref-type="bibr">48</xref>]:
<disp-formula id="FD11"><label>(50)</label><mml:math id="mm23"><mml:mrow><mml:msub><mml:mtext>E</mml:mtext><mml:mtext>R</mml:mtext></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mtext>N</mml:mtext><mml:mo>)</mml:mo></mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>k</mml:mtext><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mtext>&#x00510;</mml:mtext><mml:mo>+</mml:mo><mml:mtext>k&#x000a0;</mml:mtext><mml:mo>&#x000d7;</mml:mo><mml:msup><mml:mrow><mml:mtext>&#x000a0;r</mml:mtext></mml:mrow><mml:mn>2</mml:mn></mml:msup><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mtext>&#x000a0;&#x003b5;</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>N&#x000a0;</mml:mtext><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:msub><mml:mi>N</mml:mi><mml:mi>i</mml:mi></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo stretchy="false">(</mml:mo><mml:mtext>k</mml:mtext><mml:mo>&#x000a0;</mml:mo><mml:mo>&#x000d7;</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mtext>&#x00510;</mml:mtext><mml:mo stretchy="false">)</mml:mo></mml:mrow></mml:math></disp-formula></p><p>ECAT has improved the energy dissipation by reducing the amount of fake messages transmitted while maintaining the required temporal security. The number of total messages transmitted per interval has reduced from 100% to a certain percentage (<italic>p</italic>). We have simulated the WSN in <xref ref-type="fig" rid="sensors-15-05820-f015">Figure 15</xref> as presented in <xref ref-type="sec" rid="sec9dot1-sensors-15-05820">Section 9.1</xref> using SCAT to calculate the energy dissipation. <xref ref-type="fig" rid="sensors-15-05820-f024">Figure 24</xref> exhibits the total energy dissipation per one message considering the transmitter, the recipients and the range of transmission. The size of the messages is 8000 bits, &#x00510; is 50 nJ/bit and &#x00511; is 100 pJ/bit/m<sup>2</sup>. The simulation shows that the energy dissipation due to the increase of sensor range is marginal compared to the increase in energy dissipation due to the increase of neighbors (<italic>N<sub>i</sub></italic>). However, increasing the range could increase N<sub>i</sub> if the WSN has uniform sensor distribution. We have also simulated the network to see how the transmission of fake messages has improved using ECAT. <xref ref-type="fig" rid="sensors-15-05820-f025">Figure 25</xref> exhibits the simulation of 40 subintervals (&#x003c9;). The graph shows the maximum possible fake message at each subinterval (&#x003c9;). For instance, the total fake messages during &#x003c9; = 10 is 16 messages while during &#x003c9; = 32 is 20 messages. The mean of fake transmissions is 19.5 (compared to 48 messages in SGAT). The average fake messages for the completely simulated period is 19.5 messages which shows about 59% reduction of possible fake messages comparted to SGAT.</p><p>The number of fake message will be reduced further as the network gets busy transmitting real messages since a sensor node do not send a fake message at a subinterval where it has a real message to convey. We have simulated the same network with 70% probability of event occurrence. <xref ref-type="fig" rid="sensors-15-05820-f026">Figure 26</xref> shows that the average fake messages has reduced to 5.85 messages, which is almost 88% reduction from SGAT. This also will reduce the energy consumption significantly.</p><fig id="sensors-15-05820-f024" position="float"><label>Figure 24</label><caption><p>The energy dissipation increases as the number of neighbors and the sensor transmission range increases. Simulation assumed message size of 8000 bits, &#x00510; is 50 nJ/bit and &#x00511; is 100 pJ/bit/m<sup>2</sup>.</p></caption><graphic xlink:href="sensors-15-05820-g024"/></fig><fig id="sensors-15-05820-f025" position="float"><label>Figure 25</label><caption><p>A simulation for the maximum possible fake messages per subinterval using ECAT. In SGAT, this number should be 48, which is one message per one sensor. ECAT has reduced it significantly. The mean in this simulation is 19.5, which is about 59% reduction of fake messages.</p></caption><graphic xlink:href="sensors-15-05820-g025"/></fig><fig id="sensors-15-05820-f026" position="float"><label>Figure 26</label><caption><p>The average fake messages in a busy network with 70% of the slots occupied by real messages. The reduction of fake messages transmission in ECAT is about 88% compared to SGAT.</p></caption><graphic xlink:href="sensors-15-05820-g026"/></fig><p>The most expensive operation for energy consumption is transmission of <italic>bits</italic> from one node to another. We use two stages for air communication in our framework, (i) In the setup phase and; (ii) in the communication phase. The data transmission during setup phase is minimal. During communication phase, data will be forwarded hop-by-hop to the BS. Every packet is equally sized to prevent time and size correlation. We have introduced a probabilistic fake message transmission scheme which none of the other protocols adopted. Real messages are sent at the end of each subinterval time to prevent delays.</p><p>The cost per message at one interval time is:
<disp-formula id="FD12"><label>(51)</label><mml:math id="mm24"><mml:mrow><mml:mtext>Average</mml:mtext><mml:mo>&#x000a0;</mml:mo><mml:mtext>Message</mml:mtext><mml:mo>&#x000a0;</mml:mo><mml:mtext>Cost</mml:mtext><mml:mo>=</mml:mo><mml:mo>&#x000a0;</mml:mo><mml:mfrac><mml:mrow><mml:mtext>R</mml:mtext><mml:mo>+</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mtext>N</mml:mtext><mml:mo>&#x02212;</mml:mo><mml:mtext>R</mml:mtext></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:msub><mml:mtext>P</mml:mtext><mml:mtext>r</mml:mtext></mml:msub><mml:mo>+</mml:mo><mml:mtext>A</mml:mtext></mml:mrow><mml:mtext>R</mml:mtext></mml:mfrac></mml:mrow></mml:math></disp-formula>
where <italic>R</italic> is the total number of SNs sending real messages at one subinterval time, <italic>P<sub>r</sub></italic> the probability of sending fake message by SNs, and A is the average number of acknowledgements in one interval. None of the other schemes addressed the issue of rate analysis attacks, which is one of the easiest attacks any adversary can use. Using fake messages is an expensive solution. However, we have designed FAC to be adaptive to the network traffic situation by using a closed-loop system. The sink can always increase or decrease the amount of fake messages used according to the reports it is getting about the system security. The threshold values of R<sub>min</sub> and R<sub>max</sub> are also adjustable according to the network situation.</p></sec><sec><title>9.3. Transmission Rate Privacy</title><p>To handle this issue, we have adopted two threshold values: Rmin and Rmax where the sensor needs to keep its message transmission rate between these two values. The sensor needs to send real message at the end of subinterval time slot. If it does not have a real message, then it needs to send a fake message only if that time slot is scheduled to send a fake message according to ECAT protocol, otherwise no transmission will happen and the slot remains idle. Ideally, the sensor has a real message at the subinterval so it does not need to waste a slot by sending a fake message. The sensor can use this facility to control the threshold data rate. For instance, if the rate is high (such as in areas nearby the BS), it can replace fake messages with real messages which is a double fold beneficial. If all the fake messages are already replaced and still there is real messages above the threshold, then the sensor is required to queue the messages and delay the transmission to maintain same average message rate between <italic>Rmin</italic> and <italic>Rmax</italic>. In contrast, if the message rate is low (as in the periphery sensors), then the sensor can transmit more fake messages during idle slots. We have simulated the network in <xref ref-type="fig" rid="sensors-15-05820-f015">Figure 15</xref> for ECAT and assigned the <italic>Rmin</italic> to be <italic>thirteen</italic> messages for two consecutive <inline-formula><mml:math id="mm25"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> intervals (a total of 20 subintervals). We have assigned the Rmax to be 13 messages during this period, which is seven less than the total number of subintervals. That means we allow up to 13 real and fake messages during these two consecutive <inline-formula><mml:math id="mm26"><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mover accent="true"><mml:mi>&#x003c9;</mml:mi><mml:mo stretchy="true">&#x000af;</mml:mo></mml:mover></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> intervals. <xref ref-type="fig" rid="sensors-15-05820-f027">Figure 27</xref> exhibits the output of the simulation for four different individual transmissions. For instance, the first transmission shows, 14 real messages (blue bar), 2 fake messages (light blue bar), and <italic>four</italic> idle slots (green bar). The total real and fake messages is 16 (<italic>orange bar</italic>) which is above the assigned threshold, <italic>thirteen</italic>, by <italic>three</italic> messages, which is expressed by the brown bar.</p><fig id="sensors-15-05820-f027" position="float"><label>Figure 27</label><caption><p>The simulation shows the total real messages, fake messages and idle slots. The threshold rate is <italic>thirteen</italic> messages over <italic>T<sub>atr</sub></italic> period. For instance, the first transmission shows total of <italic>sixteen</italic> messages, which is <italic>three</italic> above the threshold value. The sensor will cancel three fake messages. The third set shows the number of transmissions at the threshold.</p></caption><graphic xlink:href="sensors-15-05820-g027"/></fig><p>The SN will cancel <italic>three</italic> fake messages out of the <italic>four</italic>. In some worse cases, the sensors would need to queue the messages for next slots. For instance, if there is 15 real messages during this time, the system send only 13 messages and queue 2 messages for the next period. Ultimately, the overall message rate during T<sub>atr</sub> will be within the assigned thresholds.</p><p>We have simulated this approach extensively for (500), (1000), (1500) and (2000) transmissions as exhibited in <xref ref-type="fig" rid="sensors-15-05820-f028">Figure 28</xref>. The first, third and fifth bar sets show the total amount of fake messages needed to be replaced with real messages to maintain <italic>R<sub>min</sub></italic> for the thresholds of th = 10, th = 11 and th = 12 consecutively. For instance, a threshold of 10 means that the maximum number of messages transmitted should be 10 (out of 20 in our simulation). The second, fourth and sixth bar sets also show the number of messages which needed to be queued for the three consecutive threshold values. Therefore, if we have real messages above the number of scheduled fake messages, then we have to queue the messages for the next period of T<sub>atr</sub>. Overall, this simulation exhibits a great preference since we always would like to reduce the amount of fake messages and keep the bandwidth busy with real messages whenever it is possible. In addition, the simulation exhibits very small messages need to be queued (delayed). It shows as we increase the threshold value the less fake messages replacement or delays is required. In summation, reducing the fake messages and keeping the delayed message minimal is the goal, which ECAT clearly achieves.</p><fig id="sensors-15-05820-f028" position="float"><label>Figure 28</label><caption><p>Simulation for busy network with different R<italic><sub>min</sub></italic> threshold values th = 10, 11 and 12. F stands for the number of fake messages has been reduced and D stand for the number of delayed messages to maintain R<sub>min</sub>. The simulation shows that the number of delayed messages is minimal while it decreases as the threshold increases.</p></caption><graphic xlink:href="sensors-15-05820-g028"/></fig></sec><sec><title>9.4. Storage Evaluation</title><p>There are two sets of information stored in a SN<sub>i</sub>: (i) information related to the sensor itself such as random numbers: (a<sub>i</sub>, b<sub>i</sub>, c<sub>i</sub>), pseudonyms: (PID<sub>i</sub>, BPID<sub>i</sub>, FPID<sub>i</sub>, APID<sub>i</sub>), keys: (ki&#x02194;bs, bki, fbki); (ii) information related to neighbors which include, random numbers: (a<sub>i&#x02194;j</sub>, b<sub>j</sub>, c<sub>j</sub>), pseudonyms: (OHPID<sub>i&#x02194;j</sub>, BPID<sub>j</sub>, FPID<sub>j</sub>), keys: (k<sub>i&#x02194;j</sub>), Misc: (link<sub>i&#x02194;j</sub>, &#x00394;<sub>j</sub>).</p><p>If we presume that the keys, the random numbers, the pseudonyms and the hash functions are all <italic>n</italic> bits long in average, and the required bits for miscellaneous data altogether is <italic>two</italic> bytes, and the average number of neighbors N<sub>ave</sub>, then the total storage memory required is:
<disp-formula>Storage = 10<italic>n</italic> + (7<italic>n</italic> + 16) &#x000d7; N<sub>ave</sub><label>(52)</label></disp-formula></p><p>Chen <italic>et al.</italic> [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>] indicated the storage for <italic>SAS</italic>, CAS, <italic>APR</italic>, <italic>DCARPS and EAC.</italic> We also calculated the storage for <italic>PhID</italic>, <italic>ACS</italic>, HIR and RHIR. All are listed in <xref ref-type="table" rid="sensors-15-05820-t004">Table 4</xref>. The size of storage increases proportionally when the size of <italic>n</italic> increases. The most common hashing functions which are considered very secure are: <italic>MD4</italic> [<xref rid="B50-sensors-15-05820" ref-type="bibr">50</xref>] which uses 128-bits digest, <italic>SHA-1</italic> [<xref rid="B50-sensors-15-05820" ref-type="bibr">50</xref>] which uses 160-bits digest, and <italic>Whirlpool</italic> [<xref rid="B50-sensors-15-05820" ref-type="bibr">50</xref>] which uses 512-bits digest [<xref rid="B50-sensors-15-05820" ref-type="bibr">50</xref>].</p><table-wrap id="sensors-15-05820-t004" position="float"><object-id pub-id-type="pii">sensors-15-05820-t004_Table 4</object-id><label>Table 4</label><caption><p>Performance Comparison. <italic>N</italic> is the total number of sensors; <italic>N<sub>ave</sub></italic> is the average number of neighbors; <italic>k</italic> (only for RHIR) is number of stored hash values where the SN stores <italic>k</italic> hash values per one neighbor which are calculated in advance at setup phase.</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">No.</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Scheme</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Storage Cost (bits)</th><th align="center" valign="middle" style="border-top:solid thin;border-bottom:solid thin" rowspan="1" colspan="1">Computation Cost</th></tr></thead><tbody><tr><td align="center" valign="middle" rowspan="1" colspan="1">1</td><td align="center" valign="middle" rowspan="1" colspan="1">SAS</td><td align="center" valign="middle" rowspan="1" colspan="1">2nN + 4nN<sub>ave</sub> + 16</td><td align="left" valign="middle" rowspan="1" colspan="1">No hashing operations</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">2</td><td align="center" valign="middle" rowspan="1" colspan="1">CAS</td><td align="center" valign="middle" rowspan="1" colspan="1">6n + 7nN<sub>ave</sub> + 16</td><td align="left" valign="middle" rowspan="1" colspan="1">Two hashing orations and two encryptions</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">3</td><td align="center" valign="middle" rowspan="1" colspan="1">HIR</td><td align="center" valign="middle" rowspan="1" colspan="1">2n + 2nN<sub>ave</sub></td><td align="left" valign="middle" rowspan="1" colspan="1">One hashing function</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">4</td><td align="center" valign="middle" rowspan="1" colspan="1">RHIR</td><td align="center" valign="middle" rowspan="1" colspan="1">2n + 2nN<sub>ave</sub> + nkN<sub>ave</sub></td><td align="left" valign="middle" rowspan="1" colspan="1">No hashing functions</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">5</td><td align="center" valign="middle" rowspan="1" colspan="1">APR</td><td align="center" valign="middle" rowspan="1" colspan="1">9n + 7nN<sub>ave</sub> + 2N &#x02212; 2N<sub>ave</sub> &#x02212; 2</td><td align="left" valign="middle" rowspan="1" colspan="1">Six hashing functions</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">6</td><td align="center" valign="middle" rowspan="1" colspan="1">DCARPS</td><td align="center" valign="middle" rowspan="1" colspan="1">3n</td><td align="left" valign="middle" rowspan="1" colspan="1">No hashing functions</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">7</td><td align="center" valign="middle" rowspan="1" colspan="1">ACS</td><td align="center" valign="middle" rowspan="1" colspan="1">5nN<sub>ave</sub></td><td align="left" valign="middle" rowspan="1" colspan="1">Two hashing functions</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">8</td><td align="center" valign="middle" rowspan="1" colspan="1">PhID</td><td align="center" valign="middle" rowspan="1" colspan="1">(3n + 2) &#x000d7; N<sub>ave</sub></td><td align="left" valign="middle" rowspan="1" colspan="1">Four hashing function</td></tr><tr><td align="center" valign="middle" rowspan="1" colspan="1">9</td><td align="center" valign="middle" rowspan="1" colspan="1">EAC</td><td align="center" valign="middle" rowspan="1" colspan="1">6n + 6nN<sub>ave</sub> + 2</td><td align="left" valign="middle" rowspan="1" colspan="1">Four hashing operations</td></tr><tr><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">10</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">FAC</td><td align="center" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">10n + (7n + 16) &#x000d7; N<sub>ave</sub></td><td align="left" valign="middle" style="border-bottom:solid thin" rowspan="1" colspan="1">Four hashing operations &#x00026; O<sub>h</sub> encryptions</td></tr></tbody></table></table-wrap></sec><sec><title>9.5. Processing and Computational Evaluation</title><p>Hash functions are used to calculate the pseudonyms and symmetric cryptography is used to encrypt the messages. Because we need to calculate three pseudonyms and one acknowledgement pseudonym after each transmission, using encryption to create pseudonyms was avoided since it requires more processing power compared to hash functions. When a SN senses data, it needs to calculate four OWH for PID, OHPID, and APID at the sender and OHPID at the receiver. If the system opts for data authentication, then another hash function is needed. The source node needs only one encryption for the data if O<sub>h</sub> = 0, however, it needs O<sub>h</sub> more encryptions if onion fashion is used. Each intermediary node needs one decryption operation and then another encryption to issue the new message. Chen <italic>et al.</italic> [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>] indicates that SAS does not use hashing or encryption to create pseudonyms because it uses already created pseudonyms from a space. The other scheme by Chen <italic>et al.</italic> [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>], CAS, uses two hashing operations and two encryption operations. APR uses at least six hashing functions. DCARPS uses constant IDs, so no hashing functions or encryptions for creating IDs. EAC has four hashing operations. It is clear that our framework needs a bit extra processing power due to the higher privacy and security we have achieved. None of the other schemes can achieve privacy against global threats and active adversary attacks. The power consumption due to the additional encryption operations is marginal compared to the power consumption caused by data transmission. <xref ref-type="fig" rid="sensors-15-05820-f029">Figure 29</xref> exhibits different storage size for different privacy schemes, which are discussed throughout this work. It shows that the increase in storage is <italic>linear</italic> and relatively comparable to the other protocols. The size of the storage would increase when the number of neighbors increases. Each SN has limited flash memory size, which could confine the maximum number of neighbors that a sensor can fit. As an example, <italic>TelosB</italic> mote [<xref rid="B16-sensors-15-05820" ref-type="bibr">16</xref>,<xref rid="B20-sensors-15-05820" ref-type="bibr">20</xref>] has 1 MB external flash memory. Thus, if one neighbor node requires 1.2 k bits of storage memory, then TelosB could fit more than 800 neighbors, which is very much more than what is needed in practical networks. Although FAC shows a bit of increase in the storage required to store the pseudonyms but it is the only one, among the discussed protocols in this work, provides a steady and functional anonymity and location privacy under strong global and active attack. In addition, the current technology provides sensors with sizable storage memory, which makes it not an issue at all.</p><fig id="sensors-15-05820-f029" position="float"><label>Figure 29</label><caption><p>Size of storage memory using different privacy schemes.</p></caption><graphic xlink:href="sensors-15-05820-g029"/></fig></sec></sec><sec id="sec10-sensors-15-05820"><title>10. Conclusions and Future Work</title><p>FAC is a modular framework that provides source, link and sink anonymity. It also provides temporal privacy and rate privacy. None of the previous related-work have a comprehensive solution for anonymity and location privacy. The three modules provided in FAC are made work together to prevent any statistical analysis attacks. The quadruple privacy (anonymity, temporal, rate, statistical) has provided a fortified SLP and BLP. FAC has addressed both local and global adversary. We have used a complex anonymity module where pseudonyms to replace real IDs are used. To provide temporal privacy both delays and fake messages are used. The use of fake messages was adjusted to manage the energy consumption. Two schemes are introduced, SGAT and ECAT. FAC is able to handle both homogenous and heterogeneous sensor nodes. FAC is both energy-aware and delay-aware. We have demonstrated that FAC can withstand passive and active attacks by presenting scenarios and provided solutions. The memory cost was mathematically analyzed for the framework. The computational complexity for encryptions and hash functions was analyzed. To provide security for the BS against colluding active attacks, we have introduced onion encryptions. We have simulated the performance of the framework. The future work would include enhancement on the fake messages probabilistic scheme. In addition, we will implement FAC for different routing protocols such as clustered networks. We would plug FAC in some civil and military applications for further analysis, development and improvement.</p></sec></body><back><notes><title>Author Contributions</title><p>Abdel-shakour Abuzneid has conducted the research work and simulations. The rest of the authors contributed to framing the intellectual merit of the proposed contribution to the state-of-the-art. The article was written by Abdel-shakour Abuzneid.</p></notes><notes><title>Conflicts of Interest</title><p>The authors declare no conflict of interest.</p></notes><ref-list><title>References</title><ref id="B1-sensors-15-05820"><label>1.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Eu</surname><given-names>Z.A.</given-names></name><name><surname>Tan</surname><given-names>H.-P.</given-names></name><name><surname>Seah</surname><given-names>W.K.G.</given-names></name></person-group>
<article-title>Design and Performance analysis of MAC Schemes for Wireless Sensor Networks Powered by Ambient Energy Harvesting</article-title>
<source>Ad Hoc Netw.</source>
<year>2011</year>
<volume>9</volume>
<fpage>300</fpage>
<lpage>323</lpage>
<pub-id pub-id-type="doi">10.1016/j.adhoc.2010.07.014</pub-id>
</element-citation></ref><ref id="B2-sensors-15-05820"><label>2.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Noh</surname><given-names>D.K.</given-names></name><name><surname>Hur</surname><given-names>J.</given-names></name></person-group>
<article-title>Using a dynamic backbone for efficient data delivery in solar-powered WSNs</article-title>
<source>J. Netw. Comput. Appl.</source>
<year>2012</year>
<volume>35</volume>
<fpage>1277</fpage>
<lpage>1284</lpage>
<pub-id pub-id-type="doi">10.1016/j.jnca.2012.01.012</pub-id>
</element-citation></ref><ref id="B3-sensors-15-05820"><label>3.</label><element-citation publication-type="book">
<person-group person-group-type="author"><name><surname>Li</surname><given-names>Y.</given-names></name><name><surname>Ren</surname><given-names>J.</given-names></name></person-group>
<article-title>Providing Source-Location Privacy in Wireless Sensor Networks</article-title>
<source>Wireless Algorithms, Systems, and Applications</source>
<person-group person-group-type="editor"><name><surname>Liu</surname><given-names>B.</given-names></name><name><surname>Bestavros</surname><given-names>A.</given-names></name><name><surname>Du</surname><given-names>D.-Z.</given-names></name><name><surname>Wang</surname><given-names>J.</given-names></name></person-group>
<publisher-name>Springer</publisher-name>
<publisher-loc>Berlin/Heidelberg, Germany</publisher-loc>
<year>2009</year>
<volume>Volume 5682</volume>
<fpage>338</fpage>
<lpage>347</lpage>
</element-citation></ref><ref id="B4-sensors-15-05820"><label>4.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Conti</surname><given-names>M.</given-names></name><name><surname>Willemsen</surname><given-names>J.</given-names></name><name><surname>Crispo</surname><given-names>B.</given-names></name></person-group>
<article-title>Providing Source Location Privacy in Wireless Sensor Networks: A Survey</article-title>
<source>IEEE Commun. Surv. Tutor.</source>
<year>2013</year>
<volume>15</volume>
<fpage>1238</fpage>
<lpage>1280</lpage>
<pub-id pub-id-type="doi">10.1109/SURV.2013.011413.00118</pub-id>
</element-citation></ref><ref id="B5-sensors-15-05820"><label>5.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Abbasi</surname><given-names>A.</given-names></name><name><surname>Khonsari</surname><given-names>A.</given-names></name><name><surname>Talebi</surname><given-names>M.S.</given-names></name></person-group>
<article-title>Source Location Anonymity for Sensor Networks</article-title>
<source>Proceediongs of the 6th IEEE Consumer Communications and Networking Conference</source>
<conf-loc>Las Vegas, NV, USA</conf-loc>
<conf-date>10&#x02013;13 January 2009</conf-date>
</element-citation></ref><ref id="B6-sensors-15-05820"><label>6.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Nezhad</surname><given-names>A.A.</given-names></name><name><surname>Miri</surname><given-names>A.</given-names></name><name><surname>Makrakis</surname><given-names>D.</given-names></name></person-group>
<article-title>Location privacy and anonymity preserving routing for wireless sensor networks</article-title>
<source>Comput. Netw.</source>
<year>2008</year>
<volume>52</volume>
<fpage>3433</fpage>
<lpage>3452</lpage>
<pub-id pub-id-type="doi">10.1016/j.comnet.2008.09.005</pub-id>
</element-citation></ref><ref id="B7-sensors-15-05820"><label>7.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Yao</surname><given-names>L.</given-names></name><name><surname>Kang</surname><given-names>L.</given-names></name><name><surname>Shang</surname><given-names>P.</given-names></name><name><surname>Wu</surname><given-names>G.</given-names></name></person-group>
<article-title>Protecting the sink location privacy in wireless sensor networks</article-title>
<source>Pers. Ubiquitous Comput.</source>
<year>2013</year>
<volume>17</volume>
<fpage>883</fpage>
<lpage>893</lpage>
<pub-id pub-id-type="doi">10.1007/s00779-012-0539-9</pub-id>
</element-citation></ref><ref id="B8-sensors-15-05820"><label>8.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Li</surname><given-names>N.</given-names></name><name><surname>Zhang</surname><given-names>N.</given-names></name><name><surname>Das</surname><given-names>S.K.</given-names></name><name><surname>Thuraisingham</surname><given-names>B.</given-names></name></person-group>
<article-title>Privacy preservation in wireless sensor networks: A state-of-the-art survey</article-title>
<source>Ad Hoc Netw.</source>
<year>2009</year>
<volume>7</volume>
<fpage>1501</fpage>
<lpage>1514</lpage>
<pub-id pub-id-type="doi">10.1016/j.adhoc.2009.04.009</pub-id>
</element-citation></ref><ref id="B9-sensors-15-05820"><label>9.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Yan</surname><given-names>Z.</given-names></name><name><surname>Zhang</surname><given-names>P.</given-names></name><name><surname>Vasilakos</surname><given-names>A.V.</given-names></name></person-group>
<article-title>A survey on trust management for Internet of Things</article-title>
<source>J. Netw. Comput. Appl.</source>
<year>2014</year>
<volume>42</volume>
<fpage>120</fpage>
<lpage>134</lpage>
<pub-id pub-id-type="doi">10.1016/j.jnca.2014.01.014</pub-id>
</element-citation></ref><ref id="B10-sensors-15-05820"><label>10.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Jing</surname><given-names>Q.</given-names></name><name><surname>Vasilakos</surname><given-names>A.</given-names></name><name><surname>Wan</surname><given-names>J.</given-names></name><name><surname>Lu</surname><given-names>J.</given-names></name><name><surname>Qiu</surname><given-names>D.</given-names></name></person-group>
<article-title>Security of the Internet of Things: Perspectives and challenges</article-title>
<source>Wirel. Netw.</source>
<year>2014</year>
<volume>20</volume>
<fpage>2481</fpage>
<lpage>2501</lpage>
<pub-id pub-id-type="doi">10.1007/s11276-014-0761-7</pub-id>
</element-citation></ref><ref id="B11-sensors-15-05820"><label>11.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Kamat</surname><given-names>P.</given-names></name><name><surname>Zhang</surname><given-names>Y.</given-names></name><name><surname>Trappe</surname><given-names>W.</given-names></name><name><surname>Ozturk</surname><given-names>C.</given-names></name></person-group>
<article-title>Enhancing Source-Location Privacy in Sensor Network Routing</article-title>
<source>Proceedings of the 25th IEEE International Conference on Distributed Computing Systems (ICDCS)</source>
<conf-loc>Columbus, OH, USA</conf-loc>
<conf-date>10 June 2005</conf-date>
</element-citation></ref><ref id="B12-sensors-15-05820"><label>12.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Ozturk</surname><given-names>C.</given-names></name><name><surname>Zhang</surname><given-names>Y.</given-names></name><name><surname>Trappe</surname><given-names>W.</given-names></name><name><surname>Ott</surname><given-names>M.</given-names></name></person-group>
<article-title>Source-Location Privacy for Networks of Energy-Constrained Sensors</article-title>
<source>Proceediongs of the Second IEEE Workshop on Software Technologies for Future Embedded and Ubiquitous Systems</source>
<conf-loc>Vienna, Austria</conf-loc>
<conf-date>11&#x02013;12 May 2004</conf-date>
</element-citation></ref><ref id="B13-sensors-15-05820"><label>13.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Jing</surname><given-names>D.</given-names></name><name><surname>Han</surname><given-names>R.</given-names></name><name><surname>Mishra</surname><given-names>S.</given-names></name></person-group>
<article-title>Countermeasures against Traffic Analysis Attacks in Wireless Sensor Networks</article-title>
<source>Proceediongs of the First International Conference on Security and Privacy for Emerging Areas in Communications Networks</source>
<conf-loc>Washington, DC, USA</conf-loc>
<conf-date>5&#x02013;9 September 2005</conf-date>
</element-citation></ref><ref id="B14-sensors-15-05820"><label>14.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Ying</surname><given-names>J.</given-names></name><name><surname>Shigang</surname><given-names>C.</given-names></name><name><surname>Zhan</surname><given-names>Z.</given-names></name><name><surname>Liang</surname><given-names>Z.</given-names></name></person-group>
<article-title>A novel scheme for protecting receiver's location privacy in wireless sensor networks</article-title>
<source>IEEE Trans. Wirel. Commun.</source>
<year>2008</year>
<volume>7</volume>
<fpage>3769</fpage>
<lpage>3779</lpage>
<pub-id pub-id-type="doi">10.1109/T-WC.2008.070182</pub-id>
</element-citation></ref><ref id="B15-sensors-15-05820"><label>15.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Xinfeng</surname><given-names>L.</given-names></name><name><surname>Xiaoyuan</surname><given-names>W.</given-names></name><name><surname>Nan</surname><given-names>Z.</given-names></name><name><surname>Zhiguo</surname><given-names>W.</given-names></name><name><surname>Ming</surname><given-names>G.</given-names></name></person-group>
<article-title>Enhanced Location Privacy Protection of Base Station in Wireless Sensor Networks</article-title>
<source>Proceedings of the 5th International Conference on Mobile Ad-hoc and Sensor Networks MSN</source>
<conf-loc>Fujian, China</conf-loc>
<conf-date>14&#x02013;16 December 2009</conf-date>
</element-citation></ref><ref id="B16-sensors-15-05820"><label>16.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Chen</surname><given-names>J.</given-names></name><name><surname>Du</surname><given-names>X.</given-names></name><name><surname>Fang</surname><given-names>B.</given-names></name></person-group>
<article-title>An efficient anonymous communication protocol for wireless sensor networks</article-title>
<source>Wirel. Commun. Mob. Comput.</source>
<year>2012</year>
<volume>12</volume>
<fpage>1302</fpage>
<lpage>1312</lpage>
<pub-id pub-id-type="doi">10.1002/wcm.1205</pub-id>
</element-citation></ref><ref id="B17-sensors-15-05820"><label>17.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Ouyang</surname><given-names>Y.</given-names></name><name><surname>Le</surname><given-names>Z.</given-names></name><name><surname>Liu</surname><given-names>D.</given-names></name><name><surname>Ford</surname><given-names>J.</given-names></name><name><surname>Makedon</surname><given-names>F.</given-names></name></person-group>
<article-title>Source Location Privacy against Laptop-Class Attacks in Sensor Networks</article-title>
<source>Proceedings of the 4th International Conference on Security and Privacy in Communication Netowrks</source>
<conf-loc>Istanbul, Turkey</conf-loc>
<conf-date>22 September 2008</conf-date>
<fpage>1</fpage>
<lpage>10</lpage>
</element-citation></ref><ref id="B18-sensors-15-05820"><label>18.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Xiaoyan</surname><given-names>H.</given-names></name><name><surname>Pu</surname><given-names>W.</given-names></name><name><surname>Jiejun</surname><given-names>K.</given-names></name><name><surname>Qunwei</surname><given-names>Z.</given-names></name><name><surname>Jun</surname><given-names>L.</given-names></name></person-group>
<article-title>Effective Probabilistic Approach Protecting Sensor Traffic</article-title>
<source>Proceedings of the IEEE Military Communications Conference (MILCOM)</source>
<conf-loc>Atlantic City, NJ, USA</conf-loc>
<conf-date>17&#x02013;20 October 2005</conf-date>
</element-citation></ref><ref id="B19-sensors-15-05820"><label>19.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Kamat</surname><given-names>P.</given-names></name><name><surname>Xu</surname><given-names>W.</given-names></name><name><surname>Trappe</surname><given-names>W.</given-names></name><name><surname>Zhang</surname><given-names>Y.</given-names></name></person-group>
<article-title>Temporal privacy in wireless sensor networks: Theory and practice</article-title>
<source>ACM Trans. Sen. Netw.</source>
<year>2009</year>
<volume>5</volume>
<fpage>1</fpage>
<lpage>24</lpage>
<pub-id pub-id-type="doi">10.1145/1614379.1614380</pub-id>
</element-citation></ref><ref id="B20-sensors-15-05820"><label>20.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Xue</surname><given-names>G.</given-names></name><name><surname>Misra</surname><given-names>S.</given-names></name></person-group>
<article-title>Efficient anonymity schemes for clustered wireless sensor networks</article-title>
<source>Int. J. Sens. Netw.</source>
<year>2006</year>
<volume>1</volume>
<fpage>50</fpage>
<lpage>63</lpage>
<pub-id pub-id-type="doi">10.1504/IJSNET.2006.010834</pub-id>
</element-citation></ref><ref id="B21-sensors-15-05820"><label>21.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Yi</surname><given-names>O.</given-names></name><name><surname>Zhengyi</surname><given-names>L.</given-names></name><name><surname>Yurong</surname><given-names>X.</given-names></name><name><surname>Triandopoulos</surname><given-names>N.</given-names></name><name><surname>Sheng</surname><given-names>Z.</given-names></name><name><surname>Ford</surname><given-names>J.</given-names></name><name><surname>Makedon</surname><given-names>F.</given-names></name></person-group>
<article-title>Providing Anonymity in Wireless Sensor Networks</article-title>
<source>Proceedings of the IEEE International Conference on Pervasive Services</source>
<conf-loc>Istanbul, Turkey</conf-loc>
<conf-date>15&#x02013;20 July 2007</conf-date>
</element-citation></ref><ref id="B22-sensors-15-05820"><label>22.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Jang-Ping</surname><given-names>S.</given-names></name><name><surname>Jehm-Ruey</surname><given-names>J.</given-names></name><name><surname>Ching</surname><given-names>T.</given-names></name></person-group>
<article-title>Anonymous Path Routing in Wireless Sensor Networks</article-title>
<source>Proceedings of the IEEE International Conference on Communications (ICC)</source>
<conf-loc>Beijing, China</conf-loc>
<conf-date>19&#x02013;23 May 2008</conf-date>
</element-citation></ref><ref id="B23-sensors-15-05820"><label>23.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Xi</surname><given-names>L.</given-names></name><name><surname>Xu</surname><given-names>J.</given-names></name><name><surname>Myong-Soon</surname><given-names>P.</given-names></name></person-group>
<article-title>Location Privacy against Traffic Analysis Attacks in Wireless Sensor Networks</article-title>
<source>Proceedings of the International Conference on Information Science and Applications (ICISA)</source>
<conf-loc>Seoul, Korea</conf-loc>
<conf-date>21&#x02013;23 April 2010</conf-date>
</element-citation></ref><ref id="B24-sensors-15-05820"><label>24.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Di Pietro</surname><given-names>R.</given-names></name><name><surname>Viejo</surname><given-names>A.</given-names></name></person-group>
<article-title>Location privacy and resilience in wireless sensor networks querying</article-title>
<source>Comput. Commun.</source>
<year>2011</year>
<volume>34</volume>
<fpage>515</fpage>
<lpage>523</lpage>
</element-citation></ref><ref id="B25-sensors-15-05820"><label>25.</label><element-citation publication-type="book">
<person-group person-group-type="author"><name><surname>Park</surname><given-names>J.-H.</given-names></name><name><surname>Jung</surname><given-names>Y.-H.</given-names></name><name><surname>Ko</surname><given-names>H.</given-names></name><name><surname>Kim</surname><given-names>J.-J.</given-names></name><name><surname>Jun</surname><given-names>M.-S.</given-names></name></person-group>
<article-title>A Privacy Technique for Providing Anonymity to Sensor Nodes in a Sensor Network</article-title>
<source>Ubiquitous Computing and Multimedia Applications</source>
<person-group person-group-type="editor"><name><surname>Kim</surname><given-names>T.-H.</given-names></name><name><surname>Adeli</surname><given-names>H.</given-names></name><name><surname>Robles</surname><given-names>R.J.</given-names></name><name><surname>Balitanas</surname><given-names>M.</given-names></name></person-group>
<publisher-name>Springer</publisher-name>
<publisher-loc>Berlin/Heidelberg, Germany</publisher-loc>
<year>2011</year>
<fpage>327</fpage>
<lpage>335</lpage>
</element-citation></ref><ref id="B26-sensors-15-05820"><label>26.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Juan</surname><given-names>C.</given-names></name><name><surname>Hongli</surname><given-names>Z.</given-names></name><name><surname>Binxing</surname><given-names>F.</given-names></name><name><surname>Xiaojiang</surname><given-names>D.</given-names></name><name><surname>Lihua</surname><given-names>Y.</given-names></name><name><surname>Xiangzhan</surname><given-names>Y.</given-names></name></person-group>
<article-title>Towards Efficient Anonymous Communications in Sensor Networks</article-title>
<source>Proceedings of the IEEE Global Telecommunications Conference (GLOBECOM)</source>
<conf-loc>Houston, TX, USA</conf-loc>
<conf-date>5&#x02013;9 December 2011</conf-date>
</element-citation></ref><ref id="B27-sensors-15-05820"><label>27.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Abuzneid</surname><given-names>A.</given-names></name><name><surname>Sobh</surname><given-names>T.</given-names></name><name><surname>Faezipour</surname><given-names>M.</given-names></name></person-group>
<article-title>An Enhanced Communication Protocol for Anonymity and Location Privacy in WSN</article-title>
<source>Proceedings of the IEEE Wireless Communications and Networking Conference</source>
<conf-loc>New Orleans, LA, USA</conf-loc>
<conf-date>9&#x02013;12 March 2015</conf-date>
</element-citation></ref><ref id="B28-sensors-15-05820"><label>28.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Kong</surname><given-names>J.</given-names></name><name><surname>Hong</surname><given-names>X.</given-names></name></person-group>
<article-title><italic>ANODR</italic>: Anonymous on Demand Routing with Untraceable Routes for Mobile ad-hoc Networks</article-title>
<source>Proceedings of the 4th ACM International Symposium on Mobile ad hoc Networking &#x00026; Computing</source>
<conf-loc>Annapolis, MA, USA</conf-loc>
<conf-date>1&#x02013;3 June 2003</conf-date>
<fpage>291</fpage>
<lpage>302</lpage>
</element-citation></ref><ref id="B29-sensors-15-05820"><label>29.</label><element-citation publication-type="webpage">
<article-title>Kerckhoffs&#x02019; Principle</article-title>
<comment>Available from: <ext-link ext-link-type="uri" xlink:href="http://en.citizendium.org/wiki/Kerckhoffs%27_Principle">http://en.citizendium.org/wiki/Kerckhoffs%27_Principle</ext-link></comment>
<date-in-citation>(accessed on 1 March 2015)</date-in-citation>
</element-citation></ref><ref id="B30-sensors-15-05820"><label>30.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Yanchao</surname><given-names>Z.</given-names></name><name><surname>Wei</surname><given-names>L.</given-names></name><name><surname>Wenjing</surname><given-names>L.</given-names></name><name><surname>Yuguang</surname><given-names>F.</given-names></name></person-group>
<article-title>Location-based compromise-tolerant security mechanisms for wireless sensor networks</article-title>
<source>IEEE J. Sel. Areas Commun.</source>
<year>2006</year>
<volume>24</volume>
<fpage>247</fpage>
<lpage>260</lpage>
<pub-id pub-id-type="doi">10.1109/JSAC.2005.861382</pub-id>
</element-citation></ref><ref id="B31-sensors-15-05820"><label>31.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Lu</surname><given-names>R.</given-names></name><name><surname>Lin</surname><given-names>X.</given-names></name><name><surname>Zhang</surname><given-names>C.</given-names></name><name><surname>Zhu</surname><given-names>H.</given-names></name><name><surname>Ho</surname><given-names>P.</given-names></name><name><surname>Shen</surname><given-names>X.</given-names></name></person-group>
<article-title>AICN: An Efficient Algorithm to Identify Compromised Nodes in Wireless Sensor Network</article-title>
<source>Proceedings of the IEEE International Conference on Communications (ICC)</source>
<conf-loc>Beijing, China</conf-loc>
<conf-date>19&#x02013;23 May 2008</conf-date>
</element-citation></ref><ref id="B32-sensors-15-05820"><label>32.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Song</surname><given-names>H.</given-names></name><name><surname>Xie</surname><given-names>L.</given-names></name><name><surname>Zhu</surname><given-names>S.</given-names></name><name><surname>Cao</surname><given-names>G.</given-names></name></person-group>
<article-title>Sensor Node Compromise Detection: the Location Perspective</article-title>
<source>Proceedings of the 2007 International Conference on Wireless Communications and Mobile Computing</source>
<conf-loc>Honolulu, HI, USA</conf-loc>
<conf-date>12 August 2007</conf-date>
<fpage>242</fpage>
<lpage>247</lpage>
</element-citation></ref><ref id="B33-sensors-15-05820"><label>33.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Tao</surname><given-names>L.</given-names></name><name><surname>Min</surname><given-names>S.</given-names></name><name><surname>Alam</surname><given-names>M.</given-names></name></person-group>
<article-title>Compromised Sensor Nodes Detection: A Quantitative Approach</article-title>
<source>Proceedings of the 28th International Conference on Distributed Computing Systems Workshops (ICDCS)</source>
<conf-loc>Beijing, China</conf-loc>
<conf-date>17&#x02013;20 June 2008</conf-date>
</element-citation></ref><ref id="B34-sensors-15-05820"><label>34.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Alomair</surname><given-names>B.</given-names></name><name><surname>Clark</surname><given-names>A.</given-names></name><name><surname>Cuellar</surname><given-names>J.</given-names></name><name><surname>Poovendran</surname><given-names>R.</given-names></name></person-group>
<article-title>Toward a Statistical Framework for Source Anonymity in Sensor Networks</article-title>
<source>IEEE Trans. Mob. Comput.</source>
<year>2013</year>
<volume>12</volume>
<fpage>248</fpage>
<lpage>260</lpage>
<pub-id pub-id-type="doi">10.1109/TMC.2011.267</pub-id>
</element-citation></ref><ref id="B35-sensors-15-05820"><label>35.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Zhu</surname><given-names>S.</given-names></name><name><surname>Setia</surname><given-names>S.</given-names></name><name><surname>Jajodia</surname><given-names>S.</given-names></name></person-group>
<article-title>LEAP+: Efficient security mechanisms for large-scale distributed sensor networks</article-title>
<source>ACM Trans. Sen. Netw.</source>
<year>2006</year>
<volume>2</volume>
<fpage>500</fpage>
<lpage>528</lpage>
<pub-id pub-id-type="doi">10.1145/1218556.1218559</pub-id>
</element-citation></ref><ref id="B36-sensors-15-05820"><label>36.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Mabrouki</surname><given-names>I.</given-names></name><name><surname>Belghith</surname><given-names>A.</given-names></name></person-group>
<article-title>E-SeRLoc: An Enhanced Serloc Localization Algorithm with Reduced Computational Complexity</article-title>
<source>Proceedings of the 9th International Wireless Communications and Mobile Computing Conference (IWCMC)</source>
<conf-loc>Sardinia, Italy</conf-loc>
<conf-date>1&#x02013;5 July 2013</conf-date>
</element-citation></ref><ref id="B37-sensors-15-05820"><label>37.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Lazos</surname><given-names>L.</given-names></name><name><surname>Poovendran</surname><given-names>R.</given-names></name></person-group>
<article-title>SeRLoc: Secure Range-Independent Localization for Wireless Sensor Networks</article-title>
<source>Proceedings of the 3rd ACM Workshop on Wireless Security</source>
<conf-date>1 October 2004</conf-date>
<publisher-name>ACM</publisher-name>
<publisher-loc>Philadelphia, PA, USA</publisher-loc>
<year>2004</year>
<fpage>21</fpage>
<lpage>30</lpage>
</element-citation></ref><ref id="B38-sensors-15-05820"><label>38.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Zheng</surname><given-names>W.</given-names></name><name><surname>Gao</surname><given-names>S.</given-names></name><name><surname>Qiu</surname><given-names>L.</given-names></name><name><surname>Zhang</surname><given-names>W.</given-names></name></person-group>
<article-title>A CDS-based Topology Control Algorithm in Energy Efficient Clustering</article-title>
<source>Proceedings of the 31st Chinese Control Conference (CCC)</source>
<conf-loc>Hefei, China</conf-loc>
<conf-date>25&#x02013;27 July 2012</conf-date>
</element-citation></ref><ref id="B39-sensors-15-05820"><label>39.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Hongwei</surname><given-names>D.</given-names></name><name><surname>Weili</surname><given-names>W.</given-names></name><name><surname>Qiang</surname><given-names>Y.</given-names></name><name><surname>Deying</surname><given-names>L.</given-names></name><name><surname>Wonjun</surname><given-names>L.</given-names></name><name><surname>Xuepeng</surname><given-names>X.</given-names></name></person-group>
<article-title>CDS-Based Virtual Backbone Construction with Guaranteed Routing Cost in Wireless Sensor Networks</article-title>
<source>IEEE Trans. Parallel Distrib. Syst.</source>
<year>2013</year>
<volume>24</volume>
<fpage>652</fpage>
<lpage>661</lpage>
<pub-id pub-id-type="doi">10.1109/TPDS.2012.177</pub-id>
</element-citation></ref><ref id="B40-sensors-15-05820"><label>40.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Abduvaliyev</surname><given-names>A.</given-names></name><name><surname>Pathan</surname><given-names>A.S.K.</given-names></name><name><surname>Jianying</surname><given-names>Z.</given-names></name><name><surname>Roman</surname><given-names>R.</given-names></name><name><surname>Wai-Choong</surname><given-names>W.</given-names></name></person-group>
<article-title>On the Vital Areas of Intrusion Detection Systems in Wireless Sensor Networks</article-title>
<source>IEEE Commun. Surv. Tutor.</source>
<year>2013</year>
<volume>15</volume>
<fpage>1223</fpage>
<lpage>1237</lpage>
<pub-id pub-id-type="doi">10.1109/SURV.2012.121912.00006</pub-id>
</element-citation></ref><ref id="B41-sensors-15-05820"><label>41.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>YangXia</surname><given-names>L.</given-names></name><name><surname>Ye</surname><given-names>G.</given-names></name></person-group>
<article-title>A Survey on Intrusion Detection of Wireless Sensor Network</article-title>
<source>Proceedings of the 2nd International Conference on Information Science and Engineering (ICISE)</source>
<conf-loc>Hangzhou, China</conf-loc>
<conf-date>4&#x02013;6 December 2010</conf-date>
</element-citation></ref><ref id="B42-sensors-15-05820"><label>42.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Abuzneid</surname><given-names>A.</given-names></name><name><surname>Sobh</surname><given-names>T.</given-names></name><name><surname>Faezipour</surname><given-names>M.</given-names></name></person-group>
<article-title>Temporal Privacy Scheme for End-to-End Location Privacy in Wireless Sensor Networks</article-title>
<source>IEEE Electrical, Electronics, Signals, Communiction &#x00026; Optimization</source>
<conf-loc>Visakhapatnam, Andhra Pradesh, India</conf-loc>
<conf-date>24&#x02013;25 January 2015</conf-date>
<fpage>2476</fpage>
<lpage>2481</lpage>
</element-citation></ref><ref id="B43-sensors-15-05820"><label>43.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Mehta</surname><given-names>K.</given-names></name><name><surname>Donggang</surname><given-names>L.</given-names></name><name><surname>Wright</surname><given-names>M.</given-names></name></person-group>
<article-title>Location Privacy in Sensor Networks Against a Global Eavesdropper</article-title>
<source>Proceedings of the IEEE International Conference on Network Protocols (ICNP)</source>
<conf-loc>Beijing, China</conf-loc>
<conf-date>16&#x02013;19 October 2007</conf-date>
</element-citation></ref><ref id="B44-sensors-15-05820"><label>44.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Alomair</surname><given-names>B.</given-names></name><name><surname>Clark</surname><given-names>A.</given-names></name><name><surname>Cuellar</surname><given-names>J.</given-names></name><name><surname>Poovendran</surname><given-names>R.</given-names></name></person-group>
<article-title>Statistical Framework for Source Anonymity in Sensor Networks</article-title>
<source>Proceedings of the IEEE Global Telecommunications Conference (GLOBECOM)</source>
<conf-loc>Miami, FL, USA</conf-loc>
<conf-date>6&#x02013;10 December 2010</conf-date>
</element-citation></ref><ref id="B45-sensors-15-05820"><label>45.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Wu</surname><given-names>P.-C.</given-names></name></person-group>
<article-title>Multiplicative, congruential random-number generators with multiplier</article-title>
<source>ACM Trans. Math. Softw.</source>
<year>1997</year>
<volume>23</volume>
<fpage>255</fpage>
<lpage>265</lpage>
<pub-id pub-id-type="doi">10.1145/264029.264056</pub-id>
</element-citation></ref><ref id="B46-sensors-15-05820"><label>46.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Deng</surname><given-names>L.-Y.</given-names></name><name><surname>Rousseau</surname><given-names>C.</given-names></name><name><surname>Yuan</surname><given-names>Y.</given-names></name></person-group>
<article-title>Generalized Lehmer-Tausworthe Random Number Generators</article-title>
<source>Proceedings of the 30th Annual Southeast Regional Conference</source>
<conf-loc>Raleigh, NC, USA</conf-loc>
<conf-date>8 April 1992</conf-date>
<fpage>108</fpage>
<lpage>115</lpage>
</element-citation></ref><ref id="B47-sensors-15-05820"><label>47.</label><element-citation publication-type="journal">
<person-group person-group-type="author"><name><surname>Payne</surname><given-names>W.H.</given-names></name><name><surname>Rabung</surname><given-names>J.R.</given-names></name><name><surname>Bogyo</surname><given-names>T.P.</given-names></name></person-group>
<article-title>Coding the Lehmer pseudo-random number generator</article-title>
<source>ACM Commun.</source>
<year>1969</year>
<volume>12</volume>
<fpage>85</fpage>
<lpage>86</lpage>
<pub-id pub-id-type="doi">10.1145/362848.362860</pub-id>
</element-citation></ref><ref id="B48-sensors-15-05820"><label>48.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Heinzelman</surname><given-names>W.R.</given-names></name><name><surname>Chandrakasan</surname><given-names>A.</given-names></name><name><surname>Balakrishnan</surname><given-names>H.</given-names></name></person-group>
<article-title>Energy-Efficient Communication Protocol for Wireless Microsensor Networks</article-title>
<source>Proceedings of the 33rd Annual Hawaii International Conference on System Sciences</source>
<conf-loc>Hawaii, HI, USA</conf-loc>
<conf-date>4&#x02013;7 January 2000</conf-date>
</element-citation></ref><ref id="B49-sensors-15-05820"><label>49.</label><element-citation publication-type="confproc">
<person-group person-group-type="author"><name><surname>Abuhelaleh</surname><given-names>M.A.</given-names></name><name><surname>Mismar</surname><given-names>T.M.</given-names></name><name><surname>Abuzneid</surname><given-names>A.A.</given-names></name></person-group>
<article-title>Armor-LEACH&#x02014;Energy Efficient, Secure Wireless Networks Communication</article-title>
<source>Proceedings of 17th International Conference on Computer Communications and Networks (ICCCN)</source>
<conf-loc>St. Thomas, USVI, USA</conf-loc>
<conf-date>3&#x02013;7 August 2008</conf-date>
</element-citation></ref><ref id="B50-sensors-15-05820"><label>50.</label><element-citation publication-type="book">
<person-group person-group-type="author"><name><surname>Stallings</surname><given-names>W.</given-names></name></person-group>
<source>Network Security Essentials Applications and Standards</source>
<edition>5th ed.</edition>
<publisher-name>Prentice Hall</publisher-name>
<publisher-loc>Upper Saddle River, NJ, USA</publisher-loc>
<year>2014</year>
</element-citation></ref></ref-list></back></article>
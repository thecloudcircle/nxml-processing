
<article article-type="research-article"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">Sci Rep</journal-id><journal-id journal-id-type="iso-abbrev">Sci Rep</journal-id><journal-title-group><journal-title>Scientific Reports</journal-title></journal-title-group><issn pub-type="epub">2045-2322</issn><publisher><publisher-name>Nature Publishing Group</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">25613754</article-id><article-id pub-id-type="pmc">4303899</article-id><article-id pub-id-type="pii">srep07982</article-id><article-id pub-id-type="doi">10.1038/srep07982</article-id><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Quantum Clock Synchronization with a Single Qudit</article-title></title-group><contrib-group><contrib contrib-type="author"><name><surname>Tavakoli</surname><given-names>Armin</given-names></name><xref ref-type="aff" rid="a1">1</xref></contrib><contrib contrib-type="author"><name><surname>Cabello</surname><given-names>Ad&#x000e1;n</given-names></name><xref ref-type="aff" rid="a2">2</xref></contrib><contrib contrib-type="author"><name><surname>&#x0017b;ukowski</surname><given-names>Marek</given-names></name><xref ref-type="aff" rid="a3">3</xref></contrib><contrib contrib-type="author"><name><surname>Bourennane</surname><given-names>Mohamed</given-names></name><xref ref-type="corresp" rid="c1">a</xref><xref ref-type="aff" rid="a1">1</xref></contrib><aff id="a1"><label>1</label><institution>Physics Department, Stockholm University</institution>, S-10691, Stockholm, <country>Sweden</country></aff><aff id="a2"><label>2</label><institution>Departamento de F&#x000ed;sica Aplicada II, Universidad de Sevilla</institution>, E-41012 Sevilla, <country>Spain</country></aff><aff id="a3"><label>3</label><institution>Instytut Fizyki Teoretycznej i Astrofizyki, Uniwersytet Gda&#x00144;ski</institution>, PL-80-952 Gda&#x00144;sk, Poland</aff></contrib-group><author-notes><corresp id="c1"><label>a</label><email>boure@fysik.su.se</email></corresp></author-notes><pub-date pub-type="epub"><day>23</day><month>01</month><year>2015</year></pub-date><pub-date pub-type="collection"><year>2015</year></pub-date><volume>5</volume><elocation-id>7982</elocation-id><history><date date-type="received"><day>10</day><month>11</month><year>2014</year></date><date date-type="accepted"><day>24</day><month>12</month><year>2014</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2015, Macmillan Publishers Limited. All rights reserved</copyright-statement><copyright-year>2015</copyright-year><copyright-holder>Macmillan Publishers Limited. All rights reserved</copyright-holder><license xmlns:xlink="http://www.w3.org/1999/xlink" license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/4.0/"><!--author-paid--><license-p>This work is licensed under a Creative Commons Attribution 4.0 International License. The images or other third party material in this article are included in the article's Creative Commons license, unless indicated otherwise in the credit line; if the material is not included under the Creative Commons license, users will need to obtain permission from the license holder in order to reproduce the material. To view a copy of this license, visit <ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link></license-p></license></permissions><abstract><p>Clock synchronization for nonfaulty processes in multiprocess networks is indispensable for a variety of technologies. A reliable system must be able to resynchronize the nonfaulty processes upon some components failing causing the distribution of incorrect or conflicting information in the network. The task of synchronizing such networks is related to Byzantine agreement (BA), which can classically be solved using recursive algorithms if and only if less than one-third of the processes are faulty. Here we introduce a nonrecursive quantum algorithm, based on a quantum solution of the detectable BA, which achieves clock synchronization in the presence of arbitrary many faulty processes by using only a single quantum system.</p></abstract></article-meta></front><body><p>In many multiprocess networks, including data transfer networks, telecommunications networks, the global positioning system, and long baseline interferometry, the individual processes need to have clocks that must be synchronized with one another<xref ref-type="bibr" rid="b1">1</xref><xref ref-type="bibr" rid="b2">2</xref>. To this purpose, individual processes' clocks must periodically be resynchronized. This motivates the need for clock synchronization algorithms which work despite the faulty behavior by some of the processes. Faulty behavior can occur due to a variety of causes, including crashing, transmission failure, and distribution of incorrect or inconsistent information in the network<xref ref-type="bibr" rid="b3">3</xref>. A clock synchronization algorithm should achieve the following tasks: C1) For any given instant, the time of all nonfaulty processes' clocks must be the same. This is necessary, but not sufficient, since simply stopping all clocks at zero satisfies C1. We therefore need to assume that a process' logical clock also keeps the rate of its corresponding physical clock. In addition, synchronizing may cause further errors, so we require that: C2) There is a small bound on the amount that a process' clock is changed during synchronization<xref ref-type="bibr" rid="b4">4</xref>.</p><p>Reliable clock synchronization algorithms can be complicated. To simplify the problem we shall work under the following assumptions<xref ref-type="bibr" rid="b4">4</xref>: A1) Initially, all clocks are synchronized to the same value. Physical clocks typically do not keep perfect time but drift with respect to one another. This motivates the following assumption: A2) All nonfaulty processes' clocks run at one second in clock time per second in real time. A general problem arises from the clocks continuously changing during the synchronization procedure. Unless the synchronization algorithm is very fast, this will cause problems. This motivates our last assumption: A3) A nonfaulty process can read the time difference between the clock of another process and its own.</p><p>A method to achieve synchronization is to use interactive consistency algorithms (ICAs) in which all nonfaulty processes reach a mutual agreement about all the clocks<xref ref-type="bibr" rid="b4">4</xref>. An ICA should satisfy that, for every process <italic>p</italic>: (1) Any two nonfaulty processes obtain the same value of process <italic>p</italic>'s clock, even if <italic>p</italic> is faulty. (2) If <italic>p</italic> is nonfaulty, then every nonfaulty process obtains the value of <italic>p</italic>'s clock. The synchronization problem can classically be solved using recursive algorithms if and only if less than one-third of the clock are faulty.</p><p>The conditions for an ICAs are similar to the ones of the problem of Byzantine Agreement (BA) in the case of which: (i) All nonfaulty processes obtain the same value and (ii) if process <italic>p</italic> is nonfaulty, then all nonfaulty processes obtain the value it sends<xref ref-type="bibr" rid="b4">4</xref><xref ref-type="bibr" rid="b5">5</xref>. Nevertheless, it has been shown that even quantum methods cannot solve the BA if one-third or more of processes are faulty<xref ref-type="bibr" rid="b6">6</xref>.</p><p>However, for most applications, including clock synchronization, it is sufficient to consider a scenario called detectable Byzantine agreement (DBA) or detectable broadcast<xref ref-type="bibr" rid="b7">7</xref><xref ref-type="bibr" rid="b8">8</xref>. In this case, conditions (i) and (ii) are replaced with: (i&#x02032;) either all nonfaulty processes obtain the same value or all abort, and (ii&#x02032;) if process <italic>p</italic> is nonfaulty, then either every nonfaulty process obtains the same value or aborts. By &#x0201c;abort&#x0201d; we mean treating the value as undefined and exiting the protocol.</p><p>Classical ICAs can only achieve DBA if less than one-third of the processes are faulty<xref ref-type="bibr" rid="b4">4</xref> and agreement is achieved by majority voting using a recursive algorithm, called <italic>OM</italic>(<italic>n</italic>), where <italic>n</italic> is the number of faulty processes. The <italic>OM</italic>(<italic>n</italic>) algorithm works as follows. We label the processes as <italic>P<sub>k</sub></italic>, with <italic>k</italic> = 1, 2, &#x02026;, <italic>m</italic>. If <italic>n</italic> = 0, then <italic>P</italic><sub>1</sub> distributes its value to every other process. Every process uses the value received from <italic>P</italic><sub>1</sub> and, in case no value is obtained, uses 0. If <italic>n</italic> &#x0003e; 0, then <italic>P</italic><sub>1</sub> distributes its value to every other process. For <italic>k</italic> = 2, &#x02026;, <italic>m</italic>, let <italic>x<sub>k</sub></italic> denote the value obtained by <italic>P<sub>k</sub></italic> from <italic>P</italic><sub>1</sub>. If <italic>P<sub>k</sub></italic> receives no message, then let <italic>x<sub>k</sub></italic> = 0. <italic>P<sub>k</sub></italic> acts as <italic>P</italic><sub>1</sub> in algorithm <italic>OM</italic>(<italic>n</italic> &#x02212; 1) by distributing <italic>x<sub>k</sub></italic> to the remaining <italic>m</italic> &#x02212; 2 processes. For every <italic>k</italic> and for all <italic>j</italic> &#x02260; <italic>k</italic>, let <italic>x<sub>j</sub></italic> be the value received by <italic>P<sub>k</sub></italic> from <italic>P<sub>j</sub></italic> using <italic>OM</italic>(<italic>n</italic> &#x02212; 1), and in case no value was received <italic>x<sub>j</sub></italic> = 0. <italic>P<sub>k</sub></italic> decides on the value obtained from the median of (<italic>x</italic><sub>1</sub>, &#x02026;, <italic>x<sub>m</sub></italic>). Thus, <italic>OM</italic>(<italic>n</italic>) requires <italic>O</italic>(<italic>m<sup>n</sup></italic><sup>+1</sup>) transmitted messages to solve the task.</p><p>The DBA is an example of a communication task for which quantum resources can provide a solution, while classical tools cannot. Nevertheless, the special case of DBA in a three process network with one faulty process, has been solved using quantum methods based on three-qutrit singlet states<xref ref-type="bibr" rid="b7">7</xref><xref ref-type="bibr" rid="b9">9</xref>, four-qubit entangled states<xref ref-type="bibr" rid="b10">10</xref>, and three<xref ref-type="bibr" rid="b8">8</xref> or two<xref ref-type="bibr" rid="b12">12</xref> pairwise quantum key distribution (QKD) channels, and experimentally demonstrated using four photon-polarization entangled state<xref ref-type="bibr" rid="b11">11</xref>.</p><p>Interestingly, later works have shown that there are quantum solutions for certain communication complexity problems and secret sharing tasks which do not require entanglement, but, instead, sequential communication of a single quantum system<xref ref-type="bibr" rid="b13">13</xref><xref ref-type="bibr" rid="b14">14</xref>. These protocols have been shown to be much more resistant to noise and imperfections, and significantly more scalable than protocols based on entanglement.</p><p>In this article, we introduce a quantum algorithm that solves the DBA and achieves clock synchronization in the presence of an arbitrary number of faulty processes, with only one single round of message passing per process independently of the number of faulty processes, utilizing only a single quantum system.</p><p>In order to solve the DBA problem, the <italic>m</italic> processes need to share data in the form of lists <italic>l<sub>k</sub></italic>, of numbers subject to specific correlations, and the distribution must be such that the list <italic>l<sub>k</sub></italic> held by process <italic>P<sub>k</sub></italic> is known only by <italic>P<sub>k</sub></italic>. Quantum mechanics provides methods to generate and securely distribute such data, here we shall seek for one which is simple, efficient, and easily extendible to an arbitrary number of processes. We assume that all processes can communicate with one another with oral messages by pairwise authenticated error-free classical channels and pairwise authenticated quantum channels.</p><sec disp-level="1"><title>Correlated lists and their use</title><p>The initial stage of the quantum protocol is to distribute lists <italic>l<sub>k</sub></italic>, for <italic>k</italic> = 1, &#x02026;, <italic>m</italic>, each of them available only to process <italic>P<sub>k</sub></italic>. All lists have to be of the same length <italic>L</italic> and are required to satisfy the property that if <italic>N</italic> = 0 (or 1) is at position <italic>j</italic> in <italic>l</italic><sub>1</sub>, then 0 (respectively, 1) is at position <italic>j</italic> in lists <italic>l<sub>k</sub></italic> for <italic>k</italic> = 2, &#x02026;, <italic>m</italic> (i.e., they are perfectly correlated). However, if <italic>N</italic> &#x02208; {2, &#x02026;, <italic>m</italic> &#x02212; 1} is at position <italic>j</italic> in <italic>l</italic><sub>1</sub>, then the sum of numbers at positions <italic>j</italic> in lists <italic>l<sub>k</sub></italic> for <italic>k</italic> = 2, &#x02026;, <italic>m</italic> equals <italic>m</italic> &#x02212; <italic>N</italic>, and all elements in these lists are either 0 or 1. Given an <italic>N</italic>, all the possible combinations of binary numbers satisfying the condition are uniformly probable.</p><p>Note that, on one hand, <italic>P</italic><sub>1</sub> has information about at which positions the lists of all other processes the values are perfectly correlated, and at which positions they are random bits, with the property that their sum is anticorrelated with the value, <italic>N</italic> &#x02265; 1, in <italic>l<sub>k</sub></italic>. On the other hand, the holder of one the lists <italic>l<sub>k</sub></italic>, with <italic>k</italic> = 2, &#x02026;, <italic>m</italic>, has no information whatsoever on whether the lists are correlated at a given position or not.</p><p>Once the processes have these lists, they can use them to achieve mutual agreement and solve the DBA by applying the algorithmic part of the protocol, which we shall call <italic>QB</italic>(<italic>n</italic>, <italic>m</italic>). The special case, <italic>QB</italic>(1, 3), reproduces the protocol in<xref ref-type="bibr" rid="b11">11</xref>.<list id="l1" list-type="order"><list-item><p><italic>P</italic><sub>1</sub> sends bit-valued messages to all processes. The message sent to process <italic>P<sub>k</sub></italic> will be denoted by <italic>m</italic><sub>1,<italic>k</italic></sub>. Together with each message, <italic>P</italic><sub>1</sub> sends a list <italic>l</italic><sub>1,<italic>k</italic></sub> of all of the positions in <italic>l</italic><sub>1</sub> in which the value <italic>m</italic><sub>1,<italic>k</italic></sub> appears. If <italic>P</italic><sub>1</sub> is nonfaulty all lists and messages are identical. The full information which <italic>P<sub>k</sub></italic> receives from <italic>P</italic><sub>1</sub> will be denoted by {<italic>m</italic><sub>1,<italic>k</italic></sub>, <italic>l</italic><sub>1,<italic>k</italic></sub>}.</p></list-item><list-item><p>The receiving processes <italic>P<sub>k</sub></italic> analyze (singlehandedly) the obtained lists and messages. If the analysis of <italic>P<sub>k</sub></italic> shows that <italic>l</italic><sub>1,<italic>k</italic></sub> is of appropriate length (i.e., about <italic>L</italic>/<italic>m</italic>) and {<italic>m</italic><sub>1,<italic>k</italic></sub>, <italic>l</italic><sub>1,<italic>k</italic></sub>} is consistent with <italic>l<sub>k</sub></italic> at all positions, then if <italic>P<sub>k</sub></italic> is nonfaulty, it conveys {<italic>m</italic><sub>1,<italic>k</italic></sub>, <italic>l</italic><sub>1,<italic>k</italic></sub>} to all other processes <italic>P<sub>k</sub></italic><sub>&#x02260;1</sub>. A faulty process sends a flipped bit value of the message with whatever list it chooses. The full information which <italic>P<sub>j</sub></italic> receives from <italic>P<sub>k</sub></italic> will be denoted by {<italic>m<sub>k</sub></italic><sub>,<italic>j</italic></sub>, <italic>l<sub>k</sub></italic><sub>,<italic>j</italic></sub>}.A nonfaulty <italic>P<sub>k</sub></italic> will also decide on the final bit value it adopts <italic>V<sub>k</sub></italic>. This is <italic>m</italic><sub>1,<italic>k</italic></sub>, unless messages from the other processes force it to decide that <italic>P</italic><sub>1</sub> is faulty. However, if {<italic>m</italic><sub>1,<italic>k</italic></sub>, <italic>l</italic><sub>1,<italic>k</italic></sub>} is not consistent with <italic>l<sub>k</sub></italic>, then <italic>P<sub>k</sub></italic> immediately ascertains that <italic>P</italic><sub>1</sub> is faulty and relays to other processes neither 0 nor 1 but &#x022a5;, meaning &#x0201c;I have received inconsistent data.&#x0201d;</p></list-item><list-item><p>Once all messages have been exchanged between <italic>P</italic><sub>2</sub>, &#x02026;, <italic>P<sub>m</sub></italic>, each process considers the obtained data and acts according to the instructions in <xref ref-type="table" rid="t1">Table 1</xref>. The overall aim is, if <italic>P</italic><sub>1</sub> is nonfaulty, to have the same value of <italic>V<sub>k</sub></italic> for all nonfaulty processes, or all of them aborting.</p></list-item></list></p></sec><sec disp-level="1"><title>Quantum protocol for distributing lists l<sub>k</sub></title><p>All processes are equipped with devices which can unitarily transform qudits. In addition, <italic>P</italic><sub>1</sub> has a source of <italic>single qudits of dimension m</italic> and the last process, <italic>P<sub>m</sub></italic>, has <italic>additionally</italic> a measurement device. The protocol runs as follows (for an illustration, see <xref ref-type="fig" rid="f1">Fig. 1</xref>):<list id="l3" list-type="roman-upper"><list-item><p><italic>P</italic><sub>1</sub> prepares the state<inline-formula id="m1"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e844" xlink:href="srep07982-m1.jpg"/></inline-formula></p></list-item><list-item><p><italic>P</italic><sub>1</sub> randomly chooses the &#x0201c;encoding basis&#x0201d; from <italic>m</italic> different options <italic>U</italic><sub>0</sub>,...,<italic>U</italic><sub><italic>m</italic>&#x02212;1</sub> and labels the choice <italic>c</italic><sub>1</sub>. Having chosen the <italic>c</italic><sub>1</sub>&#x02019;st encoding basis, process <italic>P</italic><sub>1</sub> applies the following unitary transformation to the qudit:<inline-formula id="m2"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e888" xlink:href="srep07982-m2.jpg"/></inline-formula>where <inline-formula id="m9"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e893" xlink:href="srep07982-m9.jpg"/></inline-formula>. From the interferometric point of view, applying <italic>U<sub>c<sub>1</sub></sub></italic> introduces a phase-shift of &#x02212;2<italic>&#x003c0;</italic><italic>c</italic><sub>1</sub>/<italic>m</italic> in the first beam.</p></list-item><list-item><p>After that, <italic>P</italic><sub>1</sub> randomly chooses a value <italic>N</italic><sub>1</sub> in the set {0, 1, &#x02026;, <italic>m</italic> &#x02212; 1} and encodes <italic>N</italic><sub>1</sub>, by applying the following unitary transformation:<inline-formula id="m3"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e937" xlink:href="srep07982-m3.jpg"/></inline-formula>Afterwards, the qudit is sent to <italic>P</italic><sub>2</sub>.</p></list-item><list-item><p><italic>P</italic><sub>2</sub>, in the same manner as <italic>P</italic><sub>1</sub>, choses a <italic>c</italic><sub>2</sub>&#x02208;{0,...,<italic>m</italic>&#x02212;1} and applies the unitary <italic>U</italic><sub><italic>c</italic><sub>2</sub></sub> corresponding to choice of encoding basis.</p></list-item><list-item><p>Next, <italic>P</italic><sub>2</sub> randomly chooses a value <italic>N</italic><sub>2</sub> in the set {0, 1}. If <italic>N</italic><sub>2</sub> = 0, no action is taken, i.e., <italic>P</italic><sub>2</sub> applies the transformation <inline-formula id="m10"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e998" xlink:href="srep07982-m10.jpg"/></inline-formula>. If <italic>N</italic><sub>2</sub> = 1, then <italic>P</italic><sub>2</sub> applies <italic>U</italic>(<italic>N</italic><sub>2</sub> = 1) and then sends the qudit to <italic>P</italic><sub>3</sub>.</p></list-item><list-item><p><italic>P</italic><sub>3</sub>, &#x02026;, <italic>P<sub>m</sub></italic> consecutively repeat the same procedure as <italic>P</italic><sub>2</sub> with independent choices of basis and encoding their respective random values <italic>N</italic><sub>3</sub>, &#x02026;, <italic>N<sub>m</sub></italic>.</p></list-item><list-item><p>In addition, <italic>P<sub>m</sub></italic> measures the qudit using a device which distinguishes the state |<italic>&#x003c8;</italic><sub>0</sub>&#x03009; from any set of states orthogonal to it.</p></list-item><list-item><p>If <italic>P<sub>m</sub></italic> obtains |<italic>&#x003c8;</italic><sub>0</sub>&#x03009;, then the processes consecutively reveal their encoding bases (but not their values <italic>N<sub>k</sub></italic>) in reverse order: First <italic>P<sub>m</sub></italic> and last <italic>P</italic><sub>1</sub>. If it turns out that the sum of the basis choices modulo <italic>m</italic> equals zero, then the run is treated as a valid distribution of the numbers <italic>N<sub>k</sub></italic> at the same position in the private lists <italic>l<sub>k</sub></italic>.</p></list-item></list></p><p>The protocol distributes the numbers in the required way because all the unitary operators are diagonal and, therefore, commute. Additionally, if <inline-formula id="m44"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1107" xlink:href="srep07982-m44.jpg"/></inline-formula> then<inline-formula id="m4"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1112" xlink:href="srep07982-m4.jpg"/></inline-formula>and, if <inline-formula id="m11"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1117" xlink:href="srep07982-m11.jpg"/></inline-formula>, modulo <italic>m</italic>, then <disp-formula id="m5"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1124" xlink:href="srep07982-m5.jpg"/></disp-formula></p><p>Whenever this condition is not satisfied, the final state of the system is orthogonal to |<italic>&#x003c8;</italic><sub>0</sub>&#x03009; and will therefore never be an outcome of <italic>P<sub>m</sub></italic>'s measurement.</p></sec><sec disp-level="1"><title>Clock synchronization</title><p>Now, we will show how to apply our method for solving the DBA to achieve fault tolerant clock synchronization. However, a problem arises from clocks ticking during the synchronization procedure. This is solved by exploiting assumption A3: Instead of sending a number, the processes send their clock differences to each other. In the classical case, we achieve clock synchronization by running the algorithm <italic>OM</italic>(1) <italic>m</italic> times, sending clock differences instead of the binary values, and analogously for <italic>OM</italic>(<italic>n</italic>)<xref ref-type="bibr" rid="b4">4</xref>. In analogy with the classical case, the processes send clock differences also in the quantum case, exploiting the fact that the clock differences can be decomposed into binary strings up to arbitrary accuracy agreed upon in advance. We run <italic>QB</italic>(<italic>n</italic>, <italic>m</italic>) <italic>m</italic> times in such a way that for each run a new processes takes the roll of <italic>P</italic><sub>1</sub> in <italic>QB</italic>(<italic>n</italic>, <italic>m</italic>). More explicitly, <italic>P<sub>y</sub></italic> reads the clock difference &#x00394;<italic><sub>xy</sub></italic> between its own clock and the clock of <italic>P<sub>x</sub></italic>. If <italic>P<sub>y</sub></italic> is nonfaulty it will relay &#x00394;<italic><sub>xy</sub></italic> to <italic>P<sub>z</sub></italic> but if <italic>P<sub>y</sub></italic> is a faulty process, it can arbitrarily change &#x00394;<italic><sub>xy</sub></italic> before sending it. If <italic>P<sub>y</sub></italic> relays the value obtained from <italic>P<sub>x</sub></italic> to <italic>P<sub>z</sub></italic>, then <italic>P<sub>z</sub></italic> knows the time difference between <italic>P<sub>x</sub></italic> and <italic>P<sub>y</sub></italic>. Also, since <italic>QB</italic>(<italic>n</italic>, <italic>m</italic>) is ran <italic>m</italic> times, <italic>P<sub>z</sub></italic> will also obtain &#x00394;<italic><sub>yz</sub></italic> from <italic>P<sub>y</sub></italic> and thus <italic>P<sub>z</sub></italic> knows that <italic>P<sub>y</sub></italic> is claiming that the time difference between <italic>P<sub>x</sub></italic> and <italic>P<sub>z</sub></italic> is &#x00394;<italic><sub>xy</sub></italic> + &#x00394;<italic><sub>yz</sub></italic>, which can then be compared to &#x00394;<italic><sub>xz</sub></italic> obtained directly from <italic>P<sub>x</sub></italic>.</p></sec><sec disp-level="1"><title>Comparison with the other solutions</title><p>The correlated lists needed for achieving DBA can be distributed by other means than with the single-qudit protocol. Successful distribution can be achieved by the process <italic>P<sub>m</sub></italic> sharing a QKD channel with every other process. <italic>P<sub>m</sub></italic> uses a QKD protocol, e.g., BB84<xref ref-type="bibr" rid="b17">17</xref> to distribute numbers such that (1) <italic>P<sub>m</sub></italic> and <italic>P</italic><sub>1</sub> share a string <inline-formula id="m12"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1348" xlink:href="srep07982-m12.jpg"/></inline-formula>, where <inline-formula id="m13"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1351" xlink:href="srep07982-m13.jpg"/></inline-formula>. (2) For every <italic>l</italic> = 2, &#x02026;, <italic>m</italic> &#x02212; 1, <italic>P<sub>m</sub></italic> and <italic>P<sub>l</sub></italic> share a string <inline-formula id="m14"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1371" xlink:href="srep07982-m14.jpg"/></inline-formula> such that <inline-formula id="m15"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1374" xlink:href="srep07982-m15.jpg"/></inline-formula>. (3) For a given <italic>j</italic>, the lists satisfy <inline-formula id="m16"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1380" xlink:href="srep07982-m16.jpg"/></inline-formula>. (4) None of <italic>P</italic><sub>2</sub>, &#x02026;, <italic>P<sub>m</sub></italic><sub>&#x02212;1</sub> have any information about a particular list element of any other process. (5) Whenever <italic>P</italic><sub>1</sub> receives an element <inline-formula id="m17"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1401" xlink:href="srep07982-m17.jpg"/></inline-formula>, <italic>P</italic><sub>1</sub> has no information on the bit value of <inline-formula id="m18"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1410" xlink:href="srep07982-m18.jpg"/></inline-formula> for <italic>l</italic> = 2, &#x02026;, <italic>m</italic>, and whenever <italic>P</italic><sub>1</sub> receives <inline-formula id="m19"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1424" xlink:href="srep07982-m19.jpg"/></inline-formula>, <italic>P</italic><sub>1</sub> knows that <inline-formula id="m20"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1433" xlink:href="srep07982-m20.jpg"/></inline-formula> for all <italic>l</italic> = 2, &#x02026;, <italic>m</italic>. All QKD channels except that shared between <italic>P</italic><sub>1</sub> and <italic>P<sub>m</sub></italic> transmit bit values. In order to transmit elements of {0, &#x02026;, <italic>m</italic> &#x02212; 1} to <italic>P</italic><sub>1</sub>, the numbers must be encoded into <inline-formula id="m21"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1461" xlink:href="srep07982-m21.jpg"/></inline-formula> qubits. One additional requirement that has to be made for solving the DBA using the QKD distributed lists is that <italic>P<sub>m</sub></italic> is not required to convey any lists. This is necessary since <italic>P<sub>m</sub></italic> has full knowledge about the lists of all other processes and therefore easily could cheat. Instead, <italic>P<sub>m</sub></italic> may announce the message it received from <italic>P</italic><sub>1</sub>, and if any inconsistency is noted by <italic>P</italic><sub>2</sub>, &#x02026;, <italic>P<sub>m</sub></italic><sub>&#x02212;1</sub>, then <italic>P<sub>m</sub></italic> will change its final value if the other processes convince <italic>P<sub>m</sub></italic> of them being nonfaulty.</p><p>There are also other proposed solutions to the DBA considering three processes where one is faulty. The first one, proposed in Ref. <xref ref-type="bibr" rid="b7">7</xref>, relies on the three qutrit entangled Aharonov state. The goal is to distribute lists given by all permutations of the elements of the set {0, 1, 2}, i.e., (0&#x02013;1&#x02013;2, 0&#x02013;2&#x02013;1, 1&#x02013;0&#x02013;2, 1&#x02013;2&#x02013;0, 2&#x02013;0&#x02013;1, and 2&#x02013;1&#x02013;0). Generalization to <italic>m</italic> parties along the lines of Ref. <xref ref-type="bibr" rid="b7">7</xref> would require the usage of multipartite <italic>m</italic>-level entanglement, provided by the state <disp-formula id="m6"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1522" xlink:href="srep07982-m6.jpg"/></disp-formula> where <inline-formula id="m22"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1526" xlink:href="srep07982-m22.jpg"/></inline-formula>, <italic>S<sub>m</sub></italic> = {0, &#x02026;, <italic>m</italic> &#x02212; 1} and <italic>N</italic>(<italic>&#x003c3;</italic>(<italic>S<sub>m</sub></italic>)) is the parity of the permutation of <italic>S<sub>m</sub></italic>. Already for the simplest case of <italic>m</italic> = 3, this approach requires the preparation of a very complex state which, to our knowledge, has not yet been experimentally realized. However, for the three process case, it has been pointed out in Ref. <xref ref-type="bibr" rid="b12">12</xref> that the distribution of the lists can be realized without the state (6), by utilizing two separated QKD channels. With small modification for the <italic>m</italic> process setting, distribution of the lists is achieved with <italic>m</italic> &#x02212; 1 QKD channels. However, to encode the entire space provided by <italic>S<sub>m</sub></italic>, the QKD requires <inline-formula id="m23"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1572" xlink:href="srep07982-m23.jpg"/></inline-formula> qubits. If the efficiency of a detector <italic>&#x003b7;</italic> is not perfect and the QKD is performed with single qubits using von Neuman measurements, successful distribution occurs only with probability <inline-formula id="m24"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1578" xlink:href="srep07982-m24.jpg"/></inline-formula>. Typically, the classical part of the protocol in Ref. <xref ref-type="bibr" rid="b7">7</xref> and its possible generalizations scale rapidly with the number of processes. It is required that <italic>m</italic>! different types of lists are distributed. However, a solution to the three party DBA exploiting four-qubit entanglement provides a simpler classical part of the protocol: the number of different lists is lowered from six to four<xref ref-type="bibr" rid="b11">11</xref>.</p><p>The general <italic>m</italic> process protocol presented in this paper generalizes the protocol in Ref. <xref ref-type="bibr" rid="b11">11</xref> and requires 2<italic><sup>m</sup></italic><sup>&#x02212;1</sup> different types of lists. As emphasized earlier, the distribution of the required lists can be achieved both with single-qudit and with <italic>m</italic> &#x02212; <bold>1</bold> QKD channels. Using QKD channels, only one channel needs to transmit all elements in <italic>S<sub>m</sub></italic> while the remaining <italic>m</italic> &#x02212; 2 channels only transmit bit values. In the presence of nonperfect detectors, successful distribution occurs with probability <inline-formula id="m25"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1618" xlink:href="srep07982-m25.jpg"/></inline-formula>. However, in the single-qudit approach only one single detection is needed and, therefore, successful distribution of the lists occur with probability <italic>&#x003b7;</italic> independently of <italic>m</italic>. The single-qudit protocol is highly scalable, both in terms of success probability with inefficient detectors and requirements on the classical lists.</p></sec><sec disp-level="1" sec-type="conclusions"><title>Conclusions</title><p>We have presented a single-qudit protocol which provides an efficient solution to an important multiparty communication problem: It solves DBA and achieves clock synchronization in the presence of arbitrary many faulty clocks. In principle, our quantum algorithm is not limited to the case of clock synchronization, it can with small adaptation be used for other tasks requiring oral message interactive consistency. Interestingly, our algorithm works by transmitting a single qudit among the parties rather than by distributing a quantum entangled state among them. This makes the protocol much more practical, as single qudits can be experimentally realized easily in many ways. For example, using unbiased multiport beamsplitters<xref ref-type="bibr" rid="b15">15</xref> or time-bin<xref ref-type="bibr" rid="b16">16</xref>. Compared to schemes based on several QKD channels, the single-qubit protocol is more scalable and robust against detection inefficiencies. This results shows that single-qudit quantum information protocols are interesting beyond QKD<xref ref-type="bibr" rid="b18">18</xref><xref ref-type="bibr" rid="b19">19</xref> and random number generation<xref ref-type="bibr" rid="b20">20</xref><xref ref-type="bibr" rid="b21">21</xref>, and should stimulate experimental implementations and further research in quantum information protocols.</p></sec><sec disp-level="1"><title>Author Contributions</title><p>A.C., M.Z. and M.B. proposed and initiated the project. A.T. performed the analysis and the extension for n parties. All authors discussed the results, agreed on the conclusions, and wrote the manuscript.</p></sec></body><back><ack><p>This project was supported by the Swedish Research Council, ADOPT, the Project No. FIS2011-29400 (MINECO, Spain) with FEDER funds, the FQXi large grant project &#x0201c;The Nature of Information in Sequential Quantum Measurements,&#x0201d; MNiSW Grant No. IdP2011 000361 (Ideas Plus) and Foundation for Polish Science TEAM project co-financed by the EU European Regional Development Fund.</p></ack><ref-list><ref id="b1"><mixed-citation publication-type="journal"><name><surname>Simons</surname><given-names>B.</given-names></name>, <name><surname>Welch</surname><given-names>J. L.</given-names></name> &#x00026; <name><surname>Lynch</surname><given-names>N.</given-names></name>
<article-title>An overview of clock synchronization</article-title>. <source>Fault-Tolerant Distributed Computing, Lecture Notes in Computer Science</source>
<volume>448</volume>, <fpage>84</fpage>&#x02013;<lpage>96</lpage> (Spinger, New York <year>1990</year>).</mixed-citation></ref><ref id="b2"><mixed-citation publication-type="journal"><name><surname>Lewandowski</surname><given-names>W.</given-names></name>, <name><surname>Azoubib</surname><given-names>J.</given-names></name> &#x00026; <name><surname>Klepczynski</surname><given-names>W. J.</given-names></name>
<article-title>GPS: Primary tool for time transfer</article-title>. <source>Proc. IEEE</source>
<volume>87</volume>, <fpage>163</fpage>&#x02013;<lpage>172</lpage> (<year>1999</year>).</mixed-citation></ref><ref id="b3"><mixed-citation publication-type="book"><name><surname>Lamport</surname><given-names>L.</given-names></name> &#x00026; <name><surname>Melliar-Smith</surname><given-names>M.</given-names></name>
<article-title>Byzantine Clock Synchronization</article-title>. <source>Proc. of the 3rd Ann. ACM Symposium on Principles of Distributed Computing (PODC 1984),</source>
<fpage>68</fpage>&#x02013;<lpage>74</lpage> (ACM Press, New York, <year>1984</year>).</mixed-citation></ref><ref id="b4"><mixed-citation publication-type="journal"><name><surname>Lamport</surname><given-names>L.</given-names></name> &#x00026; <name><surname>Melliar-Smith</surname><given-names>M.</given-names></name>
<article-title>Synchronizing clocks in the presence of faults</article-title>. <source>J. ACM</source>
<volume>32</volume>, <fpage>52</fpage>&#x02013;<lpage>78</lpage> (<year>1985</year>).</mixed-citation></ref><ref id="b5"><mixed-citation publication-type="journal"><name><surname>Lamport</surname><given-names>L.</given-names></name>, <name><surname>Shostak</surname><given-names>R.</given-names></name> &#x00026; <name><surname>Pease</surname><given-names>M.</given-names></name>
<article-title>The Byzantine generals problem</article-title>. <source>ACM Trans. Programming Languages and Syst.</source>
<volume>4</volume>, <fpage>382</fpage>&#x02013;<lpage>401</lpage> (<year>1982</year>).</mixed-citation></ref><ref id="b6"><mixed-citation publication-type="journal"><name><surname>Fitzi</surname><given-names>M.</given-names></name>, <name><surname>Garay</surname><given-names>J. A.</given-names></name>, <name><surname>Maurer</surname><given-names>U.</given-names></name> &#x00026; <name><surname>Ostrovsky</surname><given-names>R.</given-names></name>
<article-title>Minimal complete primitives for unconditional multi-party computation</article-title>. <source>Advances in Cryptography - CRYPTO '01, Lecture Notes in Computer Science</source>
<volume>2139</volume>, <fpage>80</fpage>&#x02013;<lpage>100</lpage> (Springer, Berlin, <year>2001</year>).</mixed-citation></ref><ref id="b7"><mixed-citation publication-type="journal"><name><surname>Fitzi</surname><given-names>M.</given-names></name>, <name><surname>Gisin</surname><given-names>N.</given-names></name> &#x00026; <name><surname>Maurer</surname><given-names>U.</given-names></name>
<article-title>A quantum solution to the Byzantine agreement problem</article-title>. <source>Phys. Rev. Lett.</source>
<volume>87</volume>, <fpage>217901</fpage> (<year>2001</year>).<pub-id pub-id-type="pmid">11736379</pub-id></mixed-citation></ref><ref id="b8"><mixed-citation publication-type="book"><name><surname>Fitzi</surname><given-names>M.</given-names></name>, <name><surname>Gottesman</surname><given-names>D.</given-names></name>, <name><surname>Hirt</surname><given-names>M.</given-names></name>, <name><surname>Holenstein</surname><given-names>T.</given-names></name> &#x00026; <name><surname>Smith</surname><given-names>A.</given-names></name>
<article-title>Detectable Byzantine agreement secure against faulty majorities</article-title>. <source>21th ACM Symposium on Principles of Distributed Computing (PODC 2002),</source>
<fpage>118</fpage>&#x02013;<lpage>126</lpage> (ACM Press, New York, <year>2002</year>).</mixed-citation></ref><ref id="b9"><mixed-citation publication-type="journal"><name><surname>Cabello</surname><given-names>A.</given-names></name>
<article-title><italic>N</italic>-particle <italic>N</italic>-level singlet states: Some properties and applications</article-title>. <source>Phys. Rev. Lett.</source>
<volume>89</volume>, <fpage>100402</fpage> (<year>2002</year>).<pub-id pub-id-type="pmid">12225176</pub-id></mixed-citation></ref><ref id="b10"><mixed-citation publication-type="journal"><name><surname>Cabello</surname><given-names>A.</given-names></name>
<article-title>Solving the liar detection problem using the four-qubit singlet state</article-title>. <source>Phys. Rev. A</source>
<volume>68</volume>, <fpage>012304</fpage> (<year>2003</year>).</mixed-citation></ref><ref id="b11"><mixed-citation publication-type="journal"><name><surname>Gaertner</surname><given-names>S.</given-names></name>, <name><surname>Bourennane</surname><given-names>M.</given-names></name>, <name><surname>Kurtsiefer</surname><given-names>C.</given-names></name>, <name><surname>Cabello</surname><given-names>A.</given-names></name> &#x00026; <name><surname>Weinfurter</surname><given-names>H.</given-names></name>
<article-title>Experimental demonstration of a quantum protocol for Byzantine Agreement and Liar Detection</article-title>. <source>Phys. Rev. Lett.</source>
<volume>100</volume>, <fpage>070504</fpage> (<year>2008</year>).<pub-id pub-id-type="pmid">18352533</pub-id></mixed-citation></ref><ref id="b12"><mixed-citation publication-type="journal"><name><surname>Iblisdir</surname><given-names>S.</given-names></name> &#x00026; <name><surname>Gisin</surname><given-names>N.</given-names></name>
<article-title>Byzantine agreement with two quantum key distribution setups</article-title>. <source>Phys. Rev. A</source>
<volume>70</volume>, <fpage>034306</fpage> (<year>2005</year>).</mixed-citation></ref><ref id="b13"><mixed-citation publication-type="journal"><name><surname>Schmid</surname><given-names>C.</given-names></name>, <name><surname>Trojek</surname><given-names>P.</given-names></name>, <name><surname>Bourennane</surname><given-names>M.</given-names></name>, <name><surname>Kurtsiefer</surname><given-names>C.</given-names></name>, <name><surname>&#x0017b;ukowski</surname><given-names>M.</given-names></name> &#x00026; <name><surname>Weinfurter</surname><given-names>H.</given-names></name>
<article-title>Experimental single qubit quantum secret sharing</article-title>. <source>Phys. Rev. Lett.</source>
<volume>95</volume>, <fpage>230505</fpage> (<year>2005</year>).<pub-id pub-id-type="pmid">16384288</pub-id></mixed-citation></ref><ref id="b14"><mixed-citation publication-type="journal"><name><surname>Trojek</surname><given-names>P.</given-names></name>, <name><surname>Schmid</surname><given-names>C.</given-names></name>, <name><surname>Bourennane</surname><given-names>M.</given-names></name>, <name><surname>Brukner</surname><given-names>&#x0010c;.</given-names></name>, <name><surname>&#x0017b;ukowski</surname><given-names>M.</given-names></name> &#x00026; <name><surname>Weinfurter</surname><given-names>H.</given-names></name>
<article-title>Experimental quantum communication complexity</article-title>. <source>Phys. Rev. A</source>
<volume>72</volume>, <fpage>050305</fpage> (<year>2005</year>).</mixed-citation></ref><ref id="b15"><mixed-citation publication-type="journal"><name><surname>&#x0017b;ukowski</surname><given-names>M.</given-names></name>, <name><surname>Zeilinger</surname><given-names>A.</given-names></name> &#x00026; <name><surname>Horne</surname><given-names>M. A.</given-names></name>
<article-title>Realizable higher-dimensional two-particle entanglements via multiport beam splitters</article-title>. <source>Phys. Rev. A</source>
<volume>55</volume>, <fpage>2564</fpage> (<year>1997</year>).</mixed-citation></ref><ref id="b16"><mixed-citation publication-type="journal"><name><surname>Marcikic</surname><given-names>I.</given-names></name>, <name><surname>de Riedmatten</surname><given-names>H.</given-names></name>, <name><surname>Tittel</surname><given-names>W.</given-names></name>, <name><surname>Scarani</surname><given-names>V.</given-names></name>, <name><surname>Zbinden</surname><given-names>H.</given-names></name> &#x00026; <name><surname>Gisin</surname><given-names>N.</given-names></name>
<article-title>Time-bin entangled qubits for quantum communication created by femtosecond pulses</article-title>. <source>Phys. Rev. A</source>
<volume>66</volume>, <fpage>062308</fpage> (<year>2002</year>).</mixed-citation></ref><ref id="b17"><mixed-citation publication-type="journal"><name><surname>Bennett</surname><given-names>C. H.</given-names></name> &#x00026; <name><surname>Brassard</surname><given-names>G.</given-names></name>
<source>Proceedings of the International Conference on Computers, Systems and Signal Processing, Bangalore, 1984</source>, <fpage>175</fpage>&#x02013;<lpage>179</lpage> (<year>1984</year>).</mixed-citation></ref><ref id="b18"><mixed-citation publication-type="journal"><name><surname>Cerf</surname><given-names>N. J.</given-names></name>, <name><surname>Bourennane</surname><given-names>M.</given-names></name>, <name><surname>Karlsson</surname><given-names>A.</given-names></name> &#x00026; <name><surname>Gisin</surname><given-names>N.</given-names></name>
<article-title>Security of quantum key distribution using <italic>d</italic>-level systems</article-title>. <source>Phys. Rev. Lett.</source>
<volume>88</volume>, <fpage>127902</fpage> (<year>2002</year>).<pub-id pub-id-type="pmid">11909502</pub-id></mixed-citation></ref><ref id="b19"><mixed-citation publication-type="journal"><name><surname>Cabello</surname><given-names>A.</given-names></name>, <name><surname>D'Ambrosio</surname><given-names>V.</given-names></name>, <name><surname>Nagali</surname><given-names>E.</given-names></name> &#x00026; <name><surname>Sciarrino</surname><given-names>F.</given-names></name>
<article-title>Hybrid ququart-encoded quantum cryptography protected by Kochen-Specker contextuality</article-title>. <source>Phys. Rev. A</source>
<volume>84</volume>, <fpage>030302(R)</fpage> (<year>2011</year>).</mixed-citation></ref><ref id="b20"><mixed-citation publication-type="journal"><name><surname>Svozil</surname><given-names>K.</given-names></name>
<article-title>Three criteria for quantum random-number generators based on beam splitters</article-title>. <source>Phys. Rev. A</source>
<volume>79</volume>, <fpage>054306</fpage> (<year>2009</year>).</mixed-citation></ref><ref id="b21"><mixed-citation publication-type="journal"><name><surname>Um</surname><given-names>M.</given-names></name>
<italic>et al.</italic>
<article-title>Experimental certification of random numbers via quantum contextuality</article-title>. <source>Sci. Rep.</source>
<volume>3</volume>, <fpage>1627</fpage> (<year>2013</year>).<pub-id pub-id-type="pmid">23568082</pub-id></mixed-citation></ref></ref-list></back><floats-group><fig id="f1"><label>Figure 1</label><caption><title>Scheme of the quantum protocol for the distribution of the correlated lists.</title><p><italic>P</italic><sub>1</sub> prepares a uniform <italic>d</italic>-level superposition state, makes a choice of basis and encoding, and forwards the qudit to <italic>P</italic><sub>2</sub> which applies a choice a basis and encoding and forwards the qudit to <italic>P</italic><sub>3</sub>. Processes <italic>P</italic><sub>3</sub>, &#x02026;, <italic>P<sub>m</sub></italic> act in analogy with <italic>P</italic><sub>2</sub>. Finally <italic>P<sub>m</sub></italic> projects the state onto the initial state prepared by <italic>P</italic><sub>1</sub> and, if the outcome is 1, the processes reveal their bases and, if all bases are the same, the round is treated as valid.</p></caption><graphic xmlns:xlink="http://www.w3.org/1999/xlink" xlink:href="srep07982-f1"/></fig><table-wrap position="float" id="t1"><label>Table 1</label><caption><title>Once <italic>P<sub>k</sub></italic> receives all messages and lists from all other processes, it will study the obtained lists and messages and compare to its own list <italic>l<sub>k</sub></italic>. Depending on the consistency between the obtained and private data, <italic>P<sub>k</sub></italic> will act according to table below. Notation <inline-formula id="m26"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1715" xlink:href="srep07982-m26.jpg"/></inline-formula> means that <italic>m<sub>j,k</sub></italic> and <italic>l<sub>j,k</sub></italic> are found to be consistent with <italic>l<sub>k</sub></italic> whereas <inline-formula id="m27"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1734" xlink:href="srep07982-m27.jpg"/></inline-formula> means &#x0201c;inconsistent with.&#x0201d; The symbol &#x022a5; means &#x0201c;I have received inconsistent data.&#x0201d; By <inline-formula id="m28"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1737" xlink:href="srep07982-m28.jpg"/></inline-formula> we denote some nonempty subset of {1, &#x02026;, <italic>m</italic>} \ {<italic>k</italic>}</title></caption><table frame="hsides" rules="groups" border="1"><colgroup><col align="left"/><col align="center"/><col align="center"/></colgroup><thead valign="bottom"><tr><th align="left" valign="top" charoff="50">&#x000a0;</th><th align="center" valign="top" charoff="50">local analysis of all data received by <italic>P<sub>k</sub></italic></th><th align="center" valign="top" charoff="50">decision of <italic>P<sub>k</sub></italic> on the value <italic>V<sub>k</sub></italic></th></tr></thead><tbody valign="top"><tr><td align="justify" valign="top" charoff="50">(iia)</td><td align="justify" valign="top" charoff="50"><inline-formula id="m29"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1775" xlink:href="srep07982-m29.jpg"/></inline-formula>, <inline-formula id="m30"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1778" xlink:href="srep07982-m30.jpg"/></inline-formula> and all messages are equal</td><td align="justify" valign="top" charoff="50"><italic>V<sub>k</sub></italic> = <italic>m</italic><sub>1,<italic>k</italic></sub>, no faulty process</td></tr><tr><td align="justify" valign="top" charoff="50">(iib)</td><td align="justify" valign="top" charoff="50"><inline-formula id="m31"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1798" xlink:href="srep07982-m31.jpg"/></inline-formula>, <inline-formula id="m32"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1801" xlink:href="srep07982-m32.jpg"/></inline-formula> and <italic>not</italic> all messages are equal</td><td align="justify" valign="top" charoff="50">as <italic>P</italic><sub>1</sub> is faulty, <italic>V<sub>k</sub></italic> = <italic>abort</italic></td></tr><tr><td align="justify" valign="top" charoff="50">(iic)</td><td align="justify" valign="top" charoff="50"><inline-formula id="m33"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1825" xlink:href="srep07982-m33.jpg"/></inline-formula>, <inline-formula id="m34"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1828" xlink:href="srep07982-m34.jpg"/></inline-formula> and <inline-formula id="m35"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1831" xlink:href="srep07982-m35.jpg"/></inline-formula>, <inline-formula id="m36"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1834" xlink:href="srep07982-m36.jpg"/></inline-formula></td><td align="justify" valign="top" charoff="50"><italic>V<sub>k</sub></italic> = <italic>m<sub>j,k</sub></italic>, for <inline-formula id="m37"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1847" xlink:href="srep07982-m37.jpg"/></inline-formula>, as the other <italic>P<sub>j</sub></italic>'s are faulty</td></tr><tr><td align="justify" valign="top" charoff="50">(iid)</td><td align="justify" valign="top" charoff="50"><inline-formula id="m38"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1859" xlink:href="srep07982-m38.jpg"/></inline-formula>, <inline-formula id="m39"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1862" xlink:href="srep07982-m39.jpg"/></inline-formula> and <inline-formula id="m40"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1865" xlink:href="srep07982-m40.jpg"/></inline-formula></td><td align="justify" valign="top" charoff="50"><italic>V<sub>k</sub></italic> = <italic>m</italic><sub>1,<italic>k</italic></sub>, although <italic>P</italic><sub>1</sub> could be faulty</td></tr><tr><td align="justify" valign="top" charoff="50">(iie)</td><td align="justify" valign="top" charoff="50"><inline-formula id="m41"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1889" xlink:href="srep07982-m41.jpg"/></inline-formula>, <inline-formula id="m42"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1892" xlink:href="srep07982-m42.jpg"/></inline-formula>, but with unequal messages, and &#x022a5; from <inline-formula id="m43"><inline-graphic xmlns:xlink="http://www.w3.org/1999/xlink" id="d33e1895" xlink:href="srep07982-m43.jpg"/></inline-formula></td><td align="justify" valign="top" charoff="50"><italic>V<sub>k</sub></italic> = <italic>abort</italic>, at least <italic>P</italic><sub>1</sub> is faulty</td></tr></tbody></table></table-wrap></floats-group></article>
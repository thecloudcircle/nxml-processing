
<article xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:mml="http://www.w3.org/1998/Math/MathML" article-type="research-article" xml:lang="en"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-id journal-id-type="iso-abbrev">BMC Bioinformatics</journal-id><journal-title-group><journal-title>BMC Bioinformatics</journal-title></journal-title-group><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">23095524</article-id><article-id pub-id-type="pmc">3439727</article-id><article-id pub-id-type="publisher-id">1471-2105-13-S14-S8</article-id><article-id pub-id-type="doi">10.1186/1471-2105-13-S14-S8</article-id><article-categories><subj-group subj-group-type="heading"><subject>Research</subject></subj-group></article-categories><title-group><article-title>GapFiller: a de novo assembly approach to fill the gap within paired reads</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" id="A1"><name><surname>Nadalin</surname><given-names>Francesca</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>fnadalin@appliedgenomics.org</email></contrib><contrib contrib-type="author" id="A2"><name><surname>Vezzi</surname><given-names>Francesco</given-names></name><xref ref-type="aff" rid="I3">3</xref><email>francesco.vezzi@scilifelab.se</email></contrib><contrib contrib-type="author" id="A3"><name><surname>Policriti</surname><given-names>Alberto</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>policriti@appliedgenomics.org</email></contrib></contrib-group><aff id="I1"><label>1</label>Department of Mathematics and Computer Science, University of Udine, Udine 33100, Italy</aff><aff id="I2"><label>2</label>IGA Applied Genomics Institute, Udine 33100, Italy</aff><aff id="I3"><label>3</label>Science for Life Laboratory, KTH Royal Institute of Technology, Solna 17121, Sweden</aff><pub-date pub-type="collection"><year>2012</year></pub-date><pub-date pub-type="epub"><day>7</day><month>9</month><year>2012</year></pub-date><volume>13</volume><issue>Suppl 14</issue><supplement><named-content content-type="supplement-title">Research from the Eleventh International Workshop on Network Tools and Applications in Biology (NETTAB 2011)</named-content><named-content content-type="supplement-editor">Riccardo Bellazzi, Paolo Romano, Marco Masseroli, Shawn Murphy and Amnon Shabo</named-content></supplement><fpage>S8</fpage><lpage>S8</lpage><permissions><copyright-statement>Copyright &#x000a9;2012 Nadalin et al.; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2012</copyright-year><copyright-holder>Nadalin et al.; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><license-p>This is an open access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0">http://creativecommons.org/licenses/by/2.0</ext-link>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</license-p></license></permissions><self-uri xlink:href="http://www.biomedcentral.com/1471-2105/13/S14/S8"/><abstract><sec><title>Background</title><p>Next Generation Sequencing technologies are able to provide high genome coverages at a relatively low cost. However, due to limited reads' length (from 30 bp up to 200 bp), specific bioinformatics problems have become even more difficult to solve. <italic>De novo </italic>assembly with short reads, for example, is more complicated at least for two reasons: first, the overall amount of "noisy" data to cope with increased and, second, as the reads' length decreases the number of <italic>unsolvable </italic>repeats grows. Our work's aim is to go at the root of the problem by providing a pre-processing tool capable to produce (in-silico) longer and highly accurate sequences from a collection of Next Generation Sequencing reads.</p></sec><sec><title>Results</title><p>In this paper a seed-and-extend <italic>local </italic>assembler is presented. The kernel algorithm is a loop that, starting from a read used as seed, keeps extending it using heuristics whose main goal is to produce a collection of error-free and longer sequences. In particular, GapFiller carefully detects reliable overlaps and operates clustering similar reads in order to reconstruct the missing part between the two ends of the same insert. Our tool's output has been validated on 24 experiments using both simulated and real paired reads datasets. The output sequences are declared correct when the seed-mate is found. In the experiments performed, GapFiller was able to extend high percentages of the processed seeds and find their mates, with a false positives rate that turned out to be nearly negligible.</p></sec><sec><title>Conclusions</title><p>GapFiller, starting from a sufficiently high short reads coverage, is able to produce high coverages of accurate longer sequences (from 300 bp up to 3500 bp). The procedure to perform safe extensions, together with the mate-found check, turned out to be a powerful criterion to guarantee contigs' correctness. GapFiller has further potential, as it could be applied in a number of different scenarios, including the post-processing validation of insertions/deletions detection pipelines, pre-processing routines on datasets for <italic>de novo </italic>assembly pipelines, or in any hierarchical approach designed to assemble, analyse or validate <italic>pools </italic>of sequences.</p></sec></abstract><kwd-group><kwd><italic>de novo </italic>assembly</kwd><kwd>paired reads</kwd><kwd>(Hamming-aware) hash functions</kwd><kwd>Next Generation Sequencing data</kwd></kwd-group><conference><conf-date>12-14 October 2011</conf-date><conf-name>NETTAB 2011 Workshop on Clinical Bioinformatics</conf-name><conf-loc>Pavia, Italy</conf-loc></conference></article-meta></front><body><sec><title>Background</title><p>The recent Next Generation Sequencing (NGS) breakthrough and the consequent tremendous increase in data production, have been accompanied by the appearance of a multitude of pipelines able to <italic>assemble </italic>the (relatively) short sequences (<italic>i.e</italic>. reads) produced by state-of-the-art sequencers.</p><p>In the last two years more than 20 new <italic>assemblers </italic>(see [<xref ref-type="bibr" rid="B1">1</xref>] for an up-to-date overview) have been proposed, more than doubling in size the population of the assemblers designed for <italic>long </italic>Sanger reads. Despite the practical and theoretical problems involved in assembling complex genomes using only short sequences [<xref ref-type="bibr" rid="B2">2</xref>], several <italic>de novo </italic>assembly projects based exclusively on NGS data have started. Among the most popular ones we mention the Panda genome project [<xref ref-type="bibr" rid="B3">3</xref>], the assembly of specific human Individuals [<xref ref-type="bibr" rid="B4">4</xref>] (Han Chinese and Yoruban), and several other species [<xref ref-type="bibr" rid="B5">5</xref>].</p><p>While several tools became publicly available and several projects based on such tools started to appear, a very lively discussion on how to validate new assemblies and, in general, on how to estimate assemblers' output started. As noticed in [<xref ref-type="bibr" rid="B6">6</xref>], all assembly tools are based on a small number of algorithms and differ from one another only in matter of details that, very often, relate to how they deal with errors, inconsistencies, and ambiguities. As a consequence, an increasing number of studies is now being published aiming, on the one hand, at evaluating <italic>de novo </italic>assemblers and assemblies, and, on the other hand, at criticising the results achieved so far.</p><p>Assemblathon [<xref ref-type="bibr" rid="B7">7</xref>] first and second editions, dnGASP [<xref ref-type="bibr" rid="B8">8</xref>], and GAGE [<xref ref-type="bibr" rid="B9">9</xref>] try to assess the performances of existing tools triggering an assembly evaluation competition among several bioinformatics groups. Even though these competitions succeeded in giving a fairly complete overview of the assemblers' potentialities, they are almost always based on specific (often already sequenced) genomes or on simulated data, leaving open the question of whether the same tools would have had the same performances when run on different datasets (<italic>i.e</italic>., different genomes or real reads).</p><p>Recently proposed assemblies carried out using NGS data only (usually Illumina reads), are at the center of a lively debate. Alkan in [<xref ref-type="bibr" rid="B10">10</xref>] criticised two of the major late NGS achievements: the assembly of the Han Chinese and Yoruban individuals [<xref ref-type="bibr" rid="B4">4</xref>], both sequenced with Illumina reads. For example, Alkan identified 420.2 Mbp of missing repeated sequences from the Yoruban assembly and estimated that in both assemblies almost 16% of the genome was missing.</p><p>Some studies started to criticise the way in which the evaluation of assemblies and assemblers is carried out: standard statistics like the mean contig length and the N50 emphasize only length and nothing, or almost nothing, is said about contigs' correctness [<xref ref-type="bibr" rid="B11">11</xref>,<xref ref-type="bibr" rid="B12">12</xref>]. Evaluations of simulated data are inherently biased by the capabilities of the read simulator to faithfully reproduce error schemata [<xref ref-type="bibr" rid="B12">12</xref>].</p><p>More than three years after the so-called NGS revolution started, it is extremely clear that <italic>de novo </italic>assembly needs extensive and standardized validation steps. NGS breakthrough allowed to sequence a number of new species and individuals thought to be impossible only few years ago. While, on the one hand, an increasing number of people keeps sequencing and assemblying genomes using available assemblers and short reads, on the other one, day after day, a larger community criticises and casts doubts on assembly achievements.</p><p>At the peak of this difficult moment we try to go back to basics and propose a new tool, dubbed <italic>GapFiller </italic>[<xref ref-type="bibr" rid="B13">13</xref>], able to generate small but correct and certified contigs, that can be used either in a first step of an assembly project, or in numerous downstream analyses strongly depending on sequencing and aligning. The innovative feature of GapFiller is the possibility to produce a highly reliable output that, having been certified correct--and hence needing no further validation--, can be used, for example, to improve or validate a whole genome assembly.</p><p>Our method is based on a <italic>seed-and-extend </italic>schema aimed at <italic>closing the gap </italic>between the two mates of a paired read. Similarly to other seed-and-extend-based tools like SSAKE [<xref ref-type="bibr" rid="B14">14</xref>], SHARCGS [<xref ref-type="bibr" rid="B15">15</xref>], QSRA [<xref ref-type="bibr" rid="B16">16</xref>], and TAIPAN [<xref ref-type="bibr" rid="B17">17</xref>], GapFiller selects one read and tries to extend it using reads that overlap for a significant region. The main drawback of seed-and-extend assemblers is their inherent incapability to cope with complex (<italic>i.e.</italic>, repetitive) genomes. GapFiller does not aim at producing a <italic>de novo </italic>assembly, but only concentrates on closing the gap within paired reads. The advantages of our method lie in the generation of correct and certified contigs and, as a by-product, in the identification of "difficult" areas (<italic>e.g.</italic>, repeats, low covered regions, <italic>etc</italic>.), thus avoiding the production of wrong contigs. The assembler TAIPAN [<xref ref-type="bibr" rid="B17">17</xref>] is implemented to stop its extension phase in presence of a repeat; however, like all other full-fledged assemblers, it is not designed to return certified contigs as output.</p><p>Closing the gap within paired reads is a strategy already used by software packages like SHERA [<xref ref-type="bibr" rid="B18">18</xref>] and FLASH [<xref ref-type="bibr" rid="B19">19</xref>]. However, these tools are able to work only with "overlapping libraries", that is, libraries whose fragment size is shorter than twice the reads' length. GapFiller solves a more challenging problem, aiming at producing filled paired reads of higher length.</p><p>We will show how the contigs produced by our method, despite being of Sanger-like length or slightly longer (up to ~ 3500 bp), are highly reliable and correct. Moreover, the sequences produced generate a genome coverage consisting of evenly distributed long contigs. Such contigs can be used to feed another assembler (designed, for example, for long, Sanger-like, reads) or to identify and--most importantly--to reconstruct insertion and deletion events in resequencing projects.</p><p>On a more technical ground, our algorithm is based on a carefully chosen hash function together with a set of heuristics able to <italic>avoid </italic>or <italic>detect </italic>errors, as well as on a test for establishing the correctness of a sequence, that allow us to create a set of <italic>certified </italic>contigs.</p></sec><sec sec-type="methods"><title>Methods</title><p>GapFiller is a <italic>local </italic>assembler based on a seed-and-extend schema [<xref ref-type="bibr" rid="B13">13</xref>]. Seed-and-extend assemblers repeatedly pick up a <italic>seed </italic>(it can be either a read or a previously assembled contig) and <italic>extend </italic>it using other reads. This procedure is realised by computing and analysing all--or almost all--the overlaps between seed's tips and the remaining available reads. The reads used for an <italic>extension </italic>are those with the highest alignment score. It is clear that the seed-and-extend assemblers' computation bottleneck is their capability to quickly cope with all the alignment scores to be determined.</p><p>GapFiller begins by storing all <italic>useful </italic>reads in a memory efficient data structure that allows to readily compute overlaps between the contig under construction and the remaining available reads. In a second phase each seed read (possibly belonging to a new set of paired reads) is selected one after the other and used to start an extension phase. Such phase halts when a stop condition is reached. Depending on the stop condition, the contig produced is labelled as <italic>trusted </italic>or <italic>not trusted </italic>(<italic>i.e.</italic>, positive or negative).</p><sec><title>Definitions</title><p>Let &#x003a3; be an alphabet and &#x003a3;* be the set of the words from &#x003a3;. For every <italic>S </italic>&#x02208; &#x003a3;<sup>&#x02217; </sup>we will denote with |<italic>S</italic>| the number of characters of <italic>S </italic>and with <italic>S</italic>[<italic>p</italic>, . . ., <italic>p </italic>+ <italic>l </italic>- 1] the sub-sequence of <italic>S </italic>starting in <italic>p </italic>&#x02208; {0, . . ., |<italic>S</italic>| - 1} and of length <italic>l </italic>&#x02208; {0, . . ., |<italic>S</italic>| - <italic>p</italic>}. We will refer to <italic>S</italic>[<italic>p</italic>, . . ., <italic>p </italic>+ <italic>l </italic>- 1] as <italic>prefix </italic>if <italic>p </italic>= 0, <italic>suffix </italic>if <italic>p </italic>+ <italic>l </italic>= |<italic>S</italic>|, and as the <italic>p-</italic>th character of <italic>S </italic>if <italic>l </italic>= 1, and we will simply write <italic>S</italic>[<italic>p</italic>].</p><p>In order to quickly identify overlaps between the contig under construction and the reads' tips, we use an approach closely related to the one presented in [<xref ref-type="bibr" rid="B20">20</xref>] based on an Hamming-aware hash function. The idea is that, by representing a string of length <italic>l </italic>as a base-|&#x003a3;| number, one can often replace expensive char-by-char comparison by fast integer (or bit-string) comparison. However, for practical values of <italic>l</italic>, the integers to be compared would not fit in a memory word. For this reason, as in the classical Karp-Rabin exact string matching algorithm [<xref ref-type="bibr" rid="B21">21</xref>], we can work with numbers modulo <italic>q </italic>considering equality modulo <italic>q </italic>only as an indication (necessary condition) that pairs of strings may be the same (<italic>i.e</italic>., operating with the strings' <italic>fingerprints</italic>). Policriti <italic>et al. </italic>in [<xref ref-type="bibr" rid="B22">22</xref>] proposed an extension of the approach by Karp and Rabin, introducing a technique to deal with mismatches, based on the idea of replacing simple fingerprints comparison with a more articulated test. In particular they noticed that, by choosing <italic>q </italic>to be a Mersenne (prime, when possible) number (<italic>i.e</italic>., <italic>q </italic>= 2<italic><sup>w </sup></italic>- 1, for some <italic>w </italic>&#x02208; &#x02115;), to check whether two strings align against each other at a small Hamming distance can be implemented in average linear time.</p><p>Given a string <italic>S </italic>&#x02208; &#x003a3;* and its base-|&#x003a3;| numerical representation <italic>s </italic>&#x02208; &#x02115;, let us define the hash function <inline-formula><mml:math id="M1" name="1471-2105-13-S14-S8-i1" overflow="scroll"><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">:</mml:mo><mml:msup><mml:mrow><mml:mo class="MathClass-op">&#x02211;</mml:mo></mml:mrow><mml:mrow><mml:mo class="MathClass-bin">*</mml:mo></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02192;</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>q</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> as</p><p><disp-formula id="bmcM1"><label>(1)</label><mml:math id="M2" name="1471-2105-13-S14-S8-i2" overflow="scroll"><mml:mrow><mml:mi>S</mml:mi><mml:mo class="MathClass-rel">&#x021a6;</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>s</mml:mi><mml:mspace class="quad" width="1em"/><mml:mspace width="0.2em"/><mml:mo class="MathClass-bin"> mod</mml:mo><mml:mspace width="0.2em"/><mml:mi>q</mml:mi><mml:mo class="MathClass-punc">,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <italic>q </italic>is a (prime) number of the form <italic>q </italic>= 2<italic><sup>w</sup></italic>- 1, for some <italic>w </italic>&#x02208; &#x02115;. The value <italic>f<sub>H </sub></italic>(<italic>S</italic>) is called the <italic>fingerprint </italic>of the sequence in <italic>S </italic>&#x02208; &#x003a3;* coded with <italic>s</italic>.</p><p>In our context, the use of <italic>f<sub>H </sub></italic>significantly reduces the size of the set employed in the search of the overlapping reads. Every read <italic>r</italic>, as well as its reverse-complement, is indexed by the fingerprint of a substring of length <italic>b</italic>, starting at a fixed position <italic>x </italic>in <italic>r </italic>(see also Figure <xref ref-type="fig" rid="F1">1</xref>). Formally, given a set of reads &#x0211b;, a sequence <inline-formula><mml:math id="M3" name="1471-2105-13-S14-S8-i3" overflow="scroll"><mml:mrow><mml:mi>&#x000a0;S</mml:mi></mml:mrow></mml:math></inline-formula>, a maximum allowed Hamming distance <italic>k</italic>, the set <inline-formula><mml:math id="M4" name="1471-2105-13-S14-S8-i4" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">Z</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> of the <italic>witnesses </italic>(the Hamming sphere of radius <italic>k </italic>around <inline-formula><mml:math id="M5" name="1471-2105-13-S14-S8-i3" overflow="scroll"><mml:mrow><mml:mi>&#x000a0;S</mml:mi></mml:mrow></mml:math></inline-formula>, see [<xref ref-type="bibr" rid="B22">22</xref>] for more details), a fixed value <italic>b </italic>for the length of the substring on which the fingerprint is computed in <italic>r</italic>, and two positions <italic>x </italic>and <italic>y</italic>, the following set:</p><p><disp-formula id="bmcM2"><label>(2)</label><mml:math id="M6" name="1471-2105-13-S14-S8-i5" overflow="scroll"><mml:mrow><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>S</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>x</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">-</mml:mo><mml:msub><mml:mrow><mml:mi>f</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>S</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mspace class="quad" width="1em"/><mml:mspace width="0.2em"/><mml:mo class="MathClass-bin">mod</mml:mo><mml:mspace width="0.2em"/><mml:mi>q</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mi mathvariant="script">Z</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>k</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>q</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>contains at least all the reads <italic>r </italic>&#x02208; &#x0211b; such that the hamming distance between <italic>r</italic>[<italic>x</italic>, . . ., <italic>x </italic>+ <italic>b </italic>- 1] and <inline-formula><mml:math id="M7" name="1471-2105-13-S14-S8-i6" overflow="scroll"><mml:mi>S</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:math></inline-formula> is not greater than <italic>k</italic>. False positives can be present but, as showed in [<xref ref-type="bibr" rid="B22">22</xref>], their amount is limited. On this ground the search for reads overlapping <inline-formula><mml:math id="M8" name="1471-2105-13-S14-S8-i3" overflow="scroll"><mml:mrow><mml:mi>&#x000a0;S</mml:mi></mml:mrow></mml:math></inline-formula> can be restricted to those belonging to <inline-formula><mml:math id="M9" name="1471-2105-13-S14-S8-i7" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>S</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, for some x, <italic>y </italic>&#x02208; &#x02124;.</p><fig id="F1" position="float"><label>Figure 1</label><caption><p><bold>Fingerprint computation on <bold><italic>b</italic></bold>-length substrings</bold>. When looking for overlaps between <italic>S </italic>and <italic>r</italic>, the fingerprints are computed on the substrings <italic>r</italic>[<italic>x</italic>, . . ., <italic>x</italic>+<italic>b -</italic>1] and <italic>S</italic>[<italic>y</italic>, . . ., <italic>y </italic>+ <italic>b </italic>- 1], respectively, where <italic>x </italic>and <italic>b </italic>are set before the contig's extension phase. We require an (almost) exact <italic>b</italic>-length match between <italic>r </italic>and <italic>S </italic>in order to include <italic>r </italic>in the set of putative overlapping reads, by setting <italic>f<sub>H </sub></italic>(<italic>r</italic>[<italic>x</italic>, . . ., <italic>x </italic>+ <italic>b </italic>- 1]) = <italic>f<sub>H </sub></italic>(<italic>S</italic>[<italic>y</italic>, . . ., <italic>y </italic>+ <italic>b </italic>-1]). Using such a method, the suffix-prefix overlaps that can be detected are those of length <italic>l </italic>&#x02265; <italic>x </italic>+ <italic>b</italic>.</p></caption><graphic xlink:href="1471-2105-13-S14-S8-1"/></fig><p>As far as GapFiller is concerned, we set <italic>k </italic>= 0 as default, meaning that we search for <italic>exact b</italic>-length substrings in the reads (<italic>i.e</italic>., <inline-formula><mml:math id="M10" name="1471-2105-13-S14-S8-i8" overflow="scroll"><mml:mi>r</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>x</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>x</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>S</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>y</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>y</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mi>b</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:math></inline-formula>, for some <italic>x </italic>and <italic>y</italic>). As a consequence, better quality output will be obtained if we select a position <italic>x </italic>in <italic>r </italic>such that the average base quality is expected to be the highest possible. This point will be further discussed in the section specifically addressing data structures' design and implementation.</p></sec><sec><title>Dataset preparation</title><p>In order to avoid the generation of wrong contigs, it is of utmost importance to use only correct reads over the entire extension phase. Several tools are available to perform error correction on Illumina data using the so-called "read spectrum" (consider QUAKE [<xref ref-type="bibr" rid="B23">23</xref>], Hammer [<xref ref-type="bibr" rid="B24">24</xref>], and Allpaths [<xref ref-type="bibr" rid="B25">25</xref>] just to mention the most recent ones). Other tools discard reads or try to improve their reliability using quality information (rNA [<xref ref-type="bibr" rid="B20">20</xref>] and QSRA [<xref ref-type="bibr" rid="B16">16</xref>]).</p><p>Our approach, when we are given raw data, is to first trim (and possibly filter) the reads on the ground of quality information using a specific rNA option (refer to [<xref ref-type="bibr" rid="B20">20</xref>] for details), and to subsequently correct them with an error correction tool like QUAKE [<xref ref-type="bibr" rid="B23">23</xref>].</p><p>Another important way to assess a dataset's global quality is to plot the reads' <italic>k-mers distribution</italic>. This can be easily done using Jellyfish [<xref ref-type="bibr" rid="B26">26</xref>]. If the genome has been sequenced tens of times, then two peaks are expected: one in correspondence of the expected coverage and one in correspondence of coverage one. <italic>k</italic>-mers composing this second peak are likely to be sequencing errors. As a rule of thumb, a low number of <italic>k</italic>-mers occurring only once suggests that the dataset has a good global quality.</p></sec><sec><title>Contig extension</title><p>In the contig extension phase, each read is selected in a loop and used as <italic>seed </italic>in order to create a new contig. Once a <italic>seed </italic>read is selected, the suffix-prefix overlaps with other reads are computed and, if a sufficiently high level of global similarity is reached, they are clustered in a consensus string, which is subsequently used to perform further extensions. The procedure continues while some overlapping reads exist and the consensus string is <italic>highly representative </italic>of the clustered reads. If either one of the previous two conditions is not met, the extension phase stops, the current sequence is returned in output, and the loop continues.</p><p>Before the extension phase some parameters are set: the minimum overlap length <italic>L </italic>and the maximum shift &#x00394;: an overlap between the current contig's suffix and the read's prefix is considered only if the overlap length <italic>l </italic>belongs to the interval [<italic>L</italic>, <italic>L </italic>+ &#x00394;].</p><p>GapFiller builds a <italic>cluster </italic>every time a contig is to be extended with the overlapping reads. In particular, GapFiller uses only those reads aligning against the contig's suffix with at most <italic>&#x003b4; </italic>mismatches (where <italic>&#x003b4; </italic>= <italic>&#x003b4;</italic>(<italic>l</italic>) is a function of the overlap length <italic>l</italic>) and requires at least <italic>m </italic>reads in order to compute a consensus string. Notice that <italic>b </italic>&#x02264; <italic>L </italic>&#x02264; <italic>l </italic>holds, hence suffix-prefix overlaps might occur with more than <italic>k </italic>= 0 mismatches (see section Definitions).</p><p>Let &#x0211b; be the set of the input reads for GapFiller and <italic>r</italic><sub>0 </sub>&#x02208; &#x0211b; be a seed read. At step <italic>i </italic>= 0 the current sequence is initialized with the seed <italic>S</italic><sub>0 </sub>: = <italic>r</italic><sub>0</sub>. Denoting by <italic>S<sub>i </sub></italic>the current contig at the generic <italic>i</italic>-th step of the algorithm, the procedure to build <italic>S</italic><sub><italic>i</italic>+1 </sub>is described below:</p><p><bold>Step1 </bold>Reads are selected according to their similarity with the current contig <italic>S</italic><sub><italic>i </italic></sub>(see Figure <xref ref-type="fig" rid="F2">2a</xref>). At this point, every read overlapping <italic>S</italic><sub><italic>i </italic></sub>for <italic>l </italic>&#x02208; [<italic>L</italic>, <italic>L </italic>+ &#x00394;] characters with at most <italic>&#x003b4; </italic>mismatches is selected.</p><fig id="F2" position="float"><label>Figure 2</label><caption><p><bold>GapFiller extension phase (an example with <italic>L </italic>= 5, &#x00394; = 4, <italic>&#x003b4; </italic>= 2, <italic>m </italic>= 2, <italic>T</italic><sub>1 </sub>= 0.3, <italic>T</italic><sub>2 </sub>= 0.5)</bold>. (a) The putative overlapping reads, selected by their fingerprint values, are checked for the presence of mismatches and possibly discarded. For each remaining read (say, <italic>r</italic><sub>1</sub>, <italic>r</italic><sub>2</sub>, <italic>r</italic><sub>3</sub>, and <italic>r</italic><sub>4</sub>), the number of mismatches (highlighted in red) with <italic>S<sub>i</sub></italic>'s suffix does not exceed <italic>&#x003b4; </italic>= 2. (b) The consensus string is computed for every position <italic>j </italic>such that either <italic>j </italic>&#x02264; <italic>F </italic>(<italic>C</italic>) or at least <italic>m </italic>= 2 reads are available. The characters rounded in gray and red refer to low-represented and non-represented positions, respectively. In presence of ambiguities (<italic>i.e</italic>., positions in which more than one character with the same representation rate occur) GapFiller chooses the character belonging to the first read encountered, from left to right. (c) Reads with mismatches in correspondence of the low-represented positions are discarded (say, <italic>r</italic><sub>1 </sub>and <italic>r</italic><sub>2</sub>), hence they do not contribute to reach the threshold <italic>m </italic>to compute a new consensus string. In our example read <italic>r</italic><sub>4</sub>'s tail is cut in the non-represented position, regardless on whether it matches the consensus string or not. (d) The reads still alive after Step 3 are used to compute the final consensus string <italic>C<sub>new</sub></italic>. Since there are 2 &#x02265; <italic>m </italic>available reads exceeding <italic>S<sub>i</sub></italic>'s tail, <italic>C<sub>new </sub></italic>is computed, it is attached to <italic>S<sub>i</sub></italic>, and the extended contig <italic>S</italic><sub><italic>i</italic>+1 </sub>is obtained.</p></caption><graphic xlink:href="1471-2105-13-S14-S8-2"/></fig><p><bold>Step2 </bold>The reads are clustered and a consensus string is computed. Every character of the consensus string is assigned a flag indicating how it is representative of the reads from which it is built. More precisely, for every position <italic>j</italic>, GapFiller selects the most occurring character in the considered reads, and the majority consensus string <italic>C </italic>is computed (see Figure <xref ref-type="fig" rid="F2">2b</xref>). Depending on two parameters <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2 </sub>such that <italic>T</italic><sub>1 </sub>&#x0003c;<italic>T</italic><sub>2</sub>, we say that a position <italic>j </italic>is non-represented, low-represented, or high-represented if the representation rate of the corresponding character in <italic>C </italic>is lower than <italic>T</italic><sub>1</sub>, lower than <italic>T</italic><sub>2</sub>, or higher than <italic>T</italic><sub>2</sub>, respectively.</p><p><bold>Step3 </bold>The reads used to build the consensus <italic>C </italic>are filtered and trimmed, depending on the presence of low-represented and non-represented positions, respectively. The idea is that on low-represented positions we need a minimum percentage of reads matching the consensus string, and that on non-represented positions the extension in considered to be unsafe. Reads differing from <italic>C </italic>in correspondence of low-represented positions are discarded and the remaining ones are also trimmed if a non-represented position occurs (see Figure <xref ref-type="fig" rid="F2">2c</xref>).</p><p><bold>Step4 </bold>A new consensus string <italic>C<sub>new </sub></italic>is computed, considering only the reads obtained at Step 3, and possibly the current contig is extended (see Figure <xref ref-type="fig" rid="F2">2d</xref>). The extension is done only if the number of reads is at least <italic>m </italic>and the consensus <italic>C<sub>new </sub></italic>exceeds <italic>S<sub>i</sub></italic>'s right end: in this case, a new contig <italic>S</italic><sub><italic>i</italic>+1 </sub>is built and the procedure restarts. Otherwise the algorithm stops and the contig <italic>S<sub>i </sub></italic>is returned.</p><p>The adopted strategy is aimed at either avoiding errors and overcoming the problems arising when GapFiller attempts to cluster reads that are different from each other. In the last part of this section we will discuss in more detail how the algorithm works. The reader who is not interested in the technical formalism might skip this part and move directly to the Subsection Stop criteria.</p><sec><title>Step 1. Overlapping reads selection</title><p>Let us denote with <inline-formula><mml:math id="M11" name="1471-2105-13-S14-S8-i9" overflow="scroll"><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> the set of the putative overlapping reads with respect to the <italic>l</italic>-suffix of <italic>S<sub>i</sub></italic>, selected by their fingerprint values (see (2), with <italic>y </italic>= |<italic>S</italic>| - <italic>l </italic>+ <italic>x</italic>, for some values of <italic>x </italic>&#x02208; {0, . . ., <italic>l </italic>- <italic>b</italic>}). For every fixed value of <italic>l</italic>, the set of the reads overlapping the <italic>l</italic>-suffix of <italic>S<sub>i </sub></italic>with at most <italic>&#x003b4; </italic>mismatches is defined as</p><p><disp-formula id="bmcM3"><label>(3)</label><mml:math id="M12" name="1471-2105-13-S14-S8-i10" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mi mathvariant="script">R</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mi>l</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>l</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mo class="MathClass-bin">-</mml:mo><mml:mspace class="tmspace" width="2.77695pt"/><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>&#x003b4;</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>where <italic>d<sub>H </sub></italic>:&#x003a3;<italic><sup>l </sup></italic>&#x000d7; &#x003a3;<italic><sup>l </sup></italic>&#x02192; &#x0211d;<sup>+ </sup>is the Hamming distance. The set of all the overlapping reads will be denoted by</p><p><disp-formula id="bmcM4"><label>(4)</label><mml:math id="M13" name="1471-2105-13-S14-S8-i11" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:munderover accent="false" accentunder="false"><mml:mrow><mml:mo mathsize="big"> &#x022c3;</mml:mo></mml:mrow><mml:mrow><mml:mi>l</mml:mi><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mtext>&#x00394;</mml:mtext></mml:mrow></mml:munderover><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo>^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>Given a read <inline-formula><mml:math id="M14" name="1471-2105-13-S14-S8-i12" overflow="scroll"><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo></mml:math></inline-formula> we define its starting and ending positions as</p><p><disp-formula id="bmcM5"><label>(5)</label><mml:math id="M15" name="1471-2105-13-S14-S8-i13" overflow="scroll"><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mo class="MathClass-bin">-</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mi>l</mml:mi><mml:mspace class="quad" width="1em"/><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">+</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">|</mml:mo><mml:mo class="MathClass-bin">-</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mn>1</mml:mn><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>I(<italic>r</italic>) and <italic>F</italic>(<italic>r</italic>) represent the position of the read <italic>r </italic>with respect to the current contig <italic>S<sub>i</sub></italic>, therefore we set <italic>I</italic>(<italic>S<sub>i</sub></italic>) = 0. For instance, in the case depicted in Figure <xref ref-type="fig" rid="F2">2</xref>, we have <inline-formula><mml:math id="M16" name="1471-2105-13-S14-S8-i14" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mn>8</mml:mn></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula> and <inline-formula><mml:math id="M17" name="1471-2105-13-S14-S8-i15" overflow="scroll"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mn>4</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:math></inline-formula>, <italic>I</italic>(<italic>r</italic><sub>1</sub>) = 10 and <italic>F</italic>(<italic>r</italic><sub>1</sub>) = 20.</p></sec><sec><title>Step 2. Reads clustering and consensus string computation</title><p>The subsequent phase consists of the computation of the consensus string obtained from the set of reads <inline-formula><mml:math id="M18" name="1471-2105-13-S14-S8-i16" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> (see (4)). Notice that, in order to compute reliable extensions, we require the number of reads to be at least <italic>m</italic>, a parameter that may depend on the dataset used. If there exists no <italic>l </italic>such that the <italic>l</italic>-suffix of <italic>S<sub>i </sub></italic>is covered by at least <italic>m </italic>reads of <inline-formula><mml:math id="M19" name="1471-2105-13-S14-S8-i16" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, then the procedure stops. Otherwise, the starting and ending positions of the consensus string <italic>C </italic>with respect to <italic>S<sub>i </sub></italic>can be computed, thanks to (5). In practice, we let the consensus string start from the leftmost reads, <italic>i.e</italic>., those covering the longest suffix of <italic>S<sub>i </sub></italic>(see, for instance, the read <italic>r</italic><sub>2 </sub>in Figure <xref ref-type="fig" rid="F2">2</xref>) and end at the rightmost position in which the number of reads is at least <italic>m</italic>. More precisely, the starting and ending positions of <italic>C </italic>are defined as</p><p><disp-formula><mml:math id="M20" name="1471-2105-13-S14-S8-i17" overflow="scroll"><mml:mrow><mml:mtable class="aligned"><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">min</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-punc">;</mml:mo></mml:mtd><mml:mtd columnalign="right"/></mml:mtr><mml:mtr><mml:mtd columnalign="right"/><mml:mtd columnalign="left"><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">max</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mtext>&#x0039b;</mml:mtext><mml:mo class="MathClass-rel">|</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x02032;</mml:mi></mml:mrow></mml:msup><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msup><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mrow><mml:mi>&#x02032;</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02265;</mml:mo><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-rel">|</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mo class="MathClass-rel">&#x02265;</mml:mo><mml:mi>m</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="right"/></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>respectively. If <italic>F</italic>(<italic>C</italic>) &#x0003e; |<italic>S<sub>i</sub></italic>|-1 the procedure continues, otherwise it stops as <italic>S<sub>i </sub></italic>cannot be further extended. Looking at Figure <xref ref-type="fig" rid="F1">1</xref> we have <italic>I</italic>(<italic>C</italic>) = 9 and <italic>F</italic>(<italic>C</italic>) = 21 and the procedure continues since <italic>F</italic>(<italic>C</italic>) &#x0003e;<italic>F </italic>(<italic>S</italic><sub><italic>i</italic>+1</sub>) = 17.</p><p>The consensus string <italic>C </italic>is then computed by selecting the most represented character at every position. For every <italic>X </italic>&#x02208; &#x003a3; and for every <italic>j </italic>= <italic>I</italic>(<italic>C</italic>), . . ., <italic>F</italic>(<italic>C</italic>) we define the number of occurrences of the character <italic>X </italic>in position <italic>j </italic>with respect to <italic>S<sub>i </sub></italic>as</p><p><disp-formula><mml:math id="M21" name="1471-2105-13-S14-S8-i18" overflow="scroll"><mml:mrow><mml:mi>&#x003c3;</mml:mi><mml:mrow><mml:mo class="MathClass-open" stretchy="false">(</mml:mo><mml:mrow><mml:mi>X</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>j</mml:mi><mml:mo class="MathClass-close" stretchy="false">)</mml:mo><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mspace class="thinspace" width="0.3em"/><mml:mspace class="thinspace" width="0.3em"/><mml:mo class="MathClass-rel">|</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>j</mml:mi><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mspace class="thinspace" width="0.3em"/><mml:mtext>&#x0039b;</mml:mtext><mml:mspace class="thinspace" width="0.3em"/><mml:mi>r</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">=</mml:mo><mml:mi>X</mml:mi></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-rel">|</mml:mo><mml:mi>.</mml:mi></mml:mrow></mml:mrow></mml:mrow></mml:math></disp-formula></p><p>The consensus string <italic>C </italic>is defined, for every <italic>j </italic>= <italic>I</italic>(<italic>C</italic>), . . ., <italic>F </italic>(<italic>C</italic>), by setting <italic>C</italic>[<italic>j </italic>- <italic>I</italic>(<italic>C</italic>)] equal to the highest occurring character, <italic>i.e</italic>., the <italic>X </italic>&#x02208; &#x003a3; with the highest number of occurrences in position <italic>j</italic></p><p><disp-formula><mml:math id="M22" name="1471-2105-13-S14-S8-i19" overflow="scroll"><mml:mrow><mml:mi>C</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">arg</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:munder class="msub"><mml:mrow><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">max&#x000a0;</mml:mtext></mml:mstyle></mml:mrow><mml:mrow><mml:mi>X</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mo mathsize="big">&#x02211;</mml:mo></mml:mrow></mml:munder><mml:mi>&#x003c3;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>X</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>Loosely speaking, the character selected on a particular position of the consensus string is the most occurring character in the reads on that position; hence <italic>&#x003c3;</italic>(<italic>C</italic>[<italic>j </italic>- <italic>I</italic>(<italic>C</italic>)], <italic>j</italic>) is the number of occurrences of character <italic>C</italic>[<italic>j </italic>- <italic>I</italic>(<italic>C</italic>)] on position <italic>j</italic>.</p></sec><sec><title>Step 3. Consensus-based reads selection</title><p>As above mentioned, in order to check, on the one hand, whether a read <italic>r </italic>is highly representative of the consensus <italic>C </italic>and, on the other hand, if the extension is "safe", it is important to introduce the notion of <italic>non-represented</italic>, <italic>low-represented</italic>, and <italic>high-represented </italic>characters in the consensus string. We simply define the <italic>representation rate </italic>of the position <italic>j </italic>as</p><p><disp-formula id="bmcM6"><label>(6)</label><mml:math id="M23" name="1471-2105-13-S14-S8-i20" overflow="scroll"><mml:mrow><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:mfrac><mml:mrow><mml:mi>&#x003c3;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>C</mml:mi><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>j</mml:mi><mml:mo class="MathClass-bin">-</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo class="MathClass-rel">|</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mi>r</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">:</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>j</mml:mi><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>F</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow><mml:mo class="MathClass-rel">|</mml:mo></mml:mrow></mml:mfrac><mml:mi>.</mml:mi></mml:mrow></mml:math></disp-formula></p><p>Hence we fix two threshold values <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2 </sub>such that 0.25 &#x02264; <italic>T</italic><sub>1 </sub>&#x0003c;<italic>T</italic><sub>2 </sub>&#x0003c; 1 (notice that &#x003c0; (<italic>j</italic>) &#x02208; [0.25, 1] as |&#x003a3;| = 4) and we distinguish three types of positions in the consensus string:</p><p><disp-formula><mml:math id="M24" name="1471-2105-13-S14-S8-i21" overflow="scroll"><mml:mrow><mml:mtable class="aligned"><mml:mtr><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mi>j</mml:mi><mml:mspace class="thinspace" width="0.3em"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">is</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:mi>n</mml:mi><mml:mi>o</mml:mi><mml:mi>n</mml:mi><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">-</mml:mtext></mml:mstyle><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mspace class="thinspace" width="0.6em"/><mml:mo class="MathClass-rel">&#x021d4;&#x000a0;&#x000a0;</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mtd><mml:mtd columnalign="left"/></mml:mtr><mml:mtr><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mi>j</mml:mi><mml:mspace class="thinspace" width="0.3em"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">is</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:mi>l</mml:mi><mml:mi>o</mml:mi><mml:mi>w</mml:mi><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">-</mml:mtext></mml:mstyle><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mspace class="thinspace" width="0.3em"/><mml:mspace class="thinspace" width="0.2em"/><mml:mo class="MathClass-rel">&#x021d4;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mspace class="thinspace" width="0.3em"/><mml:mo class="MathClass-rel">&#x0003c;</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"/><mml:mtd columnalign="left"><mml:mi>j</mml:mi><mml:mspace class="thinspace" width="0.3em"/><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">is</mml:mtext></mml:mstyle><mml:mspace class="thinspace" width="0.3em"/><mml:mi>h</mml:mi><mml:mi>i</mml:mi><mml:mi>g</mml:mi><mml:mi>h</mml:mi><mml:mstyle class="text"><mml:mtext class="textsf" mathvariant="sans-serif">-</mml:mtext></mml:mstyle><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>p</mml:mi><mml:mi>r</mml:mi><mml:mi>e</mml:mi><mml:mi>s</mml:mi><mml:mi>e</mml:mi><mml:mi>n</mml:mi><mml:mi>t</mml:mi><mml:mi>e</mml:mi><mml:mi>d</mml:mi><mml:mo class="MathClass-rel">&#x021d4;</mml:mo><mml:mi>&#x003c0;</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:mi>j</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x0003e;</mml:mo><mml:msub><mml:mrow><mml:mi>T</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mi>.</mml:mi></mml:mtd></mml:mtr><mml:mtr><mml:mtd columnalign="left"/></mml:mtr></mml:mtable></mml:mrow></mml:math></disp-formula></p><p>The idea is to discard those reads that "differ from <italic>C</italic>" and to cut them out, as there is not sufficiently high evidence that GapFiller is extending correctly. In practice, we do not consider a read <italic>r </italic>if it does not match the consensus string on a low-represented position, <italic>i.e</italic>., <italic>r</italic>[<italic>j -I</italic>(<italic>r</italic>)] &#x02260; <italic>C</italic>[<italic>j </italic>- <italic>I</italic>(<italic>C</italic>)], for some <italic>j </italic>such that &#x003c0; (<italic>j</italic>) &#x02264; <italic>T</italic><sub>2</sub>. Clearly, this applies to non-represented positions as well. Then, we trim every read overlapping any non-represented position of <italic>C</italic>. More precisely, if <italic>j<sub>not </sub></italic>is the first non-represented position occurring in <italic>r </italic>(<italic>i.e., &#x003c0; </italic>(<italic>j<sub>not</sub></italic>) &#x02264; <italic>T</italic><sub>1</sub>), we consider <italic>r</italic>[0, . . ., <italic>j<sub>not </sub></italic>- <italic>I</italic>(<italic>r</italic>) - 1] instead of <italic>r</italic>.</p><p>After unsafe reads are discarded and the remaining ones are trimmed, a new set of reads, that can be denoted by <inline-formula><mml:math id="M25" name="1471-2105-13-S14-S8-i22" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula>, is finally obtained (see Figure <xref ref-type="fig" rid="F2">2c</xref>). Every read in <inline-formula><mml:math id="M26" name="1471-2105-13-S14-S8-i22" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is both matching the consensus string <italic>C </italic>on each low-represented position and not covering any non-represented one. Using this mechanism we take into account only the most representative reads and do not extend the contig with a consensus character when its representation rate is too low.</p></sec><sec><title>Step 4. Final consensus string computation and contig update</title><p>After previous step, the new set of overlapping reads <inline-formula><mml:math id="M27" name="1471-2105-13-S14-S8-i22" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:math></inline-formula> is obtained. A new consensus string <italic>C<sub>new </sub></italic>can be computed as <italic>C </italic>was before. If <italic>F</italic>(<italic>C<sub>new</sub></italic>) &#x0003e; |<italic>S<sub>i</sub></italic>| - 1 the extension is performed, the current contig is updated</p><p><disp-formula><mml:math id="M28" name="1471-2105-13-S14-S8-i23" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-rel">:</mml:mo><mml:mo class="MathClass-rel">=</mml:mo><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>I</mml:mi><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mi>.</mml:mi><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi><mml:mi>e</mml:mi><mml:mi>w</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:math></disp-formula></p><p>and the (<italic>i </italic>+ 2)-th extension phase restarts from <italic>S</italic><sub><italic>i</italic>+1</sub>.</p></sec></sec><sec><title>Stop criteria</title><p>The algorithm described in the previous section may potentially extend a contig for an arbitrarily large number of times, without checking any "global" properties of the current sequence. With our method the extension phase halts if at least one of the following conditions is met: (i) the available overlapping reads for the consensus <italic>C </italic>are less than <italic>m</italic>; (ii) the available overlapping reads for the new consensus <italic>C<sub>new </sub></italic>are less than <italic>m</italic>; (iii) contig's length exceeds the maximum length; (iv) the seed-mate has been found.</p><p>Let <italic>S<sub>i </sub></italic>be the contig obtained at the <italic>i</italic>-th step, starting from the seed read <italic>r</italic><sub>0</sub>. Criterion (i) applies when the consensus string <italic>C </italic>does not exceed the current contig. This means that there are no more than <italic>m - </italic>1 overlapping reads, or that they are too short. In such a case, the contig produced is labelled as NO_MORE_EXTENSION.</p><p>Criterion (ii) applies when the consensus may have been produced as consequence of the presence of reads belonging to different genomic locations. More precisely, this situation is likely to appear when the consensus extension is "trying" to exit from a repeat. In this case, either too many reads are discarded (due to the presence of low-represented positions) or a significant trimming of them has been performed (as some non-represented positions occur far before the end of the consensus). In such a situation, the extension is halted and the contig is labelled as REPEAT_FOUND.</p><p>Criterion (iii) is satisfied as |<italic>S</italic><sub><italic>i</italic>+1</sub>| &#x0003e;<italic>L</italic><sub>max</sub>, where <italic>L</italic><sub>max </sub>is fixed at the beginning of the algorithm and is usually set to the maximum insert size, plus a tolerance value. In such a situation, we could have been able to continue the extension but, however, we could not find the seed-mate. This suggests that the contig produced may be wrong or, at least, that it contains a high number of unreliable bases. When the maximum allowed length is exceeded, the computation is halted and the contig, labelled as LENGTH_EXCEED, is returned.</p><p>Criterion (iv) is used to stop the extension as the mate <inline-formula><mml:math id="M29" name="1471-2105-13-S14-S8-i24" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-op"> &#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> of the seed <italic>r</italic><sub>0 </sub>is found. At the generic <italic>i</italic>-th step, every <inline-formula><mml:math id="M30" name="1471-2105-13-S14-S8-i25" overflow="scroll"><mml:mrow><mml:mi>p</mml:mi><mml:mo class="MathClass-rel">&#x02208;</mml:mo><mml:mrow><mml:mo class="MathClass-open">{</mml:mo><mml:mrow><mml:mn>0</mml:mn><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mo class="MathClass-bin">-</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-op"> &#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo></mml:mrow><mml:mo class="MathClass-close">}</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula> is checked to see whether the following condition is satisfied</p><p><disp-formula id="bmcM7"><label>(7)</label><mml:math id="M31" name="1471-2105-13-S14-S8-i26" overflow="scroll"><mml:mrow><mml:msub><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mrow><mml:mi>H</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo class="MathClass-open">[</mml:mo><mml:mrow><mml:mi>p</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mi>.</mml:mi><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>p</mml:mi><mml:mo class="MathClass-bin">+</mml:mo><mml:mo class="MathClass-rel">|</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-op">&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub><mml:mo class="MathClass-rel">|</mml:mo><mml:mo class="MathClass-bin">-</mml:mo><mml:mn>1</mml:mn></mml:mrow><mml:mo class="MathClass-close">]</mml:mo></mml:mrow><mml:mo class="MathClass-punc">,</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-op">&#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow><mml:mo class="MathClass-rel">&#x02264;</mml:mo><mml:mi>M</mml:mi><mml:mo class="MathClass-punc">,</mml:mo></mml:mrow></mml:math></disp-formula></p><p>where <italic>M </italic>is the maximum number of mismatches allowed between <inline-formula><mml:math id="M32" name="1471-2105-13-S14-S8-i24" overflow="scroll"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>r</mml:mi></mml:mrow><mml:mo class="MathClass-op"> &#x002dc;</mml:mo></mml:mover></mml:mrow><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:msub></mml:math></inline-formula> and <italic>S<sub>i</sub></italic>. Inequality (7) is satisfied if and only if the mate is found in <italic>S<sub>i </sub></italic>at position <italic>p </italic>with no more than <italic>M </italic>mismatches. This control is performed on-the-fly and hence the positions already checked at the <italic>i</italic>-th step will not be re-checked. The <italic>mate</italic>-<italic>check </italic>criterion is used as a guarantee of correctness of the whole contig. This is in contrast to previous criteria, which are used to detect and prevent errors introduced in the extension phase. From this point of view, criteria (i) and (ii) can be seen as strictly <italic>local</italic>, since no information collected during previous steps is used. In this last case the contig returned is labelled as MATE_FOUND.</p></sec><sec><title>Data structures</title><p>In this section we will take a closer look at the data structures designed for our algorithm and at their implementation. GapFiller's <italic>core </italic>is the module working during the extension phase. At this point, we assume that the set &#x0211b; has already been trimmed and possibly filtered.</p><p>The basic idea is to pre-compute as much as possible of the useful information on the reads, in order to speed up the computation of the overlaps needed to perform the extension phase. Suppose that GapFiller is working at the (<italic>i</italic>+1)-th step of an extension, with <italic>i </italic>&#x02265; 0, and let <italic>S<sub>i </sub></italic>be the current contig. When constructing the consensus string <italic>C </italic>(see Figure <xref ref-type="fig" rid="F2">2a</xref>) we are always interested in obtaining overlaps between <italic>suffixes </italic>of <italic>S<sub>i </sub></italic>and <italic>prefixes </italic>of reads belonging to &#x0211b;.</p><p>In order to compute overlaps, GapFiller employs a hashing schema based on the one implemented in rNA [<xref ref-type="bibr" rid="B20">20</xref>]; in particular, a data structure similar to the one proposed in [<xref ref-type="bibr" rid="B22">22</xref>] is built. A simplified schema of GapFiller's data structure is presented in Figure <xref ref-type="fig" rid="F3">3</xref>. The basic idea behind GapFiller is the possibility to obtain in a fast and efficient way the set of reads whose prefixes overlap a suffix of the partial contig under construction. Therefore we used the rNA hash function to find reads that are likely to overlap a suffix of <italic>S<sub>i</sub></italic>; those reads are subsequently checked to see if they actually overlap <italic>S<sub>i </sub></italic>or not.</p><fig id="F3" position="float"><label>Figure 3</label><caption><p><bold>GapFiller data structure</bold>. The data structure used for GapFiller's implementation is composed of three arrays: <italic>HASHcounter</italic>, whose length depends on the parameter <italic>q </italic>used to compute the fingerprints; <italic>Reads </italic>and <italic>HASHvalues</italic>, whose lengths depend on the number of reads in &#x0211b;. <italic>HASHvalues </italic>is divided in blocks, each of them corresponding to a fingerprint value; each <italic>HASHvalues' </italic>entry contains a pointer to an element of <italic>Reads </italic>and a boolean value indicating whether the read has been reverse-complemented or not.</p></caption><graphic xlink:href="1471-2105-13-S14-S8-3"/></fig><p>Obviously, all the data must be stored in the main memory, thus requiring a careful data structures' engineering. It is clear that, since overlaps between reads and the the current contig can take place on both strands, reads must be stored together with their reverse complement.</p><p>With the goal to save as much memory as possible, reads are represented as arrays of integers, so that a base needs 2 bits instead of 8 (A&#x02192;00, C&#x02192;01, G&#x02192;10, T&#x02192;11). The data structure used to compute overlaps and to construct contigs is built from the reads. Three arrays are used to represent in a compact way the reads stored in &#x0211b; and to compute overlaps among them:</p><p>1. <italic>HASHcounter</italic>: it is an array of pointers to <italic>HASHvalues</italic>. In position <italic>i </italic>it stores the first position in <italic>HASHvalues </italic>such that a read <italic>r </italic>or its reverse complement has a prefix whose fingerprint is <italic>i</italic>.</p><p>2. <italic>HASHvalues</italic>: each array entry stores the read's location in the array <italic>Reads </italic>together with a boolean value indicating whether the fingerprint has been computed from the original read or from its reverse complement. For this reason the size of <italic>HASHvalues </italic>is twice the number of reads in &#x0211b;;</p><p>3. <italic>Reads</italic>: this array stores the reads and other useful informations, like paired read location, paired read order (first or second in a pair), and read status (used, not used, <italic>etc</italic>.).</p><p>The overall memory requirement for GapFiller depends on the size of <italic>HASHcounter </italic>and on the number of reads. As for rNA, a reasonable value for <italic>q </italic>is 2<sup>30 </sup>-1. Such a number guarantees a reduction of the number of false positives (<italic>i.e</italic>., reads reported to align with the contig suffix, even though they do not overlap with it). As far as the number of reads is concerned, we can limit <italic>q</italic>, without loss of generality, to 2<sup>31</sup>: with state-of-the-art Illumina technology, such a number of reads represents approximately a 70&#x000d7; coverage of the human genome. An Illumina read of length 100 bp requires two memory locations in <italic>HASHvalues </italic>of 4 bytes each (31 bits to access array <italic>Reads </italic>and one bit to store the overlap orientation) and one entry in <italic>Reads </italic>of 9 bytes (7 bytes to store the read's numerical representation, one to store the mate position in <italic>Reads</italic>, and one more byte to store several useful informations about read status). In total the amount of memory required is 4<italic>q </italic>+ 2 * 4|&#x0211b;| + 9|&#x0211b;| = 4<italic>q </italic>+ 17|&#x0211b;| bytes.</p><p>The reads' fingerprint is computed on a precise substring of length <italic>b </italic>(see (2)). As pointed out in section Definitions, the fingerprint of <italic>r </italic>&#x02208; &#x0211b; should be computed on the position <italic>x </italic>such that the (expected) average base quality is as high as possible and the substring <italic>r</italic>[<italic>x</italic>, . . ., <italic>x </italic>+ <italic>b </italic>- 1] falls into the contigs' suffix, independently on the overlap length <italic>l</italic>. For these two reasons, having the Illumina error-profile in mind, we choose <italic>x </italic>= 0 if <italic>r </italic>is considered on its original strand, <italic>x </italic>= <italic>L </italic>- <italic>b </italic>if <italic>r </italic>has been reverse-complemented (see Figure <xref ref-type="fig" rid="F4">4</xref>).</p><fig id="F4" position="float"><label>Figure 4</label><caption><p><bold>Reads selection by fingerprint values</bold>. The substring on which the fingerprint is computed must belong to the reads' <italic>L</italic>-prefix in order to be independent on the overlap length <italic>l</italic>. The fingerprint is computed on the leftmost substring of length <italic>b </italic>for original-stranded reads, and on the rightmost <italic>b</italic>-length substring for reverse-complemented ones.</p></caption><graphic xlink:href="1471-2105-13-S14-S8-4"/></fig><p>In order to compute the overlaps between the current contig <italic>S<sub>i </sub></italic>and the reads, one has to compute the fingerprints of the substrings of length <italic>b </italic>starting from <italic>y</italic>, for every <italic>y </italic>&#x02208; {|<italic>S<sub>i</sub></italic>| - <italic>L </italic>- &#x00394;, . . ., |<italic>S<sub>i</sub></italic>| - <italic>L</italic>} if original-stranded reads are searched, and for every <italic>y </italic>&#x02208; {|<italic>S<sub>i </sub></italic>| - &#x00394; - <italic>b</italic>, . . ., |<italic>S<sub>i</sub></italic>| - <italic>b</italic>} if reverse-complemented ones are to be extracted. Let us indicate with <italic>s<sub>y </sub></italic>the fingerprint computed from <italic>S<sub>i</sub></italic>[<italic>y</italic>, . . ., <italic>y </italic>+ <italic>b </italic>- 1] (see Figure <xref ref-type="fig" rid="F4">4</xref>). GapFiller uses this number to retrieve reads whose <italic>l</italic>-length prefix (<italic>l </italic>= |<italic>S<sub>i</sub></italic>| - <italic>y </italic>for original-stranded reads, <italic>l </italic>= |<italic>S<sub>i</sub></italic>| - <italic>y </italic>+ <italic>L </italic>- <italic>b </italic>for reverse-complemented ones) is likely to match a substring of <italic>S<sub>i </sub></italic>close to the sequence's end. In particular GapFiller accesses all <italic>HASHvalues </italic>positions between <italic>HASHcounter</italic>[<italic>s<sub>y</sub></italic>] and <italic>HASHcounter</italic>[<italic>s<sub>y </sub></italic>+ 1] and, subsequently, accesses <italic>Reads </italic>to identify the set of candidate overlapping sequences &#x0211b;(<italic>S<sub>i</sub></italic>, <italic>l</italic>) (in Figure <xref ref-type="fig" rid="F3">3</xref> GapFiller scans all positions between <italic>k </italic>and <italic>r </italic>- 1 of <italic>HASHvalues</italic>). Finally, the set &#x0211b;(<italic>S<sub>i</sub></italic>, <italic>l </italic>is used to compute <inline-formula><mml:math id="M33" name="1471-2105-13-S14-S8-i27" overflow="scroll"><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="script">R</mml:mi></mml:mrow><mml:mo class="MathClass-op">^</mml:mo></mml:mover><mml:mrow><mml:mo class="MathClass-open">(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>S</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo class="MathClass-punc">,</mml:mo><mml:mi>l</mml:mi></mml:mrow><mml:mo class="MathClass-close">)</mml:mo></mml:mrow></mml:mrow></mml:math></inline-formula>, the set of real overlapping reads. This is done by checking all candidate reads singularly. Due to the fact that only a limited number of mismatches is allowed in this phase and that the employed hash function guarantees a low false positive rate, this step is extremely fast.</p></sec></sec><sec sec-type="results"><title>Results</title><p>GapFiller outputs a set of labelled contigs. The label describes the level of reliability of the sequence, in particular we divide GapFiller's output in two sets: <italic>positive/trusted </italic>contigs are those labelled MATE_FOUND, while <italic>negative/non-trusted </italic>contigs are those labelled NO_MORE_EXTENSION, REPEAT_FOUND, LENGTH_EXCEED. Trusted contigs are those that we consider certified correct and can therefore be used in subsequent analysis. Non-trusted contigs are defined in this way because we were not able to find the seed-mate and hence we have no way to estimate their correctness.</p><p>We decided to perform experiments on both simulated and real data. Despite being aware that results on simulated datasets are strongly connected with the ability of read simulators to successfully reproduce realistic error schemata [<xref ref-type="bibr" rid="B12">12</xref>], we are also conscious that they are the only way to precisely estimate the reliability of assembled reads. In contrast, experiments on real datasets are necessary in order to test the applicability of our tool.</p><p>We simulated NGS experiments on five bacterial genomes, producing four coverages for each of them, in order to show how GapFiller's performances scale at different coverages. Moreover, in order to test correctness, we aligned each output contig against a precise region of the reference, as seed reads' coordinates and orientation are known.</p><p>The experiments on real datasets were performed on public data, for which the results obtained by various assemblers are public as well. In this case, we first checked the correctness of GapFiller's output contigs and then used them as input for an assembler for long reads.</p><sec><title>Dataset</title><p>The reference genomes used for simulated experiments were downloaded from NCBI website [<xref ref-type="bibr" rid="B27">27</xref>] and we used SimSeq, the reads simulator employed in Assemblathon 1 [<xref ref-type="bibr" rid="B7">7</xref>], to generate paired reads coverages. More specifically, we performed our experiments on five bacterial genomes (see Table <xref ref-type="table" rid="T1">1</xref>). We generated a library constituted by 100 bp-length paired reads, with insert size 600 &#x000b1; 200 bp, using error profiles provided by SimSeq for reads 1 and 2, respectively. In particular, we obtained 20 simulated datasets generating, for each organism, four paired-ends coverages: 30&#x000d7;, 50&#x000d7;, 70&#x000d7;, and 90&#x000d7;. The reasons behind this choice lie on the fact that, on the one hand, we need at least a 30&#x000d7; coverage in order to provide GapFiller an adequate reads distribution, and, on the other hand, we noticed that coverages equal or higher than 100&#x000d7; do not appreciably increase GapFiller's performances.</p><table-wrap id="T1" position="float"><label>Table 1</label><caption><p>Reference genomes for simulated datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center">Organism</th><th align="center">Genome length (bp)</th><th align="center">Read length (bp)</th><th align="center">Insert size (bp)</th></tr></thead><tbody><tr><td align="center"><italic>Alcanivorax borkumensis</italic></td><td align="center">3,120,143</td><td align="center">100</td><td align="center">600</td></tr><tr><td align="center"><italic>Alteromonas macleodii</italic></td><td align="center">4,412, 282</td><td align="center">100</td><td align="center">600</td></tr><tr><td align="center"><italic>Bacillus amyloliquefaciens</italic></td><td align="center">3, 980,199</td><td align="center">100</td><td align="center">600</td></tr><tr><td align="center"><italic>Bacillus cereus</italic></td><td align="center">5, 699, 545</td><td align="center">100</td><td align="center">600</td></tr><tr><td align="center"><italic>Bordetella bronchiseptica</italic></td><td align="center">5, 339,179</td><td align="center">100</td><td align="center">600</td></tr></tbody></table></table-wrap><p>The real datasets were dowloaded from GAGE website [<xref ref-type="bibr" rid="B28">28</xref>] (see Table <xref ref-type="table" rid="T2">2</xref>). Fragment (paired-ends) and short jump (mate-pairs) libraries are available, and corrected data are provided as well. For both datasets, we combined the two libraries in two ways: in a first attempt we ran GapFiller using only reads from the fragment library, while in a second experiment we used both libraries, but we selected seeds from the short jump dataset only, creating in this way contigs of average length 3.5 Kbp.</p><table-wrap id="T2" position="float"><label>Table 2</label><caption><p>Reference genomes and libraries for real datasets (Allpaths error-corrected)</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center">Organism</th><th align="center">Genome length (bp)</th><th align="left">Library</th><th align="center">Avg Read length (bp)</th><th align="center">Insert size (bp)</th><th align="center">Coverage</th></tr></thead><tbody><tr><td align="center"><italic>S. aureus</italic></td><td align="center">2, 903, 081</td><td align="left">Fragment<break/>Short jump</td><td align="center">101<break/>96</td><td align="center">180<break/>3500</td><td align="center">29 &#x000d7;<break/>32 &#x000d7;</td></tr><tr><td/><td/><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>R. sphaeroides</italic></td><td align="center">4, 603, 060</td><td align="left">Fragment<break/>Short jump</td><td align="center">101<break/>101</td><td align="center">180<break/>3500</td><td align="center">31&#x000d7;<break/>29&#x000d7;</td></tr></tbody></table></table-wrap><p>As far as the experiments on real data are concerned, it is important to notice that the datasets provided by GAGE, together with the assembly results described in [<xref ref-type="bibr" rid="B9">9</xref>], represent the first available benchmarks that can be used to evaluate new instruments like GapFiller.</p><p>Using a specific rNA option, each simulated dataset was filtered to prune and trim reads on the basis of their quality information. For the real datasets, instead, we chose to use the Allpaths error-corrected reads, hence there was no need to trim them.</p></sec><sec><title>Design of experiments</title><p>We used simulated data in order to evaluate GapFiller's ability to correctly reconstruct the gap between two paired reads and to assess the reliability of the output classification (NO_MORE_EXTENSION, REPEAT_FOUND, LENGTH_EXCEED, and MATE_FOUND). In particular we used these datasets--easy to build and validate--to explore how coverage affects GapFiller's extension phase. Results on real datasets have been used instead to evaluate GapFiller's potential when its output is used as an input dataset for an assembler for long reads. However, the capability of producing correct contigs is a fundamental feature when GapFiller is used in this context.</p><p>GapFiller's performances rely on the choice of three crucial parameters: the minimum overlap length <italic>L</italic>, the slack &#x00394;, and the length <italic>b </italic>of the substring on which the fingerprint is computed. We decided to set <italic>L </italic>= 50 and &#x00394; = 40, as reads' length is approximately 100 bp for every library used for the experiments. The value of <italic>b </italic>identifies the length of a substring on which we (almost always) require an exact matching between read and contig (see Figure <xref ref-type="fig" rid="F4">4</xref>), due to the fact that the employed hash function has a low false-positives rate (see (2)). We set <italic>b </italic>= 20 because we observed that a greater value of <italic>b </italic>(<italic>i.e</italic>., close to <italic>L</italic>) dramatically prevents GapFiller to find even few-mismatch-affected overlaps.</p><p>The parameters <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2</sub>, necessary to discern among high/low/non-represented positions in the consensus string (see Subsection Implementation-Contig extension), are set to <italic>T</italic><sub>1 </sub>= 0.6 and <italic>T</italic><sub>2 </sub>= 0.9. Recall that when a position in the consensus string has a representation rate lower than <italic>T</italic><sub>1</sub>, all the reads are trimmed on that position; instead, if the representation rate is lower than <italic>T</italic><sub>2</sub>, only the reads not matching the consensus string are dropped. The value of <italic>m</italic>, the minimum number of reads required in order to compute the consensus string, has always been set to 2. We chose not to let <italic>m </italic>depend upon coverage, since the number of reads after Step 3 strongly depends on the parameters used (say, <italic>T</italic><sub>1 </sub>and <italic>T</italic><sub>2</sub>).</p><p>We set the maximum length of a contig to be much greater than the expected mean insert size, <italic>i.e</italic>., 1800 bp for simulated data, 550 bp and 4500 bp for GAGE fragment and short jump libraries, respectively (see also Table <xref ref-type="table" rid="T1">1</xref> and Table <xref ref-type="table" rid="T2">2</xref>).</p><p>We allowed for the presence of mismatches when looking for the seed-mate in the contig being constructed with parameter <italic>M</italic>. In all the performed experiments we set <italic>M </italic>= 10 (<italic>i.e</italic>., approximately 10% of the reads' length). This choice is justified by two reasons: the first one lies in the fact that the data simulated with SimSeq have a quite high amount of low-quality bases even far from the rightmost positions within the reads; the second one is that, on real datasets, lower values of <italic>M </italic>(<italic>e.g</italic>., 5 or 2) do not increase output quality. The value of <italic>&#x003b4;</italic>, representing the maximum number of mismatches allowed when computing overlaps, depends on the overlap length <italic>l </italic>and was set to <italic>Ml </italic>/ |<italic>r</italic>|, where |<italic>r</italic>| is the average read length.</p></sec><sec><title>Analysis</title><p>The post-processing phase of GapFiller's output is aimed at both quantitative and qualitative analysis. The first is focused on evaluating the amount of trusted contigs our tool is able to produce, the second on results' validation. The main goal is to compare the performances on different input datasets and coverages.</p><p>Due to their nature, experiments on simulated data allow to precisely estimate correctness by aligning a contig in the exact place where it is supposed to occur in the reference genome. More precisely, we used the Smith-Waterman alignment algorithm [<xref ref-type="bibr" rid="B29">29</xref>], assigning a score of 1 to a match, -1 to a mismatch, and -2 to an indel. For instance, let us consider a contig <italic>S </italic>generated by extending a seed read <italic>r</italic>, and suppose that <italic>r </italic>has been extracted from the genome <italic>G </italic>at position <italic>x</italic>, on the forward strand. To test its correctness, <italic>S </italic>is aligned against <italic>G</italic>[<italic>x</italic>, <italic>x </italic>+ |<italic>S</italic>| + <italic>g </italic>- 1], where <italic>g </italic>is the maximum number of allowed indels, depending on a user-defined threshold for the alignment score. We say that <italic>S </italic>is <italic>correctly aligned </italic>if and only if the ratio between the best alignment score of <italic>S </italic>against <italic>G</italic>[<italic>x</italic>, <italic>x </italic>+ |<italic>S</italic>| + <italic>g </italic>- 1] and |<italic>S</italic>| is at least 0.95 (for instance, we allow up to 5 mismatches, 1 indel and 1 mismatch, or 3 indels every 200 bp, on average). For this particular choice of the alignment score, <italic>g </italic>is fixed to be &#x02308;3|<italic>S</italic>|/200&#x02309;.</p><p>Alignments performed in this way allowed us to divide contigs in four subsets: <italic>true </italic>and <italic>false </italic>positives and <italic>true </italic>and <italic>false </italic>negatives, depending on the contigs classification and correctness (see Table <xref ref-type="table" rid="T3">3</xref>). This gave us the possibility not only to estimate the percentage of correctly reconstructed contigs, but also to evaluate GapFiller's ability to discern between trusted and not trusted ones.</p><table-wrap id="T3" position="float"><label>Table 3</label><caption><p>Contigs post-processing classification</p></caption><table frame="hsides" rules="groups"><thead><tr><th/><th align="center">Aligned</th><th align="center">Unaligned</th></tr></thead><tbody><tr><td align="center"><bold>Trusted</bold></td><td align="center">True Positive (TP)</td><td align="center">False Positive (FP)</td></tr><tr><td colspan="3"><hr/></td></tr><tr><td align="center"><bold>Not trusted</bold></td><td align="center">False Negative (FN)</td><td align="center">True Negative (TN)</td></tr></tbody></table></table-wrap><p>When using a real dataset reads provenance is unknown, so in this case we tested output correctness by aligning the contigs against the reference genome using BLAST. We set the percentage of identity to be at least 95% and the hit length to be 100% of contig's length, in order to accept an alignment. In real cases it is interesting to extract two pieces of information from alignments: the number of (trusted) contigs that correctly align against the reference, as in the simulated case, and the coverage profile, as it is useful in order to estimate the percentage of genome reconstructed by GapFiller (see Table <xref ref-type="table" rid="T4">4</xref>).</p><table-wrap id="T4" position="float"><label>Table 4</label><caption><p>Validation of GapFiller's output on GAGE datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center">Organism</th><th align="center">Library</th><th align="center">Avg contig length (bp)</th><th align="center">Aligned contigs</th><th align="center">Aligned length</th><th align="center">Genome cov</th></tr></thead><tbody><tr><td align="center"><italic>S. aureus</italic></td><td align="center">Fragment<break/>S.j. + fragment</td><td align="center">182<break/>3648</td><td align="center">99.48%<break/>98.74%</td><td align="center">99.47%<break/>98.76%</td><td align="center">98.12%<break/>95.00%</td></tr><tr><td colspan="6"><hr/></td></tr><tr><td align="center"><italic>R. sphaeroides</italic></td><td align="center">Fragment<break/>S.j. + fragment</td><td align="center">188<break/>3736</td><td align="center">99.91%<break/>98.20%</td><td align="center">99.92%<break/>98.22%</td><td align="center">98.65%<break/>74.12%</td></tr></tbody></table><table-wrap-foot><p>The experiments performed with both short jump (s.j.) and fragment libraries are done by picking the seeds from the short jump library only. We state that a contig is aligned against the reference if the alignment is a single hit covering 100% of contig's length and the percentage of identity is at least 95%. The statistics are computed on trusted contigs.</p></table-wrap-foot></table-wrap><p>Thanks to the presence of <italic>theoretical optimal </italic>assemblies for the two real datasets (see [<xref ref-type="bibr" rid="B9">9</xref>]) we evaluated the performances of GapFiller with respect to other assemblers. In particular, we extracted a set of contigs corresponding to a fixed coverage (10&#x000d7; for <italic>Staphylococcus aureus </italic>and 15&#x000d7; for <italic>Rhodobacter sphaeroides </italic>datasets, respectively) and assembled it with PHRAP [<xref ref-type="bibr" rid="B30">30</xref>], a well known Overlap-Layout-Consensus assembler. We produced a set of statistics representing the correctness of our assembly using the same scripts used in [<xref ref-type="bibr" rid="B9">9</xref>] and available for download at [<xref ref-type="bibr" rid="B28">28</xref>].</p></sec></sec><sec sec-type="discussion"><title>Discussion</title><p>All the experiments were performed on a 8CPU (2500GHz) and 32GB RAM machine. All of them required no more than ~ 5.4GB RAM memory. See Table <xref ref-type="table" rid="T5">5</xref> for the time requirements and for the output coverage produced for each experiment.</p><table-wrap id="T5" position="float"><label>Table 5</label><caption><p>GapFiller performances on both simulated and real datasets</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="center">Organism</th><th align="center">Dataset</th><th align="center">Output coverage</th><th align="center">Time</th></tr></thead><tbody><tr><td align="center"><italic>A. borkumensis</italic></td><td align="center">30&#x000d7;</td><td align="center">80&#x000d7;</td><td align="center">25' 45"</td></tr><tr><td/><td align="center">50&#x000d7;</td><td align="center">141&#x000d7;</td><td align="center">53' 14"</td></tr><tr><td/><td align="center">70&#x000d7;</td><td align="center">199&#x000d7;</td><td align="center">1 h 30' 23"</td></tr><tr><td/><td align="center">90&#x000d7;</td><td align="center">279&#x000d7;</td><td align="center">2 h 01' 03"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>A. macleodii</italic></td><td align="center">30&#x000d7;</td><td align="center">83&#x000d7;</td><td align="center">30' 55"</td></tr><tr><td/><td align="center">50&#x000d7;</td><td align="center">146&#x000d7;</td><td align="center">1 h 12' 12"</td></tr><tr><td/><td align="center">70&#x000d7;</td><td align="center">203&#x000d7;</td><td align="center">2 h 05' 36"</td></tr><tr><td/><td align="center">90&#x000d7;</td><td align="center">262&#x000d7;</td><td align="center">3 h 12' 36"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>B. amyloliquefaciens</italic></td><td align="center">30&#x000d7;</td><td align="center">87&#x000d7;</td><td align="center">26' 40"</td></tr><tr><td/><td align="center">50&#x000d7;</td><td align="center">154&#x000d7;</td><td align="center">1 h 01' 24</td></tr><tr><td/><td align="center">70&#x000d7;</td><td align="center">216&#x000d7;</td><td align="center">1 h 47' 51"</td></tr><tr><td/><td align="center">90&#x000d7;</td><td align="center">278&#x000d7;</td><td align="center">2 h 44' 52"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>B.cereus</italic></td><td align="center">30&#x000d7;</td><td align="center">86&#x000d7;</td><td align="center">35' 54</td></tr><tr><td/><td align="center">50&#x000d7;</td><td align="center">151&#x000d7;</td><td align="center">1 h 20' 50"</td></tr><tr><td/><td align="center">70&#x000d7;</td><td align="center">213&#x000d7;</td><td align="center">2 h 21' 28</td></tr><tr><td/><td align="center">90&#x000d7;</td><td align="center">274&#x000d7;</td><td align="center">3 h 36' 37"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>B. bronchiseptica</italic></td><td align="center">30&#x000d7;</td><td align="center">87&#x000d7;</td><td align="center">35' 27"</td></tr><tr><td/><td align="center">50&#x000d7;</td><td align="center">153&#x000d7;</td><td align="center">1 h 19' 34"</td></tr><tr><td/><td align="center">70&#x000d7;</td><td align="center">215&#x000d7;</td><td align="center">2 h 19' 01"</td></tr><tr><td/><td align="center">90&#x000d7;</td><td align="center">276&#x000d7;</td><td align="center">3 h 35' 01"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>S. aureus</italic></td><td align="center">Fragment</td><td align="center">26&#x000d7;</td><td align="center">08' 25"</td></tr><tr><td/><td align="center">Short jump + fragment</td><td align="center">517&#x000d7;</td><td align="center">3 h 34' 01"</td></tr><tr><td colspan="4"><hr/></td></tr><tr><td align="center"><italic>R. sphaeroides</italic></td><td align="center">Fragment</td><td align="center">28&#x000d7;</td><td align="center">08' 43"</td></tr><tr><td/><td align="center">Short jump + fragment</td><td align="center">230&#x000d7;</td><td align="center">5 h 27' 21"</td></tr></tbody></table></table-wrap><p>Experiments performed on simulated datasets show how GapFiller's performances improve as coverage increases (see Figure <xref ref-type="fig" rid="F5">5</xref> and Table <xref ref-type="table" rid="T5">5</xref>). From the histograms in Figure <xref ref-type="fig" rid="F5">5</xref> we can clearly appreciate how the number of true positives (see Table <xref ref-type="table" rid="T3">3</xref>) increases with coverage, reaching an average value of 99% when coverage is above 50&#x000d7;. In a specular way, we can see that the number of false negatives decreases as coverage increases. Table <xref ref-type="table" rid="T5">5</xref> shows how a higher input coverage allows us to produce a higher output coverage composed by trusted reads.</p><fig id="F5" position="float"><label>Figure 5</label><caption><p><bold>Results on 5 simulated datasets</bold>. The five histograms represent, for each dataset, the true positives, false positives, false negatives, and true negatives rates for different input coverages. In order to decide if a (positive or negative) contig is either true or false, it is aligned against the reference on the exact positions in which it is supposed to occur.</p></caption><graphic xlink:href="1471-2105-13-S14-S8-5"/></fig><p>The simulated datasets allowed us to show how GapFiller is able not only to correctly reconstruct the gap between paired reads, but also to correctly flag the generated contigs as trusted (<italic>i.e</italic>., MATE_FOUND) and non-trusted (all other cases). Going into more detail, we observed that the majority of non-trusted contigs are labelled NO_MORE_EXTENSION, meaning that GapFiller stops a contig extension depending on some input dataset features (low covered regions and/or error-affected reads). Another possible scenario is the one in which GapFiller computes a wrong consensus without recognizing it.</p><p>Another important result obtained from these datasets is that the percentage of uncovered bases is negligible, being strictly less than 0.1% even with low input coverages (<italic>e.g</italic>., 30&#x000d7;).</p><p>On the basis of the results obtained on simulated data, we tested GapFiller on real data. We decided to use two datasets provided by GAGE [<xref ref-type="bibr" rid="B9">9</xref>]. We opted for these data because they represent state-of-the-art Illumina sequences, they are freely available, and they come with a reference sequence, a set of assemblies obtained with state-of-the-art assemblies, and with a set of evaluation scripts.</p><p>Table <xref ref-type="table" rid="T4">4</xref> shows GapFiller's results on <italic>Staphylococcus aureus </italic>and <italic>Rhodobacter sphaeroides </italic>datasets. For both of them we run GapFiller twice: a first time using only reads from fragment library and a second time using reads from short jump library as seeds and reads from both libraries to close the gap. From Table <xref ref-type="table" rid="T4">4</xref> we can also see that, in both situations, GapFiller is able to reconstruct the insert with the expected size; moreover the amount of aligned trusted contigs is comparable to that obtained when simulated datasets are used as input. The percentage of reconstructed genome is extremely high in <italic>S</italic>. <italic>aureus </italic>(for both experiments) and <italic>R</italic>. <italic>sphaeroides </italic>when fragment library is used alone. When reads from short jump library are used as seeds, instead, there is almost 26% of reference missing. This could have been caused either by a bias in the library (non-uniform mate-pairs distribution) or by the presence of difficult-to-assemble areas larger than the insert size.</p><p>In order to proof GapFiller's capabilities when used on real data, we extracted a random 10&#x000d7; coverage from the set of <italic>S</italic>. <italic>aureus </italic>output contigs (in particular from those obtained using short jump reads as seeds) and a random 15&#x000d7; coverage from <italic>R</italic>. <italic>sphaeroides </italic>output contigs (10&#x000d7; and 5&#x000d7; from those obtained using seeds from fragment and short jump libraries, respectively). Both coverages have been assembled with PHRAP with default parameters and the results have been compared to the ones presented in GAGE [<xref ref-type="bibr" rid="B9">9</xref>]. It is worth noting that the assemblies presented in GAGE should be considered <italic>the best </italic>achievable assemblies with the employed tools. In order to obtain a comparison as fair as possible we employed the same scripts used by Salzberg and colleagues in [<xref ref-type="bibr" rid="B9">9</xref>]. It is important to say that the presence of a reference sequence for both the assembled genomes allows us to compute the real number of errors and mis-assemblies.</p><p>Tables <xref ref-type="table" rid="T6">6</xref> and <xref ref-type="table" rid="T7">7</xref> show the most important statistics obtained in the validation phase. For what concerns <italic>S</italic>. <italic>aureus </italic>assemblies, we can see that our assembly has a connectivity level (number of contigs and N50) higher than that of many other widely used assemblers (<italic>e.g</italic>., Velvet), moreover the number of small contigs (chaffs), and the number of wrongly assembled repeats (duplications and compressions) is always comparable and often better than the other assemblies (all percentages in Tables <xref ref-type="table" rid="T6">6</xref> and <xref ref-type="table" rid="T7">7</xref> are expressed as a pecentage of true genome size). The most important columns, however, are the last four, showing the number of errors (the ideal assembler should have 0 everywhere). GapFiller+PHRAP not only is one of the assemblies with the fewest number of indels, but is also the one having less relocations (3) and inversions (0). These latest two types of errors are the most dangerous ones, due to the fact that they are the result of merging two completely different genome areas.</p><table-wrap id="T6" position="float"><label>Table 6</label><caption><p>GAGE comparison statistics on Staphylococcus aureus contigs</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Assembler</th><th align="right">#Ctg</th><th align="right">NG50</th><th align="center">Chaff %</th><th align="center">Dupl %</th><th align="center">Comp %</th><th align="center">Indels &#x02264; 5 bp</th><th align="center">Indels &#x0003e; 5 bp</th><th align="center">Inv</th><th align="right">Rel</th></tr></thead><tbody><tr><td align="left">ABySS</td><td align="right">301</td><td align="right">29198</td><td align="center">6.71</td><td align="center">23.06</td><td align="center">0.98</td><td align="center">20</td><td align="center">9</td><td align="center">3</td><td align="right">2</td></tr><tr><td align="left">Allpaths-LG</td><td align="right">59</td><td align="right">96740</td><td align="center">0.03</td><td align="center">0.03</td><td align="center">1.26</td><td align="center">4</td><td align="center">12</td><td align="center">0</td><td align="right">4</td></tr><tr><td align="left">Bambus2</td><td align="right">108</td><td align="right">50192</td><td align="center">0.00</td><td align="center">0.01</td><td align="center">1.27</td><td align="center">56</td><td align="center">164</td><td align="center">2</td><td align="right">11</td></tr><tr><td align="left">MSR-CA</td><td align="right">93</td><td align="right">59152</td><td align="center">0.02</td><td align="center">0.71</td><td align="center">0.88</td><td align="center">23</td><td align="center">10</td><td align="center">6</td><td align="right">7</td></tr><tr><td align="left"><bold>GapFiller+PHRAP</bold></td><td align="right"><bold>90</bold></td><td align="right"><bold>42398</bold></td><td align="center"><bold>0.00</bold></td><td align="center"><bold>0.28</bold></td><td align="center"><bold>1.07</bold></td><td align="center"><bold>12</bold></td><td align="center"><bold>4</bold></td><td align="center"><bold>0</bold></td><td align="right"><bold>3</bold></td></tr><tr><td align="left">SGA</td><td align="right">1253</td><td align="right">4005</td><td align="center">21.34</td><td align="center">0.01</td><td align="center">1.26</td><td align="center">2</td><td align="center">2</td><td align="center">1</td><td align="right">3</td></tr><tr><td align="left">SOAPdenovo</td><td align="right">106</td><td align="right">288184</td><td align="center">0.35</td><td align="center">1.42</td><td align="center">1.39</td><td align="center">25</td><td align="center">31</td><td align="center">1</td><td align="right">16</td></tr><tr><td align="left">Velvet</td><td align="right">161</td><td align="right">48440</td><td align="center">0.46</td><td align="center">0.14</td><td align="center">1.31</td><td align="center">6</td><td align="center">14</td><td align="center">5</td><td align="right">9</td></tr></tbody></table></table-wrap><table-wrap id="T7" position="float"><label>Table 7</label><caption><p>GAGE comparison statistics on Rhodobacter sphaeroides contigs</p></caption><table frame="hsides" rules="groups"><thead><tr><th align="left">Assembler</th><th align="right">#Ctg</th><th align="right">NG50</th><th align="center">Chaff %</th><th align="center">Dupl %</th><th align="center">Comp %</th><th align="center">Indels &#x02264; 5 bp</th><th align="center">Indels &#x0003e; 5 bp</th><th align="center">Inv</th><th align="center">Rel</th></tr></thead><tbody><tr><td align="left">ABySS</td><td align="right">1916</td><td align="right">5872</td><td align="center">1.67</td><td align="center">10.07</td><td align="center">0.49</td><td align="center">278</td><td align="center">34</td><td align="center">2</td><td align="center">17</td></tr><tr><td align="left">Allpaths-LG</td><td align="right">203</td><td align="right">42455</td><td align="center">0.01</td><td align="center">0.38</td><td align="center">0.33</td><td align="center">150</td><td align="center">37</td><td align="center">0</td><td align="center">6</td></tr><tr><td align="left">Bambus2</td><td align="right">176</td><td align="right">93198</td><td align="center">0.00</td><td align="center">0.00</td><td align="center">0.25</td><td align="center">149</td><td align="center">363</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="left">CABOG</td><td align="right">321</td><td align="right">20211</td><td align="center">0.00</td><td align="center">0.12</td><td align="center">0.71</td><td align="center">145</td><td align="center">24</td><td align="center">1</td><td align="center">9</td></tr><tr><td align="left">MSR-CA</td><td align="right">394</td><td align="right">22128</td><td align="center">0.02</td><td align="center">1.05</td><td align="center">0.53</td><td align="center">179</td><td align="center">32</td><td align="center">1</td><td align="center">8</td></tr><tr><td align="left"><bold>GapFiller+PHRAP</bold></td><td align="right"><bold>1584</bold></td><td align="right"><bold>7809</bold></td><td align="center"><bold>0.12</bold></td><td align="center"><bold>0.49</bold></td><td align="center"><bold>0.76</bold></td><td align="center"><bold>158</bold></td><td align="center"><bold>14</bold></td><td align="center"><bold>2</bold></td><td align="center"><bold>7</bold></td></tr><tr><td align="left">SGA</td><td align="right">3073</td><td align="right">2284</td><td align="center">3.49</td><td align="center">0.05</td><td align="center">0.98</td><td align="center">114</td><td align="center">5</td><td align="center">0</td><td align="center">5</td></tr><tr><td align="left">SOAPdenovo</td><td align="right">204</td><td align="right">131681</td><td align="center">0.44</td><td align="center">1.07</td><td align="center">0.54</td><td align="center">155</td><td align="center">406</td><td align="center">0</td><td align="center">8</td></tr><tr><td align="left">Velvet</td><td align="right">583</td><td align="right">15665</td><td align="center">0.55</td><td align="center">0.29</td><td align="center">0.96</td><td align="center">148</td><td align="center">27</td><td align="center">0</td><td align="center">8</td></tr></tbody></table></table-wrap><p>Results showed in Table <xref ref-type="table" rid="T7">7</xref> for <italic>R</italic>. <italic>sphaeroides </italic>are similar: this time GapFiller+PHRAP has a lower connectivity level (however greater than SGA and ABySS, two widely used assemblers). Also in this case our assembly is not seriously affected by indels (opposite to SOAPdenovo that has more than 550 indels). Concerning inversions and relocations, GapFiller + PHRAP's performances are comparable to that of the other assemblers.</p></sec><sec sec-type="conclusions"><title>Conclusion</title><p>GapFiller is a <italic>local assembler </italic>based on a hashing technique. Indeed, on the one hand, it boosts the extension phase by reducing the search space and hence allows an exact computation of overlaps, and, on the other hand, it allows to store in an efficient and compact way all the needed information.</p><p>GapFiller is a tool able to provide <italic>certified </italic>contigs, in the sense that those labelled "trusted" are (almost always) correct. This statement is sustained by various simulated experiments, as well as by two real ones. GapFiller does not try and does not aim at assembling a genome but, instead, it aims at providing as output a set of Sanger-like-length reads certified correct. In a <italic>de novo </italic>assembly project, GapFiller can be used in two modalities. It can realize a preprocessing step, as the produced trusted contigs can be used as input <italic>meta-reads </italic>for an assembler for long reads; as an opposite strategy, it can be used to join the contigs produced by a <italic>de novo </italic>assembler in a scaffolding-like phase or to (partially) assemble structural variations within an NGS resequencing project.</p><p>In this paper we proved the effectiveness of the first application. We showed how the Sanger-like-long reads can be used to feed another assembler (PHRAP [<xref ref-type="bibr" rid="B30">30</xref>] in our case, but many other solutions are possible) in order to obtain a standard assembly. This assembly is similar and often better than assemblies generated by state-of-the-art assemblers. In order to proof this we compare the results of our tool with the ones recently obtained by GAGE.</p><p>GapFiller's strength lies, on the one hand, in the ability to produce an output that does not need validation, and, on the other hand, in being a <italic>local </italic>assembler, making it useful when studying limited regions of a genome.</p><p>GapFiller's applications to structural variations analysis include indels detection and validation; in particular, it can be used to assemble insertions occurred in a sequenced organism, with respect to a reference genome. It is of primary importance to notice how, while there is a large number of tools able to <italic>identify </italic>structural variations, so far there is no widely accepted strategy to <italic>reconstruct </italic>structural variations in re-sequencing projects. We believe that the localized GapFiller strategy can be used in order to "fill this gap" and move several approaches from identification to reconstruction.</p></sec><sec><title>Availability and requirements</title><p>GapFiller can be freely downloaded from <ext-link ext-link-type="uri" xlink:href="http://users.dimi.uniud.it/~francesco.vezzi/software.php">http://users.dimi.uniud.it/~francesco.vezzi/software.php</ext-link>. It has been tested on Linux Operating systems only (Ubuntu and Centos distributions). It has been written in C++.</p></sec><sec><title>Abbreviations</title><p>NGS: Next Generation Sequencing.</p></sec><sec><title>Competing interests</title><p>The authors declare that they have no competing interests.</p></sec><sec><title>Authors' contributions</title><p>FN, FV, and AP equally contributed to the idea and equally contributed to the design of the experiments. FN and FV developed the tools and FN performed the experiments. FN, FV, and AP wrote the paper.</p></sec><sec><title>Appendix</title><p>SimSeq can be freely downloaded from <ext-link ext-link-type="uri" xlink:href="https://github.com/jstjohn/SimSeq">https://github.com/jstjohn/SimSeq</ext-link>.</p><p>Command lines for read simulation:</p><p>java -jar -Xmx2048m SimSeq.jar -1 100 -2 100 --error hiseq_mito_default_bwa_mapping_mq10_1.txt</p><p>--error2 hiseq_mito_default_bwa_mapping_mq10_2.txt --insert_size 600 --insert_stdev 200</p><p>--read_number PAIR_NUMBER --reference reference.fasta -o output.sam;</p><p>java -jar SamToFastq.jar INPUT=output.sam FASTQ=reads_1.fastq SECOND_END_FASTQ=reads_2.fastq</p><p>INCLUDE_NON_PF_READS=true VALIDATION_STRINGENCY=SILENT</p><p>KmerCounter can be freely downloaded from its git repository git clone</p><p><monospace>http://git://git.code.sf.net/p/kmercounter/code kmercounter-code. </monospace>Command line for KmerCounter<monospace>:</monospace></p><p>./kmers_count --input reads_1.fastq --input reads_2.fastq --threads NUM_THREADS</p><p>--output 16mer_profile.txt (--mark-reads READ_NAME)</p><p>Command line for GapFiller:</p><p>./IGAassembler --k 15 --output output.fasta --statistics output.stat --overlap 50 --slack 40</p><p>--short-1 seed_reads.fasta --short-2 seed_mates.fasta (--short-1 reads1.fasta</p><p>--short-2 reads2.fasta) --short-ins AVG_INSERT_SIZE --short-var INSERT_SIZE_ST_DEV</p><p>--read-length AVG_READ_LENGTH --global-mismatch 10 --extThr 2 --limit NUM_SEEDS_TO_EXTEND</p><p>--no-read-cycle --max-length MAX_CTG_LENGTH</p></sec></body><back><sec><title>Acknowledgements</title><p>The autors would like to thank IGA staff for support and interaction, in particular Simone Scalabrin, whose suggestions helped us in substantially improving the results.</p><p>This article has been published as part of <italic>BMC Bioinformatics </italic>Volume 13 Supplement 14, 2012: Selected articles from Research from the Eleventh International Workshop on Network Tools and Applications in Biology (NETTAB 2011). The full contents of the supplement are available online at <ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/13/S14">http://www.biomedcentral.com/1471-2105/13/S14</ext-link></p></sec><ref-list><ref id="B1"><mixed-citation publication-type="journal"><name><surname>Miller</surname><given-names>JR</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Sutton</surname><given-names>G</given-names></name><article-title>Assembly algorithms for next-generation sequencing data</article-title><source>Genomics</source><year>2010</year><volume>95</volume><issue>6</issue><fpage>315</fpage><lpage>327</lpage><pub-id pub-id-type="doi">10.1016/j.ygeno.2010.03.001</pub-id><pub-id pub-id-type="pmid">20211242</pub-id></mixed-citation></ref><ref id="B2"><mixed-citation publication-type="journal"><name><surname>Nagarajan</surname><given-names>N</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><article-title>Parametric complexity of sequence assembly: theory and applications to next generation sequencing</article-title><source>Journal of Computational Biology</source><year>2009</year><volume>16</volume><issue>7</issue><fpage>897</fpage><lpage>908</lpage><pub-id pub-id-type="doi">10.1089/cmb.2009.0005</pub-id><pub-id pub-id-type="pmid">19580519</pub-id></mixed-citation></ref><ref id="B3"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Fan</surname><given-names>W</given-names></name><name><surname>Zhu</surname><given-names>H</given-names></name><name><surname>He</surname><given-names>L</given-names></name><name><surname>Cai</surname><given-names>J</given-names></name><name><surname>Huang</surname><given-names>Q</given-names></name><name><surname>Cai</surname><given-names>Q</given-names></name><name><surname>Li</surname><given-names>B</given-names></name><name><surname>Bai</surname><given-names>Y</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Zhang</surname><given-names>Y</given-names></name><name><surname>Wang</surname><given-names>W</given-names></name><name><surname>Li</surname><given-names>J</given-names></name><name><surname>Wei</surname><given-names>F</given-names></name><name><surname>Li</surname><given-names>H</given-names></name><name><surname>Jian</surname><given-names>M</given-names></name><name><surname>Li</surname><given-names>J</given-names></name><name><surname>Zhang</surname><given-names>Z</given-names></name><name><surname>Nielsen</surname><given-names>R</given-names></name><name><surname>Li</surname><given-names>D</given-names></name><name><surname>Gu</surname><given-names>W</given-names></name><name><surname>Yang</surname><given-names>Z</given-names></name><name><surname>Xuan</surname><given-names>Z</given-names></name><name><surname>Ryder</surname><given-names>OA</given-names></name><name><surname>Chi-Ching Leung</surname><given-names>F</given-names></name><name><surname>Zhou</surname><given-names>Y</given-names></name><name><surname>Cao</surname><given-names>J</given-names></name><name><surname>Sun</surname><given-names>X</given-names></name><name><surname>Fu</surname><given-names>Y</given-names></name><name><surname>Fang</surname><given-names>X</given-names></name><etal/><article-title>The sequence and de novo assembly of the giant panda genome</article-title><source>Nature</source><year>2009</year><volume>463</volume><issue>7279</issue><fpage>311</fpage><lpage>317</lpage><pub-id pub-id-type="pmid">20010809</pub-id></mixed-citation></ref><ref id="B4"><mixed-citation publication-type="journal"><name><surname>Li</surname><given-names>R</given-names></name><name><surname>Zhu</surname><given-names>H</given-names></name><name><surname>Ruan</surname><given-names>J</given-names></name><name><surname>Qian</surname><given-names>W</given-names></name><name><surname>Fang</surname><given-names>X</given-names></name><name><surname>Shi</surname><given-names>Z</given-names></name><name><surname>Li</surname><given-names>Y</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Shan</surname><given-names>G</given-names></name><name><surname>Kristiansen</surname><given-names>K</given-names></name><name><surname>Li</surname><given-names>S</given-names></name><name><surname>Yang</surname><given-names>H</given-names></name><name><surname>Wang</surname><given-names>J</given-names></name><name><surname>Wang</surname><given-names>J</given-names></name><etal/><article-title>De novo assembly of human genomes with massively parallel short read sequencing</article-title><source>Genome Research</source><year>2010</year><volume>20</volume><issue>2</issue><fpage>265</fpage><lpage>72</lpage><pub-id pub-id-type="doi">10.1101/gr.097261.109</pub-id><pub-id pub-id-type="pmid">20019144</pub-id></mixed-citation></ref><ref id="B5"><mixed-citation publication-type="other"><article-title>Assemblathon</article-title><ext-link ext-link-type="uri" xlink:href="http://assemblathon.org/">http://assemblathon.org/</ext-link></mixed-citation></ref><ref id="B6"><mixed-citation publication-type="journal"><name><surname>Paszkiewicz</surname><given-names>K</given-names></name><name><surname>Studholme</surname><given-names>DJ</given-names></name><article-title>De novo assembly of short sequence reads</article-title><source>Briefings in bioinformatics</source><year>2010</year><volume>11</volume><issue>5</issue><fpage>457</fpage><lpage>472</lpage><pub-id pub-id-type="doi">10.1093/bib/bbq020</pub-id><pub-id pub-id-type="pmid">20724458</pub-id></mixed-citation></ref><ref id="B7"><mixed-citation publication-type="journal"><name><surname>Earl</surname><given-names>DA</given-names></name><name><surname>Bradnam</surname><given-names>K</given-names></name><name><surname>St John</surname><given-names>J</given-names></name><name><surname>Darling</surname><given-names>A</given-names></name><name><surname>Lin</surname><given-names>D</given-names></name><name><surname>Faas</surname><given-names>J</given-names></name><name><surname>Yu</surname><given-names>HOK</given-names></name><name><surname>Vince</surname><given-names>B</given-names></name><name><surname>Zerbino</surname><given-names>DR</given-names></name><name><surname>Diekhans</surname><given-names>M</given-names></name><name><surname>Nguyen</surname><given-names>N</given-names></name><name><surname>Nuwantha</surname><given-names>P</given-names></name><name><surname>Sung</surname><given-names>AWK</given-names></name><name><surname>Ning</surname><given-names>Z</given-names></name><name><surname>Haimel</surname><given-names>M</given-names></name><name><surname>Simpson</surname><given-names>JT</given-names></name><name><surname>Fronseca</surname><given-names>NA</given-names></name><name><surname>Birol</surname><given-names>I</given-names></name><name><surname>Docking</surname><given-names>TR</given-names></name><name><surname>Ho</surname><given-names>IY</given-names></name><name><surname>Rokhsar</surname><given-names>DS</given-names></name><name><surname>Chikhi</surname><given-names>R</given-names></name><name><surname>Lavenier</surname><given-names>D</given-names></name><name><surname>Chapuis</surname><given-names>G</given-names></name><name><surname>Naquin</surname><given-names>D</given-names></name><name><surname>Maillet</surname><given-names>N</given-names></name><name><surname>Schatz</surname><given-names>MC</given-names></name><name><surname>Kelly</surname><given-names>DR</given-names></name><name><surname>Phillippy</surname><given-names>AM</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><etal/><article-title>Assemblathon 1: A competitive assessment of de novo short read assembly methods</article-title><source>Genome Research</source><year>2011</year><volume>21</volume><issue>12</issue><fpage>2224</fpage><lpage>2241</lpage><pub-id pub-id-type="doi">10.1101/gr.126599.111</pub-id><pub-id pub-id-type="pmid">21926179</pub-id></mixed-citation></ref><ref id="B8"><mixed-citation publication-type="other"><article-title>dnGASP</article-title><ext-link ext-link-type="uri" xlink:href="http://cnag.bsc.es/">http://cnag.bsc.es/</ext-link></mixed-citation></ref><ref id="B9"><mixed-citation publication-type="journal"><name><surname>Salzberg</surname><given-names>SL</given-names></name><name><surname>Phillippy</surname><given-names>AM</given-names></name><name><surname>Zimin</surname><given-names>AV</given-names></name><name><surname>Puiu</surname><given-names>D</given-names></name><name><surname>Magoc</surname><given-names>T</given-names></name><name><surname>Koren</surname><given-names>S</given-names></name><name><surname>Treangen</surname><given-names>T</given-names></name><name><surname>Schatz</surname><given-names>MC</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Roberts</surname><given-names>M</given-names></name><name><surname>Marcais</surname><given-names>G</given-names></name><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Yorke</surname><given-names>JA</given-names></name><article-title>GAGE: A critical evaluation of genome assemblies and assembly algorithms</article-title><source>Genome Research</source><year>2011</year><volume>22</volume><fpage>557</fpage><lpage>567</lpage><ext-link ext-link-type="uri" xlink:href="http://genome.cshlp.org/content/22/3/557">http://genome.cshlp.org/content/22/3/557</ext-link><comment>http://www.ncbi.nlm.nih.gov/pubmed/22147368</comment><pub-id pub-id-type="pmid">22147368</pub-id></mixed-citation></ref><ref id="B10"><mixed-citation publication-type="journal"><name><surname>Alkan</surname><given-names>C</given-names></name><name><surname>Sajjadian</surname><given-names>S</given-names></name><name><surname>Eichler</surname><given-names>E</given-names></name><article-title>Limitations of next-generation genome sequence assembly</article-title><source>Nature methods</source><year>2010</year><volume>8</volume><fpage>61</fpage><lpage>65</lpage><pub-id pub-id-type="pmid">21102452</pub-id></mixed-citation></ref><ref id="B11"><mixed-citation publication-type="journal"><name><surname>Narzisi</surname><given-names>G</given-names></name><name><surname>Mishra</surname><given-names>B</given-names></name><article-title>Comparing de novo genome assembly: the long and short of it</article-title><source>PLoS ONE</source><year>2011</year><volume>6</volume><issue>4</issue><fpage>e19175</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0019175</pub-id><pub-id pub-id-type="pmid">21559467</pub-id></mixed-citation></ref><ref id="B12"><mixed-citation publication-type="journal"><name><surname>Vezzi</surname><given-names>F</given-names></name><name><surname>Narzisi</surname><given-names>G</given-names></name><name><surname>Mishra</surname><given-names>B</given-names></name><article-title>Feature-by-Feature, evaluating de novo sequence assembly</article-title><source>PLoS ONE</source><year>2012</year><volume>7</volume><issue>2</issue><fpage>e31002</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0031002</pub-id><pub-id pub-id-type="pmid">22319599</pub-id></mixed-citation></ref><ref id="B13"><mixed-citation publication-type="other"><name><surname>Nadalin</surname><given-names>F</given-names></name><name><surname>Vezzi</surname><given-names>F</given-names></name><name><surname>Policriti</surname><given-names>A</given-names></name><article-title>GapFiller: a preprocessing step for the de novo assembly problem [abstract]</article-title><source>Proceedings on the 8th annual meeting of the Bioinformatics Italian Society</source><year>2011</year><fpage>13</fpage><lpage>14</lpage><ext-link ext-link-type="uri" xlink:href="http://www.bits2011.it/index.php?pg=show&#x00026;id=19">http://www.bits2011.it/index.php?pg=show&#x00026;id=19</ext-link></mixed-citation></ref><ref id="B14"><mixed-citation publication-type="journal"><name><surname>Warren</surname><given-names>RL</given-names></name><name><surname>Sutton</surname><given-names>GG</given-names></name><name><surname>Jones</surname><given-names>SJM</given-names></name><name><surname>Holt</surname><given-names>RA</given-names></name><article-title>Assembling millions of short DNA sequences using SSAKE</article-title><source>Bioinformatics</source><year>2007</year><volume>23</volume><issue>4</issue><fpage>500</fpage><lpage>501</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btl629</pub-id><pub-id pub-id-type="pmid">17158514</pub-id></mixed-citation></ref><ref id="B15"><mixed-citation publication-type="journal"><name><surname>Dohm</surname><given-names>JC</given-names></name><name><surname>Lottaz</surname><given-names>C</given-names></name><name><surname>Borodina</surname><given-names>T</given-names></name><name><surname>Himmelbauer</surname><given-names>H</given-names></name><article-title>SHARCGS, a fast and highly accurate short-read assembly algorithm for de novo genomic sequencing</article-title><source>Genome Research</source><year>2007</year><volume>17</volume><issue>11</issue><fpage>1697</fpage><lpage>1706</lpage><pub-id pub-id-type="doi">10.1101/gr.6435207</pub-id><pub-id pub-id-type="pmid">17908823</pub-id></mixed-citation></ref><ref id="B16"><mixed-citation publication-type="journal"><name><surname>Bryant</surname><given-names>DW</given-names></name><name><surname>Wong</surname><given-names>WK</given-names></name><name><surname>Mockler</surname><given-names>TC</given-names></name><article-title>QSRA: a quality-value guided de novo short read assembler</article-title><source>BMC Bioinformatics</source><year>2009</year><volume>10</volume><fpage>69</fpage><pub-id pub-id-type="doi">10.1186/1471-2105-10-69</pub-id><pub-id pub-id-type="pmid">19239711</pub-id></mixed-citation></ref><ref id="B17"><mixed-citation publication-type="journal"><name><surname>Schmidt</surname><given-names>B</given-names></name><name><surname>Sinha</surname><given-names>R</given-names></name><name><surname>Beresford-Smith</surname><given-names>B</given-names></name><name><surname>Puglisi</surname><given-names>SJ</given-names></name><article-title>A fast hybrid short read fragment assembly algorithm</article-title><source>Bioinformatics (Oxford, England)</source><year>2009</year><volume>25</volume><issue>17</issue><fpage>2279</fpage><lpage>80</lpage><ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/19535537">http://www.ncbi.nlm.nih.gov/pubmed/19535537</ext-link><pub-id pub-id-type="doi">10.1093/bioinformatics/btp374</pub-id></mixed-citation></ref><ref id="B18"><mixed-citation publication-type="journal"><name><surname>Rodrigue</surname><given-names>S</given-names></name><name><surname>Materna</surname><given-names>AC</given-names></name><name><surname>Timberlake</surname><given-names>SC</given-names></name><name><surname>Blackburn</surname><given-names>MC</given-names></name><name><surname>Malmstrom</surname><given-names>RR</given-names></name><name><surname>Alm</surname><given-names>EJ</given-names></name><name><surname>Chisholm</surname><given-names>SW</given-names></name><article-title>Unlocking short read sequencing for metagenomics</article-title><source>PLoS ONE</source><year>2010</year><volume>5</volume><issue>7</issue><fpage>e11840</fpage><pub-id pub-id-type="doi">10.1371/journal.pone.0011840</pub-id><pub-id pub-id-type="pmid">20676378</pub-id></mixed-citation></ref><ref id="B19"><mixed-citation publication-type="journal"><name><surname>Mago&#x0010d;</surname><given-names>T</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name><article-title>FLASH: fast length adjustment of short reads to improve genome assemblies</article-title><source>Bioinformatics (Oxford, England)</source><year>2011</year><volume>27</volume><issue>21</issue><fpage>2957</fpage><lpage>2963</lpage><ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov/pubmed/21903629">http://www.ncbi.nlm.nih.gov/pubmed/21903629</ext-link><pub-id pub-id-type="doi">10.1093/bioinformatics/btr507</pub-id></mixed-citation></ref><ref id="B20"><mixed-citation publication-type="journal"><name><surname>Vezzi</surname><given-names>F</given-names></name><name><surname>Del Fabbro</surname><given-names>C</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Policriti</surname><given-names>A</given-names></name><article-title>rNA: a fast and accurate short reads numerical aligner</article-title><source>Bioinformatics</source><year>2011</year><volume>28</volume><fpage>123</fpage><lpage>124</lpage><pub-id pub-id-type="pmid">22084252</pub-id></mixed-citation></ref><ref id="B21"><mixed-citation publication-type="journal"><name><surname>Karp</surname><given-names>R</given-names></name><name><surname>Rabin</surname><given-names>M</given-names></name><article-title>Efficient randomized pattern-matching algorithms</article-title><source>IBM Journal of Research and Development</source><year>1987</year><volume>31</volume><issue>2</issue><fpage>249</fpage><lpage>260</lpage></mixed-citation></ref><ref id="B22"><mixed-citation publication-type="other"><name><surname>Policriti</surname><given-names>A</given-names></name><name><surname>Tomescu</surname><given-names>AI</given-names></name><name><surname>Vezzi</surname><given-names>F</given-names></name><article-title>A randomized Numerical Aligner (rNA)</article-title><source>Journal of Computer and System Sciences</source><comment> in press <ext-link ext-link-type="uri" xlink:href="http://dx.doi.org/10.1016/j.jcss.2011.12.007">http://dx.doi.org/10.1016/j.jcss.2011.12.007</ext-link></comment></mixed-citation></ref><ref id="B23"><mixed-citation publication-type="journal"><name><surname>Kelley</surname><given-names>DR</given-names></name><name><surname>Schatz</surname><given-names>MC</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name><article-title>Quake: quality-aware detection and correction of sequencing errors</article-title><source>Genome biology</source><year>2010</year><volume>11</volume><issue>11</issue><fpage>R116</fpage><pub-id pub-id-type="doi">10.1186/gb-2010-11-11-r116</pub-id><pub-id pub-id-type="pmid">21114842</pub-id></mixed-citation></ref><ref id="B24"><mixed-citation publication-type="journal"><name><surname>Medvedev</surname><given-names>P</given-names></name><name><surname>Scott</surname><given-names>E</given-names></name><name><surname>Kakaradov</surname><given-names>B</given-names></name><name><surname>Pevzner</surname><given-names>P</given-names></name><article-title>Error correction of high-throughput sequencing datasets with non-uniform coverage</article-title><source>Bioinformatics</source><year>2011</year><volume>27</volume><issue>13</issue><fpage>i137</fpage><lpage>i141</lpage><pub-id pub-id-type="doi">10.1093/bioinformatics/btr208</pub-id><pub-id pub-id-type="pmid">21685062</pub-id></mixed-citation></ref><ref id="B25"><mixed-citation publication-type="journal"><name><surname>Gnerre</surname><given-names>S</given-names></name><name><surname>MacCallum</surname><given-names>I</given-names></name><name><surname>Przybylski</surname><given-names>D</given-names></name><name><surname>Ribeiro</surname><given-names>FJ</given-names></name><name><surname>Burton</surname><given-names>JN</given-names></name><name><surname>Walker</surname><given-names>BJ</given-names></name><name><surname>Sharpe</surname><given-names>T</given-names></name><name><surname>Hall</surname><given-names>G</given-names></name><name><surname>Shea</surname><given-names>TP</given-names></name><name><surname>Sykes</surname><given-names>S</given-names></name><name><surname>Berlin</surname><given-names>AM</given-names></name><name><surname>Aird</surname><given-names>D</given-names></name><name><surname>Costello</surname><given-names>M</given-names></name><name><surname>Daza</surname><given-names>R</given-names></name><name><surname>Williams</surname><given-names>L</given-names></name><name><surname>Nicol</surname><given-names>R</given-names></name><name><surname>Gnirke</surname><given-names>A</given-names></name><name><surname>Nusbaum</surname><given-names>C</given-names></name><name><surname>Lander</surname><given-names>ES</given-names></name><name><surname>Jaffe</surname><given-names>DB</given-names></name><article-title>High-quality draft assemblies of mammalian genomes from massively parallel sequence data</article-title><source>Proceedings of the National Academy of Sciences</source><year>2010</year><volume>108</volume><issue>4</issue><fpage>1513</fpage><lpage>1518</lpage><ext-link ext-link-type="uri" xlink:href="http://www.pnas.org/cgi/doi/10.1073/pnas.1017351108">http://www.pnas.org/cgi/doi/10.1073/pnas.1017351108</ext-link></mixed-citation></ref><ref id="B26"><mixed-citation publication-type="journal"><name><surname>Mar&#x000e7;ais</surname><given-names>G</given-names></name><name><surname>Kingsford</surname><given-names>C</given-names></name><article-title>A fast, lock-free approach for efficient parallel counting of occurrences of k-mers</article-title><source>Bioinformatics (Oxford, England)</source><year>2011</year><volume>27</volume><issue>6</issue><fpage>764</fpage><lpage>770</lpage><ext-link ext-link-type="uri" xlink:href="http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btr011v1">http://bioinformatics.oxfordjournals.org/cgi/content/abstract/btr011v1</ext-link><pub-id pub-id-type="doi">10.1093/bioinformatics/btr011</pub-id></mixed-citation></ref><ref id="B27"><mixed-citation publication-type="other"><article-title>NCBI</article-title><ext-link ext-link-type="uri" xlink:href="http://www.ncbi.nlm.nih.gov">http://www.ncbi.nlm.nih.gov</ext-link></mixed-citation></ref><ref id="B28"><mixed-citation publication-type="other"><article-title>GAGE</article-title><ext-link ext-link-type="uri" xlink:href="http://gage.cbcb.umd.edu">http://gage.cbcb.umd.edu</ext-link></mixed-citation></ref><ref id="B29"><mixed-citation publication-type="journal"><name><surname>Smith</surname><given-names>TF</given-names></name><name><surname>Waterman</surname><given-names>MS</given-names></name><article-title>Identification of common molecular subsequences</article-title><source>Journal of molecular biology</source><year>1981</year><volume>147</volume><fpage>195</fpage><lpage>197</lpage><pub-id pub-id-type="doi">10.1016/0022-2836(81)90087-5</pub-id><pub-id pub-id-type="pmid">7265238</pub-id></mixed-citation></ref><ref id="B30"><mixed-citation publication-type="journal"><name><surname>de la Bastide</surname><given-names>M</given-names></name><name><surname>McCombie</surname><given-names>WR</given-names></name><article-title>Assembling Genomic DNA Sequences with PHRAP</article-title><source>Current Protocols in Bioinformatics</source><year>2007</year><volume>17</volume><issue>11</issue><fpage>11.4.1</fpage><lpage>11.4.15</lpage><ext-link ext-link-type="uri" xlink:href="http://www.currentprotocols.com/WileyCDA/CPUnit/refId-bi1104.html">http://www.currentprotocols.com/WileyCDA/CPUnit/refId-bi1104.html</ext-link></mixed-citation></ref></ref-list></back></article>